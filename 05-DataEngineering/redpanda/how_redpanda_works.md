- https://docs.redpanda.com/current/get-started/architecture/

# How Redpanda Works
Redpanda의 핵심은 이벤트 스트림을 저장하기 위한 내결함성 트랜잭션 로그입니다. 생산자와 소비자는 Kafka API를 사용하여 Redpanda와 상호 작용합니다. 높은 확장성을 달성하기 위해 생산자와 소비자는 완전히 분리되어 있습니다. Redpanda는 생산자에게 이벤트가 시스템 내에 영구적으로 저장된다는 강력한 보장을 제공하며, 소비자는 Redpanda를 구독하고 비동기적으로 이벤트를 읽을 수 있습니다.

Redpanda는 이벤트를 토픽으로 구성하여 이러한 디커플링을 달성합니다. 토픽은 동일한 로그에 기록되는 이벤트의 논리적 그룹을 나타냅니다. 토픽에는 여러 명의 생산자가 토픽에 이벤트를 작성하고 여러 명의 소비자가 토픽에서 이벤트를 읽을 수 있습니다.

이 페이지에서는 Redpanda의 작동 방식에 대해 자세히 설명합니다. 개략적인 개요는 Redpanda 소개를 참조하세요.

## Tiered Storage
레드판다 계층형 스토리지는 거의 실시간으로 로그 세그먼트를 오브젝트 스토리지로 오프로드할 수 있는 기능을 제공하는 다중 계층형 오브젝트 스토리지 솔루션입니다. 계층형 스토리지를 로컬 스토리지와 결합하여 주제별로 장기 데이터 보존 및 재해 복구를 제공할 수 있습니다.

최근 오프셋에서 읽는 소비자는 로컬 스토리지에서 계속 읽고, 과거 오프셋에서 읽는 소비자는 오브젝트 스토리지에서 읽으며, 이 모든 것이 동일한 API를 통해 이루어집니다. 소비자는 이벤트가 로컬 스토리지에 있든, 오브젝트 스토리지에 있든 상관없이 최대 보존 기간 내 어느 시점부터든 이벤트를 읽고 다시 읽을 수 있습니다.

오브젝트 스토리지의 데이터가 증가하면 그에 대한 메타데이터도 증가합니다. 효율적인 장기 데이터 보존을 지원하기 위해 Redpanda는 오브젝트 스토리지의 메타데이터를 분할하여 최근에 업데이트된 세그먼트의 메타데이터만 메모리 또는 로컬 디스크에 유지하고 나머지 메타데이터는 오브젝트 스토리지에 안전하게 보관하고 디스크에 로컬로 캐싱합니다. 아카이브된 메타데이터는 기록 데이터에 액세스할 때만 로드됩니다. 따라서 계층형 스토리지는 거의 모든 크기 또는 보존 기간의 파티션을 처리할 수 있습니다.

## Partitions
토픽을 확장하기 위해 Redpanda는 토픽을 클러스터의 노드에 분산된 하나 이상의 파티션으로 분할합니다. 이를 통해 여러 노드에서 동시에 쓰고 읽을 수 있습니다. 프로듀서가 토픽에 글을 쓰면 이벤트를 토픽의 파티션 중 하나로 라우팅합니다. 주식 시세와 같이 동일한 키를 가진 이벤트는 항상 동일한 파티션으로 라우팅되며, Redpanda는 파티션 수준에서 이벤트 순서를 보장합니다. 소비자는 작성된 순서대로 파티션에서 이벤트를 읽습니다. 키를 지정하지 않으면 이벤트는 라운드 로빈 방식으로 모든 토픽 파티션으로 전송됩니다.

## Raft consensus algorithm
Redpanda는 데이터 안전과 내결함성을 강력하게 보장합니다. 토픽 파티션에 기록된 이벤트는 디스크의 로그 파일에 추가됩니다. 이러한 이벤트는 클러스터의 다른 노드로 복제되어 디스크의 로그 파일 사본에 추가되어 장애 발생 시 데이터 손실을 방지할 수 있습니다. 데이터 복제에는 Raft 합의 알고리즘이 사용됩니다.

모든 토픽 파티션은 선출된 리더 한 명과 0명 이상의 팔로워(토픽의 복제 계수에 지정된 대로)로 구성된 Raft 그룹을 형성합니다. Raft 그룹은 노드가 2ƒ+1개일 때 ƒ개의 실패를 허용할 수 있습니다. 예를 들어 노드가 5개이고 복제 계수가 5인 토픽이 있는 클러스터에서 두 개의 노드에 장애가 발생해도 토픽은 계속 정상적으로 작동합니다.

래프트는 다수결 투표 알고리즘입니다. 리더가 파티션에 이벤트가 커밋되었음을 인정하려면 해당 복제본의 과반수가 해당 이벤트를 자신의 로그 사본에 기록해야 합니다. 과반수(정족수)의 응답이 수신되면 리더는 소비자에게 이벤트를 제공하고 acks=모두(-1)일 때 이벤트 수신을 승인할 수 있습니다. 프로듀서 승인 설정은 데이터를 전송하는 동안 프로듀서와 리더가 자신의 상태를 전달하는 방법을 정의합니다.

리더와 대다수의 레플리카가 안정적이라면, 레드판다는 소수의 레플리카의 장애를 견딜 수 있습니다. 회색 장애로 인해 소수의 복제본이 평소보다 느리게 응답하는 경우, 리더는 응답이 진행될 때까지 기다릴 필요가 없으며 추가 지연이 클라이언트에 전달되지 않습니다. 그 결과 Redpanda는 장애에 덜 민감하고 예측 가능한 성능을 제공할 수 있습니다.

## Partition leadership elections
Raft는 하트비트 메커니즘을 사용하여 리더의 권한을 유지하고 리더 선거를 트리거합니다. 파티션 리더는 모든 팔로워에게 주기적으로 하트비트를 보내 현재 임기(기본값 = 150밀리초)의 리더십을 주장합니다. 임기는 리더 선거가 트리거될 때 시작되는 임의의 기간입니다. 팔로워가 일정 기간(기본값 = 1.5초) 동안 하트비트를 받지 못하면 새로운 파티션 리더를 선출하기 위한 선거가 트리거됩니다. 팔로워는 자신의 임기를 늘리고 자신이 해당 임기의 리더가 되도록 투표합니다. 그런 다음 다른 노드에 투표 요청을 보내고 다음 시나리오 중 하나를 기다립니다:
- 과반수 이상의 표를 받은 후보가 리더가 됩니다. 래프트는 주어진 임기 동안 최대 한 명의 후보자만 리더로 선출될 수 있도록 보장합니다.

- 다른 팔로워가 리더로 선출됩니다. 투표를 기다리는 동안 후보자는 그룹 내 다른 노드로부터 자신이 리더임을 주장하는 통신을 받을 수 있습니다. 후보자는 해당 노드의 임기가 후보자의 임기보다 크거나 같은 경우에만 해당 주장을 수락하고, 그렇지 않으면 통신이 거부되고 후보자는 계속해서 투표를 기다립니다.

- 일정 기간 동안 리더가 선출되지 않습니다. 여러 명의 팔로워가 동시에 타임아웃되어 선거 후보자가 되면 과반수 득표를 얻은 후보자가 없을 수 있습니다. 이 경우, 각 후보자의 임기가 늘어나고 새로운 선거 라운드가 시작됩니다. Raft는 150~300밀리초 사이의 무작위 타임아웃을 사용하여 분할 투표가 드물게 발생하고 신속하게 해결되도록 합니다.

하트비트 시간, 선거 타임아웃, 노드 평균 고장 간격(MTBF) 사이에 타이밍 불균형이 존재하는 한, Raft는 안정적으로 리더를 선출하고 유지하며 발전할 수 있습니다. 리더는 1.5초마다 모든 팔로워에게 보내는 10개의 하트비트 메시지 중 하나가 수신되는 한 그 위치를 유지할 수 있으며, 그렇지 않으면 새로운 리더가 선출됩니다.

팔로워가 선거를 시작했지만 현직 리더가 다시 살아나서 데이터를 다시 보내기 시작하면 너무 늦은 것입니다. 선거 과정의 일환으로 팔로워(현재 선거 후보자)가 임기를 늘리고 이전 임기의 요청을 거부하여 사실상 리더십 변경을 강요한 것입니다. 클러스터에 광범위한 네트워크 인프라 문제가 발생하여 지연 시간이 하트비트 타임아웃을 초과하는 경우, 연이은 선거 라운드가 트리거될 수 있습니다. 이 기간 동안 불안정한 뗏목 그룹은 쿼럼을 구성하지 못할 수 있습니다. 이로 인해 파티션이 쓰기를 거부하지만 이전에 디스크에 기록된 데이터는 손실되지 않습니다. 레드판다에는 네트워크 중단 후 시스템이 빠르게 안정화될 수 있도록 하는 래프트 우선 순위 구현이 있습니다.

## Controller partition and snapshots
Redpanda는 메타데이터 업데이트 명령(예: 토픽 또는 사용자 생성 및 삭제)을 컨트롤러 파티션이라는 시스템 파티션에 저장합니다. 새 스냅샷은 각 컨트롤러 명령이 추가된 후 또는 빠른 업데이트의 경우 설정된 시간(기본값은 60초) 후에 생성됩니다. 컨트롤러 스냅샷은 현재 클러스터 메타데이터 상태를 디스크에 저장하므로 시작이 빠릅니다. 예를 들어, 파티션이 여러 번 이동한 경우 스냅샷은 모든 이동 명령을 재생하지 않고도 최신 상태로 복원할 수 있습니다.

각 브로커는 컨트롤러 로그 디렉터리(예: /var/lib/redpanda/data/redpanda/controller/0_0/snapshot)에 저장된 스냅샷 파일을 가지고 있습니다. 컨트롤러 파티션은 모든 클러스터 브로커를 포함하는 Raft 그룹에 의해 복제되며, 컨트롤러 스냅샷은 이 그룹에 대한 Raft 스냅샷입니다. 브로커가 클러스터에 참여하거나 다시 시작할 때 스냅샷이 하이드레이션됩니다. 컨트롤러 스냅샷은 기본적으로 새 클러스터에서만 사용하도록 설정됩니다. 기존 또는 업그레이드된 클러스터에서 컨트롤러 스냅샷을 활성화하려면 Redpanda 지원팀에 문의하세요.

## Optimized platform performance
레드판다는 네트워크에서 디스크에 이르기까지 최신 하드웨어의 발전을 활용하도록 설계되었습니다. 네트워크 대역폭은 특히 오브젝트 스토리지에서 상당히 증가했으며, 스피닝 디스크는 더 나은 I/O 성능을 제공하는 SSD 장치로 대체되었습니다. CPU도 더 빨라졌지만, 이는 단일 코어 속도의 증가가 아니라 코어 수가 증가했기 때문입니다. Redpanda에는 하드웨어 구성을 감지하여 자동으로 최적화하는 튜너가 있습니다.

Redpanda가 성능 최적화를 위해 사용하는 플랫폼 및 커널 기능의 예시:

- 디스크 I/O를 위한 직접 메모리 액세스(DMA)

- XFS를 통한 스파스 파일 시스템 지원

- CPU 코어 간 인터럽트 요청(IRQ) 처리 분산 처리

- 제어 그룹(c그룹)이 있는 격리된 프로세스

- CPU 절전 모드 비활성화

- CPU 코어에 파티셔닝 및 고정된 사전 메모리 할당

## Thread-per-core model
Redpanda는 Seastar 라이브러리를 사용하여 코어당 스레드 프로그래밍 모델을 구현합니다. 이를 통해 Redpanda는 각 애플리케이션 스레드를 CPU 코어에 고정하여 컨텍스트 전환 및 차단을 방지할 수 있습니다. 이를 구조화된 메시지 전달(SMP)과 결합하여 고정된 스레드 간에 비동기적으로 통신합니다. 이를 통해 Redpanda는 컨텍스트 전환과 고비용의 잠금 작업으로 인한 오버헤드를 방지하여 처리 성능과 효율성을 개선합니다.

규모 조정의 관점에서 볼 때, 사용 가능한 모든 하드웨어를 효율적으로 사용할 수 있는 Redpanda는 워크로드 수요를 충족하기 위해 강제로 스케일아웃하기 전에 인프라를 최대한 활용할 수 있도록 확장할 수 있습니다. Redpanda는 더 작은 설치 공간에서 더 나은 성능을 제공하므로 운영 비용과 복잡성을 줄일 수 있습니다.