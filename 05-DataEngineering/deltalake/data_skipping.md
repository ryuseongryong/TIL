- https://learn.microsoft.com/en-us/azure/databricks/delta/data-skipping

# Data Skipping

- 데이터 건너뛰기 정보는 Delta 테이블에 데이터를 쓸 때 자동으로 수집됩니다. Azure 데이터브릭의 델타 레이크는 쿼리 시 이 정보(최소값 및 최대값, null 개수, 파일당 총 레코드 수)를 활용하여 더 빠른 쿼리를 제공합니다.


- 데이터브릭스 런타임 13.3 이상에서 데이터브릭스는 델타 테이블 레이아웃에 클러스터링을 사용할 것을 권장합니다. 클러스터링은 Z 정렬과 호환되지 않습니다. 델타 테이블에 액체 클러스터링 사용을 참조하십시오.

## 델타 통계 열 지정
기본적으로 델타 레이크는 테이블 스키마에 정의된 처음 32개 열에 대한 통계를 수집합니다. 이 컬렉션의 경우 중첩된 열의 각 필드는 개별 열로 간주됩니다. 다음 테이블 속성 중 하나를 설정하여 이 동작을 수정할 수 있습니다:

- `delta.dataSkippingNumIndexedCols`(지원되는 모든 데이터브릭스 런타임 버전): 델타에서 통계를 수집하는 열의 수를 늘리거나 줄입니다. 열 순서에 따라 다릅니다.
- `delta.dataSkippingStatsColumns`(데이터브릭스 런타임 13.2 이상): 델타 레이크가 통계를 수집하는 열 이름 목록을 지정합니다. 데이터 스키핑 넘버 인덱스 컬럼을 대체합니다.

테이블 속성은 테이블 생성 시 또는 ALTER TABLE 문을 사용하여 설정할 수 있습니다. 델타 테이블 속성 참조를 참조하십시오.

이 속성을 업데이트해도 기존 데이터에 대한 통계가 자동으로 다시 계산되지는 않습니다. 그 대신 테이블에 데이터를 추가하거나 업데이트할 때 향후 통계 수집 동작에 영향을 미칩니다. 델타 레이크는 현재 통계 열 목록에 포함되지 않은 열에 대한 통계를 활용하지 않습니다.

데이터브릭스 런타임 14.3 LTS 이상에서는 다음 명령을 사용하여 델타 테이블에 대한 통계 재계산을 수동으로 트리거할 수 있습니다:

```
OPTIMIZE events
WHERE date >= current_timestamp() - INTERVAL 1 day
ZORDER BY (eventType)
```

## Z 정렬이란?

Z 정렬은 동일한 파일 집합에 관련 정보를 배치하는 기술입니다. 이 공동 위치는 Azure Databricks의 Delta Lake에서 데이터 건너뛰기 알고리즘에 의해 자동으로 사용됩니다. 이 동작은 Azure 데이터브릭의 델타 레이크가 읽어야 하는 데이터의 양을 크게 줄여줍니다. 데이터를 Z순으로 정렬하려면 ZORDER BY 절에서 정렬할 열을 지정합니다:

```
OPTIMIZE eventsWHERE date >= current_timestamp() - INTERVAL 1 dayZORDER BY (eventType)
```

열이 쿼리 술어에 일반적으로 사용될 것으로 예상되고 해당 열의 카디널리티가 높은 경우(즉, 고유 값이 많은 경우) ZORDER BY를 사용합니다.

쉼표로 구분된 목록으로 정렬 기준의 열을 여러 개 지정할 수 있습니다. 그러나 열이 추가될 때마다 로캘리티의 효율성이 떨어집니다. 통계가 수집되지 않은 열에 대한 Z 정렬은 비효율적이며 리소스 낭비입니다. 데이터 건너뛰기에는 최소, 최대 및 카운트와 같은 열 로컬 통계가 필요하기 때문입니다. 스키마에서 열을 재정렬하여 특정 열에 대한 통계 수집을 구성하거나 통계를 수집할 열의 수를 늘릴 수 있습니다.

Z-정렬은 무효가 아니라 증분 연산을 목표로 합니다. Z 정렬에 걸리는 시간은 여러 번 실행해도 줄어든다는 보장이 없습니다. 그러나 방금 Z 정렬된 파티션에 새 데이터가 추가되지 않은 경우 해당 파티션에 대한 또 다른 Z 정렬은 아무런 효과가 없습니다.

Z 정렬은 튜플 수와 관련하여 균형 잡힌 데이터 파일을 생성하는 것을 목표로 하지만, 반드시 디스크의 데이터 크기를 고려하지는 않습니다. 두 측정값은 대부분 상관관계가 있지만, 그렇지 않은 경우가 있어 작업 시간 최적화에 왜곡이 발생할 수 있습니다.

예를 들어, 날짜별로 정렬 하는 경우 가장 최근 레코드가 모두 과거 레코드보다 훨씬 더 넓은 경우(예: 더 긴 배열 또는 문자열 값), OPTIMIZE 작업의 작업 기간과 결과 파일 크기가 왜곡될 것으로 예상됩니다. 그러나 이는 OPTIMIZE 명령 자체의 문제일 뿐, 후속 쿼리에는 부정적인 영향을 미치지 않습니다.

