- https://trino.io/docs/current/overview/concepts.html
# Trino

트리노를 이해하려면 먼저 트리노 문서 전체에서 사용된 용어와 개념을 이해해야 합니다.

문과 쿼리는 쉽게 이해할 수 있지만, 최종 사용자는 효율적인 쿼리를 실행하기 위해 Trino를 최대한 활용하려면 단계 및 분할과 같은 개념에 익숙해야 합니다. 트리노 관리자 또는 트리노 기여자는 트리노의 단계 개념이 작업과 어떻게 매핑되는지, 작업에 데이터를 처리하는 일련의 드라이버가 어떻게 포함되어 있는지 이해해야 합니다.

이 섹션에서는 트리노 전반에 걸쳐 언급된 핵심 개념에 대한 명확한 정의를 제공하며, 가장 일반적인 것부터 가장 구체적인 것까지 정렬되어 있습니다.

## Architecture
Trino는 여러 서버에서 데이터를 병렬로 처리하는 분산 쿼리 엔진입니다. Trino 서버에는 코디네이터와 워커라는 두 가지 유형이 있습니다. 다음 섹션에서는 이러한 서버와 Trino 아키텍처의 다른 구성 요소에 대해 설명합니다.

### Cluster
트리노 클러스터는 코디네이터와 다수의 워커로 구성됩니다. 사용자는 SQL 쿼리 도구를 사용하여 코디네이터에 연결합니다. 코디네이터는 작업자와 협업합니다. 코디네이터와 작업자는 연결된데이터 소스에 액세스합니다. 이 액세스는 카탈로그에서 구성됩니다.

각 쿼리를 처리하는 것은 상태 저장 작업입니다. 워크로드는 코디네이터에 의해 조율되고 클러스터의 모든 워커에 병렬로 분산됩니다. 각 노드는 하나의 JVM 인스턴스에서 Trino를 실행하며, 처리는 스레드를 사용하여 더욱 병렬화됩니다.

### Coordinator
Trino 코디네이터는 문 구문 분석, 쿼리 계획, Trino 워커 노드 관리를 담당하는 서버입니다. Trino 설치의 "두뇌"이며 클라이언트가 실행을 위해 문을 제출하기 위해 연결하는 노드이기도 합니다. 모든 Trino 설치에는 한 명 이상의 Trino 작업자와 함께 Trino 코디네이터가 있어야 합니다. 개발 또는 테스트 목적으로 단일 Trino 인스턴스가 두 가지 역할을 모두 수행하도록 구성할 수 있습니다.

코디네이터는 각 워커의 활동을 추적하고 쿼리 실행을 조율합니다. 코디네이터는 일련의 단계를 포함하는 쿼리의 논리적 모델을 생성한 다음, Trino 작업자 클러스터에서 실행되는 일련의 연결된 작업으로 변환합니다.

코디네이터는 REST API를 사용하여 작업자 및 클라이언트와 소통합니다.

### Worker
Trino 워커는 Trino 설치의 서버로, 작업 실행 및 데이터 처리를 담당합니다. 워커 노드는 커넥터에서 데이터를 가져오고 서로 중간 데이터를 교환합니다. 코디네이터는 작업자로부터 결과를 가져와 최종 결과를 클라이언트에 반환하는 역할을 담당합니다.

Trino 워커 프로세스가 시작되면 코디네이터의 검색 서버에 자신을 알리고, 이를 통해 Trino 코디네이터가 작업을 실행할 수 있도록 합니다.

작업자는 REST API를 사용하여 다른 작업자 및 Trino 코디네이터와 소통합니다.

## Data sources
이 문서 전체에서 커넥터, 카탈로그, 스키마 및 테이블과 같은 용어를 읽게 됩니다. 이러한 기본 개념은 특정 데이터 소스에 대한 Trino의 모델을 다루며 다음 섹션에서 설명합니다.

### Connector
커넥터는 Hive 또는 관계형 데이터베이스와 같은 데이터 소스에 Trino를 적용합니다. 커넥터는 데이터베이스용 드라이버를 생각하는 것과 같은 방식으로 생각할 수 있습니다. 커넥터는 Trino가 표준 API를 사용하여 리소스와 상호 작용할 수 있도록 하는 Trino의 SPI를 구현한 것입니다.

Trino에는 JMX용 커넥터, 내장된 시스템 테이블에 액세스할 수 있는 시스템 커넥터, Hive 커넥터, TPC-H 벤치마크 데이터를 제공하도록 설계된 TPC-H 커넥터 등 여러 가지 내장 커넥터가 포함되어 있습니다. 많은 타사 개발자가 커넥터를 제공하여 Trino가 다양한 데이터 소스의 데이터에 액세스할 수 있도록 했습니다.

모든 카탈로그는 특정 커넥터와 연결되어 있습니다. 카탈로그 구성 파일을 살펴보면 각 파일에는 카탈로그 관리자가 특정 카탈로그에 대한 커넥터를 만드는 데 사용하는 필수 속성 connector.name이 포함되어 있음을 알 수 있습니다. 두 개 이상의 카탈로그가 동일한 커넥터를 사용하여 유사한 데이터베이스의 서로 다른 두 인스턴스에 액세스하도록 할 수 있습니다. 예를 들어, 두 개의 Hive 클러스터가 있는 경우, 하나의 Trino 클러스터에 두 개의 카탈로그를 구성하여 둘 다 Hive 커넥터를 사용하도록 하면 동일한 SQL 쿼리 내에서도 두 Hive 클러스터의 데이터를 쿼리할 수 있습니다.

### Catalog
Trino 카탈로그에는 스키마가 포함되어 있으며 커넥터를 통해 데이터 소스를 참조합니다. 예를 들어, JMX 커넥터를 통해 JMX 정보에 대한 액세스를 제공하도록 JMX 카탈로그를 구성할 수 있습니다. Trino에서 SQL 문을 실행하면 하나 이상의 카탈로그에 대해 실행하게 됩니다. 카탈로그의 다른 예로는 Hive 데이터 소스에 연결하기 위한 Hive 카탈로그가 있습니다.

Trino에서 테이블 주소를 지정할 때 정규화된 테이블 이름은 항상 카탈로그에 뿌리를 두고 있습니다. 예를 들어, hive.test_data.test라는 정규화된 테이블 이름은 하이브 카탈로그의 test_data 스키마에 있는 테스트 테이블을 가리킵니다.

카탈로그는 Trino 구성 디렉터리에 저장된 속성 파일에 정의됩니다.

### Schema
스키마는 테이블을 구성하는 방법입니다. 카탈로그와 스키마는 함께 쿼리할 수 있는 테이블 집합을 정의합니다. Trino로 Hive 또는 MySQL과 같은 관계형 데이터베이스에 액세스할 때 스키마는 대상 데이터베이스에서 동일한 개념으로 변환됩니다. 다른 유형의 커넥터는 기본 데이터 소스에 적합한 방식으로 테이블을 스키마로 구성하도록 선택할 수 있습니다.

### Table
테이블은 정렬되지 않은 행의 집합으로, 유형이 있는 명명된 열로 구성됩니다. 이는 모든 관계형 데이터베이스에서와 동일합니다. 소스 데이터에서 테이블로의 매핑은 커넥터에 의해 정의됩니다.

## Query execution model
Trino는 SQL 문을 실행하고 이러한 문을 쿼리로 변환하여 분산된 코디네이터 및 워커 클러스터에서 실행합니다.

### Statement
Trino는 ANSI 호환 SQL 문을 실행합니다. Trino 문서에서 문을 지칭할 때는 절, 표현식 및 술어로 구성된 ANSI SQL 표준에 정의된 문을 의미합니다.

이 섹션에서 문과 쿼리에 대해 별도의 개념을 나열하는 이유가 궁금한 독자도 있을 것입니다. 이는 Trino에서 문은 단순히 SQL로 작성된 문장의 텍스트 표현을 의미하기 때문에 필요합니다. 문이 실행되면 Trino는 쿼리 계획과 함께 쿼리를 생성한 다음 일련의 Trino 워커에 배포합니다.

### Query
Trino는 문을 구문 분석하면 이를 쿼리로 변환하고 분산 쿼리 계획을 생성한 다음, Trino 워커에서 실행되는 일련의 상호 연결된 단계로 실현합니다. Trino에서 쿼리에 대한 정보를 검색하면 문에 대한 응답으로 결과 집합을 생성하는 데 관여하는 모든 구성 요소의 스냅샷을 받게 됩니다.

문과 쿼리의 차이점은 간단합니다. 문은 Trino에 전달되는 SQL 텍스트로 생각할 수 있으며, 쿼리는 해당 문을 실행하기 위해 인스턴스화된 구성 및 구성 요소를 나타냅니다. 쿼리는 결과를 생성하기 위해 함께 작동하는 스테이지, 작업, 분할, 커넥터 및 기타 구성 요소와 데이터 소스를 포함합니다.

### Stage
Trino는 쿼리를 실행할 때 실행을 단계 계층 구조로 분할하여 실행합니다. 예를 들어, Trino가 Hive에 저장된 10억 개의 행에서 데이터를 집계해야 하는 경우, 분산 쿼리 계획의 여러 섹션을 구현하도록 설계된 여러 다른 단계의 출력을 집계하는 루트 단계를 생성하여 이를 수행합니다.

쿼리를 구성하는 단계의 계층 구조는 트리와 유사합니다. 모든 쿼리에는 다른 단계의 출력을 집계하는 역할을 하는 루트 단계가 있습니다. 스테이지란 코디네이터가 분산 쿼리 계획을 모델링하는 데 사용하는 것이지만, 스테이지 자체는 Trino 워커에서 실행되지 않습니다.

### Task
이전 섹션에서 언급했듯이, 스테이지는 분산 쿼리 계획의 특정 섹션을 모델링하지만, 스테이지 자체는 Trino 워커에서 실행되지 않습니다. 스테이지가 어떻게 실행되는지 이해하려면 스테이지가 Trino 워커 네트워크에 분산된 일련의 작업으로 구현된다는 점을 이해해야 합니다.

태스크는 분산 쿼리 계획이 일련의 단계로 분해된 후 태스크로 변환되고, 태스크는 다시 분할에 따라 작동하거나 처리하기 때문에 Trino 아키텍처에서 "작업 말"입니다. Trino 작업에는 입력과 출력이 있으며, 스테이지가 일련의 작업에 의해 병렬로 실행될 수 있는 것처럼, 작업은 일련의 드라이버와 병렬로 실행됩니다.

### Split
작업은 더 큰 데이터 세트의 섹션인 분할에서 작동합니다. 분산 쿼리 계획의 가장 낮은 수준의 단계는 커넥터의 분할을 통해 데이터를 검색하고, 분산 쿼리 계획의 높은 수준의 중간 단계는 다른 단계의 데이터를 검색합니다.

Trino가 쿼리를 예약할 때 코디네이터는 커넥터에 테이블에 사용할 수 있는 모든 분할 목록을 쿼리합니다. 코디네이터는 어떤 컴퓨터가 어떤 작업을 실행 중인지, 어떤 작업이 어떤 분할을 처리하고 있는지 추적합니다.

### Driver
작업에는 하나 이상의 병렬 드라이버가 포함됩니다. 드라이버는 데이터에 따라 작동하고 연산자를 결합하여 출력을 생성한 다음 태스크에 의해 집계된 다음 다른 단계의 다른 태스크에 전달됩니다. 드라이버는 연산자 인스턴스의 시퀀스 또는 드라이버를 메모리에 있는 연산자의 물리적 집합으로 생각할 수 있습니다. 트리노 아키텍처에서 가장 낮은 수준의 병렬 처리입니다. 드라이버에는 하나의 입력과 하나의 출력이 있습니다.

### Operator
오퍼레이터는 데이터를 소비, 변환, 생성합니다. 예를 들어 테이블 스캔은 커넥터에서 데이터를 가져와 다른 오퍼레이터가 사용할 수 있는 데이터를 생성하고, 필터 오퍼레이터는 데이터를 소비하고 입력 데이터에 술어를 적용하여 하위 집합을 생성합니다.

### Exchange
교환은 쿼리의 여러 단계에 대해 Trino 노드 간에 데이터를 전송합니다. 작업은 데이터를 출력 버퍼로 생성하고 교환 클라이언트를 사용하여 다른 작업의 데이터를 소비합니다.
