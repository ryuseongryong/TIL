# SeaweedFS

## Components
- 3가지 핵심 구성요소
- 마스터 서비스, 볼륨 서비스, 파일러 서비스(및 S3 서비스)로 구성됨
### 마스터 서비스
- 전체 SeaweedFS 클러스터에 대한 일관된 뷰를 소유
- Raft 프로토콜을 통해 선출된 리더가 모든 참여 노드에 클러스터에 대한 일관된 뷰를 전달하는 서버 클러스터
- Raft 프로토콜을 위해서는 홀수의 다수결로 마스터가 결정되며 낮은 수의 안정적인 서버가 더 선호됨
- 마스터 리더는 주기적인 Raft election을 통해 모든 마스터 서버 중 임의로 선택됨
- 리더는 파일 ID를 할당하고, 오브젝트를 저장할 볼륨을 지정하고, 클러스터의 일부가 될 노드를 결정하는 권한도 가짐
- 모든 볼륨 서버에서 리더에게 heartbeat를 전송하고, 리더는 이를 통해 트래픽을 라우팅할 위치와 replication을 결정함
- 리더를 사용할 수 없는 경우, Raft 합의 프로토콜은 전체 클러스터의 동의를 얻어 새로운 리더를 임명하고 부재중인 기존 리더는 다시 정상적으로 작동할 때까지 강등됨
### 볼륨 서비스
- 많은 객체(files, chunks of files)를 디스크의 임의의 큰 블록이 될 수 있는 큰 개별 볼륨에 효율적으로 패킹함
- 데이터의 Redundancy, Replication은 객체 단위가 아닌 볼륨 수준에서 관리됨
- 각 볼륨 서버는 마스터를 통해 상태 및 볼륨 정보가 포함된 주기적인 heartbeat를 리더에게 전송함
- 볼륨의 컬렉션 개념
    - 하나의 컬렉션은 볼륨의 그룹
    - 컬렉션 내 볼륨이 없으면 자동 생성
    - TTL, Replication 설정은 각 볼륨에 대한 설정(하나의 컬렉션에 서로 다른 TTL, Replicatioin 설정의 볼륨이 있을 수 있음)
    - 컬렉션의 모든 볼륨을 제거하기만 하면 되므로 컬렉션을 빠르게 삭제 할 수 있음
    - s3 서비스의 경우, 각 버킷에 전용 컬렉션이 있고, 버킷을 삭제하는 것도 빠름
    - 하나의 컬렉션에는 여러 개의 볼륨이 필요함

### 파일러 서비스
- SeaweedFS 볼륨과 객체를 HTTP 또는 Unix FUSE 마운트를 통해 사용자가 볼 수 있는 경로(URL / FS)로 구성함
- Filer는 수정 없이 기존 애플리케이션에 정상적으로 보이는 파일 시스템 / 다운로드, 업로드용 웹 API를 제공하는 데 사용할 수 있는 편리하고 일반적인 추상화를 제공함
### S3 서비스
- 파일러 서비스와 유사한 AWS style S3 버킷을 제공함
- 별도로 시작하거나 파일러와 함께 시작할 수 있음

## FAQ
### 얼마나 많은 볼륨이 필요한가?
- SeaweedFS의 볼륨은 일반적인 storage에서 사용되는 볼륨과 다르다. 데이터 배치, 복제, 수집, 디스크 유형, S3 버킷, TTL, CSI 마운트 등 모두 볼륨을 기반으로 동작한다. 따라서 `no free volumes left` 에러가 발생하면 볼륨을 추가해줘야 한다. 
- 아래는 다른 볼륨 세트가 필요한 경우이다.
    - 다른 Replication
    - 다른 Collection
    - 다른 TTL
    - 디스크 유형이 다른 경우
    - 다른 S3 버킷이 컬렉션에 매핑된 경우
    - CSI 마운트는 볼륨이 필요한 버킷에 자동 매핑됨
- 기본 볼륨 크기는 30GB, 개수 기본값은 8개이지만, master를 실행할 때, `-volumeSizeLimitMB` 설정, volume을 실행할 때 `-max` 설정으로 조절할 수 있다.
- `volumePreallocate는` 볼륨에 디스크 공간을 사전 할당한다. 이러한 디스크 공간은 할당된 볼륨이 사용하는 것이며 볼륨이 가득 차 있지 않아 df 명령이 사용 가능하더라도 다른 볼륨에서 사용할 수 없다.
- 디스크 유형의 경우, 기본적으로 비어있거나 hdd로 간주한다. 디스크 유형이 hdd가 아닌 ssd라도 모든 볼륨이 동일한 디스크 타입인 경우 비워두어야 한다. 디스크 유형은 볼륨을 그룹화하기 위한 태그일 뿐이다.
### 디스크에서 삭제된 파일이 바로 release되지 않는 이유?
- 디스크 공간은 volume이 vacuume될 때 release된다.
- 기본적으로 garbage 비율이 30% 이상일 때 vacuume이 동작하도록 설정되어 있다.
- `weed shell`에서 `volume.vacuum -garbageThreshold=0.0001`로 바로 실행할 수 있다.(default is `-garbabeThreshold=0.3`)
### 데이터 보호에 대해서
- SSD 친화적 : SeaweedFS데이터는 모두 추가 전용(append-only)이므로 디스크의 쓰기 횟수가 제한된 SSD에 스트레스를 덜 준다. 동일한 SSD 셸에 대한 쓰기를 최대로 줄여 수명을 늘릴 수 있다.
- Bitrot Protection : 볼륨 서버의 항목은 서버 측에서 변경이 가능한지 CRC를 검사하고 Etag를 통해 액세스할 수 있다. 파일러 및 S3 API의 경우 클라이언트에서 MD5 Etag를 통해 파일을 확인할 수 있다.
- Replication : 각 파일 별 Replication 전략을 가질 수 있다. Erasure Coding은 공간 절약과 4개의 데이터 조각 손실도 견딜 수 있다.
- Encryption : 파일러는 암호화 키가 파일러 메타데이터 저장소에 저장된 AES256 암호화 모드로 실행할 수 있다. 따라서 볼륨 서버는 원격 또는 클라우드 등 어디서나 안전하게 실행할 수 있다. 
- Secure Connection : 마스터, 볼륨 서버, 파일러, 클라이언트 등 모든 구성 요소 간 모든 통신에 SSL/TLS를 사용하도록 설정할 수 있다. 모든 클라이언트가 볼륨 서버에 데이터를 업로드 할 수 있도록 JWT를 활성화하여 안전하게 허용할 수 있다.
- Access Control : AWS S3 API로 자격 증명을 확인하고 액세스 제어를 적용할 수 있다.

## volume 저장 파일 분석
- 파일을 저장하게 되면 볼륨에 `.dat`, `.idx`, `.vif`가 생성된다.
- dat에는 볼륨에 저장된 파일의 실제 이진 데이터가 포함되어 있다. 고가용성과 내구성을 위해 chunk로 분할하여 클러스터 전체에 분산된다. 각 chunk는 클러스터의 별도 노드에 저장되며 독립적으로 액세스/검색할 수 있다.
- idx에는 파일 이름, 크기, 볼륨 내 위치를 포함하여 볼륨에 저장된 모든 파일의 메타데이터가 포함된다. SeaweedFS에서 디스크의 데이터를 빠르게 찾고 효율적인 파일 조회 및 검색 작업을 지원한다.
- vif에는 추가적인 메타데이터와 볼륨에 저장된 파일에 대한 사용자 지정 정보를 저장한다. SeaweedFS 자체에서는 사용하지 않고 파일에 추가 정보 저장을 위해 SeaweedFS 통합 애플리케이션에서 사용할 수 있다.