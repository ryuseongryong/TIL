- https://lms.kmooc.kr/course/view.php?id=10039#section-2

# 데이터베이스의 등장 배경과 개념
- 데이터 처리 및 저장
- 데이터를 다루는 전통적인 방법
    1. 저장(정형화됨, 파일 시스템)
    2. 처리(개별 프로그램을 작성하여 처리)
- 파일시스템의 문제점
    1. 데이터 종속성(data dependency) : 데이터를 이용하는 응용 프로그램이 데이터의 구조(파일구조)의 변화에 영향을 받는 현상
    2. 데이터 무결성(data integrity)의 침해 : 데이터가 오류가 없는 정확한 값을 저장하고 있어야 함을 의미
    3. 데이터 중복성(data redundancy)과 데이터 불일치(data inconsistency) : 동일한 데이터가 여러 곳에 저장, 관리됨 = 저장공간 낭비, 보안 어려움 / 여러 곳에 저장된 동일 데이터의 내용이 다른 문제
    4. 데이터 보안성(data security)의 결여
- 대안으로 등장한 것이 데이터베이스 시스템
    - 데이터베이스와 DBMS, 두 가지로 구성됨
    - 데이터베이스 : 모아둔 데이터의 집합
    - DBMS : 데이터베이스를 관리하는 소프트웨어(Database Management System)
    - 파일 시스템에서는 파일에 직접 접근, 데이터베이스 시스템에서는 DBMS를 통해서만 접근
    1. 데이터 중복성 제거
    2. 보안성 강화
    3. 데이터 무결성 강화
    4. 데이터 종속성 완화
    - 과거 파일시스템의 문제점이 해결되었기 때문에 많이 사용됨
- 여러 종류의 데이터베이스 중 관계형 데이터베이스가 대부분 차지함.
    - 1970. IBM E.F.Codd 박사에 의해 관계형 데이터베이스 이론 제안
            Oracle 발표
    - 1983. IBM DB2 발표
    
# 실습환경 구축
- mysql community server download

---

# 데이터베이스 맛보기
- show databases;
- world database, sakila database 추가
    - download, source ~/filepath로 추가
- use world;
- show tables;
- desc country;
- select name, population from country where continent = 'Asia';
- select name, population from country where name = 'South Korea';

# 데이터베이스 시스템의 개념
- sql이라는 언어를 통해서 데이터베이스를 이용
- 데이터베이스 시스템은 DBMS <-> Database[File0, File1, File2] 구조
    - DBMS : 관리 SW
    - 데이터베이스 : 데이터의 집합체
    - 데이터의 저장 단위인 파일 = Table
- 데이터베이스 : 데이터를 한 곳에 체계적으로 모아 놓은 데이터 저장소 = 데이터 뱅크
    - 데이터베이스는 보통 물리 저장장치인 하드디스크에 구현함
    - 특정 폴더 아래 테이블을 파일 형태로 저장하는 형태가 있고,
    - 하나의 커다란 파일 안에 테이블을 저장하는 형태가 있다.
    - e.g. mysql : world database[city, country, country language, ...(tables)]
    - 데이터베이스에는 데이터와 데이터베이스를 관리하기 위한 정보(메타정보)도 함께 저장됨 : 사용자가 필요로 하는 테이블 + 시스템이 사용하는 테이블
        - 데이터베이스를 관리하는 정보를 시스템 카탈로그, 데이터 사전이라고 부르기도 함. : 사용자 계정정보, 권한정보, 테이블 목록 및 구조, 저장공간 정보, 사용 로그 등
        => 데이터에 대한 데이터 = 메타데이터
- DBMS : 데이터베이스를 관리하는 소프트웨어
    - e.g. mysqld.exe의 형태라고 window에서는 볼 수 있음
    - 백그라운드 프로세스로 상시 실행 가능
    - 데이터베이스의 성능 = DBMS의 성능
    - 기능
        - 데이터 정의 기능 : 사용자가 데이터베이스를 생성하거나
        데이터베이스 내 원하는 구조의 파일(테이블)을 생성/변경할 수 있도록 지원
        - 데이터 조작 기능 : 사용자가 데이터베이스 내의 파일(테이블)에 대해 조회하거나 데이터를 삽입, 수정, 변경, 삭제하는 기능을 지원
        - 데이터 제어 기능 : 다수의 사용자가 이요하는 데이터베이스 내의 데이터를 정확하고 안전하게 유지하는 기능 - 보안관리(접근제어), 병행수행 제어, 데이터베이스의 백업 및 복구
- 데이터베이스 : 데이터의 집합체

# 데이터베이스 사용자, 언어
- 최종 사용자(end user), 개발자, 관리자(DBA)
    - 최종 사용자(end user) : 이미 구축된 데이터베이스를 이용하는데 주된 관심
        - 캐주얼 사용자 : SQL을 이용하여 매번 다른 정보를 검색, 개발자, 기업 내부 사용자
        - 초보 사용자 : 이미 구축된 데이터베이스를 이용하는데 주된 관심, 데이터베이스의 존재를 알지 못하고 사용, REST API를 통해 구축된 시스템을 이용해 간접적으로 데이터베이스를 사용하는 의미인듯(e.g. 신용카드, 교통카드 이용, 인터넷 우편번호 조회 등)
    - 응용 프로그래머(Application Developer) : 데이터베이스를 이용하는 앱 개발자(초보 사용자가 사용하는 SW)
        - 대규모 정보시스템, 동영상 플랫폼, 일정 관리 프로그램 등
        - 개발언어 + SQL(ORM 이용) : 내장 SQL / 임베디드 SQL
    - 데이터베이스 관리자(DBA) : 일반관리자 ~ 최고관리자(DBA)
        - 데이터베이스 시스템의 운영, 관리에 대한  책임을 지고 있는 사용자
        - 현장 업무와 기술적인 지식 필요
        - SQL(Structured Query Language) : 관계형 데이터베이스 표준 언어
            - DMBS와 커뮤니케이션 하기 위한 언어
            - 한국의 인구와 GNP는 얼마인가? = SELECT name, population, GNP FROM country WHERE name='South Korea';
            - 아시아에 속한 국가들의 이름과 인구수는? = SELECT name, population FROM country WHERE continent='Asia';
            - 아시아에 속한 국가들의 GNP의 합계는? = SELECT SUM(GNP) FROM country WHERE continent='Asia';
            - 한국인의 기대수명을 80으로 바꾸시오 = UPDATE country SET LifeExpectancy = 80 WHERE name='South Korea';
            - New Stan이라는 신생국의 정보를 추가하시오 = INSERT INTO country (code, name, continent) values ('NST', 'New Stan', 'Asia');
            - NEW Stan에 대한 자료를 삭제하시오 = DELETE FROM country WHERE name='New Stan';
---
# 관계형 데이터베이스
# 데이터 모델의 개념
- 데이터를 어떤 형태로 저장할 것인가? 
    - 데이터 모델
        - 현실 세계에 존재하는 데이터(정보)를 컴퓨터 안에 어떻게 표현할 것인가를 나타내는 것
        - 데이터 요소와 이들 간의 관계를 시각적으로 표현
        - 논리적 모델 : 사용자의 눈으로 봤을 때 데이터가 어떤 모양으로 보이는가?(어떤 형태로 표현되고 관리되는가?)
            - DBMS가 어떤 논리적인 데이터 모델을 제공하는지에 따라서 : 계층형 DBMS -> 네트워크형 DBMS -> 관계형 DBMS
        - 물리적 모델 : 데이터를 저장장치에 저장할 때 어떤 모양으로 저장할 것인가?
        - 계층형 DBMS
            - 데이터들이 계층적 구조로 연결되어 있다고 보는 관점
            - 초기 DBMS 제품에서 많이 채택해서 사용되던 모델
            - 장점 : 구조가 간단, 데이터 수정이나 검색이 빠름
            - 단점 : 검색 경로가 한정적, 삽입과 삭제 연산이 매우 복잡
        - 네트워크형 DBMS
            - 계층형 모델의 단점을 보완한 모델
            - 네트워크 모델에서는 하나의 하위정보가 여러 개의 상위 정보와 연결
        - 관계형 DBMS
            - 정보 또는 데이터간 상하 개념이 존재하지 않음
            - 장점 : 유연한 정보 검색 가능
            - 단점 : 검색 속도가 계층형이나 네트워크 모델에 비해 떨어짐
            - 검색 속도는 다른 방법으로 극복 가능함
            - 오늘날 우리가 알고 있는 대부분의 DBMS제품들(오라클, MSSQL, MySQL 등)은 관계형 모델
        - 1960s : 일반적인 파일 시스템, 데이터베이스 이전 시대
        - 1970s : 계층형과 네트워크형, 계층형 메인, 70s후반 관계형 모델 제안
        - 1980s : 관계형 모델 활성화
        - 1990s : 객체 지향형(Object-oriented), 객체 관계형(Object-relational) 모델 등장, 데이터를 보는 관점이 달라짐
        - 2000s : 비정형데이터를 다루기 위한 데이터베이스 등장
- 저장된 데이터를 사용자들이 어떤 방법을 통해서 이용할 수 있게 할 것인가?
- 저장되는 데이터들이 오류가 없도록 어떻게 관리할 것인가?
# 관계형 모델
- 1970s E.F Codd에 의해서 제안됨(논문)
- 데이터간 물리적 링크가 존재하지 않음
- 사용자에게 데이터가 테이블의 형태로 보임
- 릴레이션(relation, 오늘날 테이블)
    - 데이터를 저장하는 기본 단위
    - 릴레이션과 릴레이션 구분을 위해 이름을 갖음(테이블 이름) 
    - 릴레이션들이 모여서 데이터베이스를 구성함
    - 데이터베이스 : 서로 다른 이름을 갖는 여러 릴레이션들의 집합
- 속성(attribute)
    - 릴레이션의 열(column)을 가리키는 용어
    - 릴레이션에 저장되는 정보 항목의 이름
    - 동일한 릴레이션 내에서는 중복된 속성이름이 존재할 수 없음
    - 차수(degree) : 한 릴레이션에 포함된 속성의 개수
        - 변동성이 적음
- 튜플(tupple)
    - 하나의 릴레이션에서 행(row)를 가리킴
    - STUDENT 릴레이션에서 하나의 튜플은 한 명의 학생에 대한 정보를 담고 있음
    - 카디널리티(cardinality) : 하나의 릴레이션에 포함된 튜플의 수
        - 변동성이 많음
- 도메인(domain)
    - 릴레이션에서 각 속성이 속성에 저장될 수 있는 값들의 집합
    - 릴레이션에 올바르지 않은 데이터가 입력되는 것을 방지할 목적으로 고안됨
    - 속성에 들어올 수 있는 값의 집합을 미리 정의함 / 도메인에 있는 값만 속성에 넣을 수 있음
    - E.F.Codd가 도메인 개념을 제안한 이유 : 릴레이션에 올바르지 않은 데이터가 입력되는 것을 막기 위해서
    - 실제 구현에서 현실적인 문제가 발생
        - 모든 경우의 수를 갖기 어려움
        - 오늘날 도메인의 취지를 살려서 일부 구현이 되어 있음
    - 도메인 : 올바른 데이터가 들어오는 것을 실현하기 위한 개념
- 기본키(primary key)
    - 릴레이션에서 각 튜플을 식별할 수 있는 어떤 속성(또는 속성의 집합)
    - 튜플을 구분하는데 기준이 되는 속성(column)
- 외래키(foreign key)
    - 두 릴레이션을 참조 관계로 맺어주는 속성(또는 속성의 집합)
- 파일시스템 - 관계형 모델 - 현실 사용
    - 파일 = 릴레이션 = 테이블
    - 필드 = 속성 = 열(컬럼)
    - 레코드 = 튜플 = 행(로우)
- 릴레이션의 특징
    - 속성의 원자성
        - 릴레이션의 각 튜플의 특정 속성은 원자 값(Atomic value)을 가져야 함
        - 원자 값 : 더 이상 쪼개면 의미를 상실하는 입력 값
    - 튜플의 유일성
        - 릴레이션에는 중복되는 튜플이 저장되는 안 된다는 특성
    - 튜플(과 속성)의 무순서 성질
        - 릴레이션에 저장되는 속성에도 순서라는 개념이 없음
    - 속성 이름의 유일성
        - 동일한 릴레이션 내에 같은 이름을 가진 속성이 중복해서 존재할 수 없음
        - 다른 릴레이션에는 동일한 이름을 가진 속성이 있을 수 있음(구분 가능)
    - 이런 속성이 지켜져야
        - 데이터 관리에 용이함
        - 잘못된 데이터가 들어오는 것을 막을 수 있음
        - 원하는 데이터를 조회할 수 있음
- 관계형 모델에서 제시된 모든 이론들이 구현된 것은 아님
- 대부분의 개념은 제품화하면서 적용됨

# 데이터 무결성 규칙
- 데이터베이스에 포함된 오류는 다양한 문제를 야기함
- 저장되는 데이터가 정확하고 유효한 상태로 유지되는 성질
- 데이터의 무결성 침해 사례
    - 몸무게가 5600KG으로 저장되는 경우
    - 이름이 홍길동56으로 저장되는 경우
    - 유통기한이 지난 재고 수량이 데이터에 포함된 경우
- DBMS 역할
    - 데이터 무결성을 최대한 지킬 수 있어야 함
    - DBMS가 쉽게 확인할 수 있는 무결성 침해 사례도 있지만, 그렇지 않은 경우도 있음
- 관계형 데이터 모델에서 요구하는 기본 무결성 규칙(DBMS에게 유지 책임이 있음)
    - 개체 무결성 규칙 : 릴레이션의 기본키 속성에는 널(null)값이 입력될 수 없음
        - 학번이 없는 학생
            - 학생을 구분할 수 없음
            - 학생에 대한 정보를 저장할 수 없음
        - 정보의 관리 대상은 모두 고유한 식별 번호가 붙어 있음 : 주민등록번호, 학번, 도서번호, 주문번호, 전화번호 등 -> 고유 식별번호 속성
        - DBMS 역할 : 튜플들이 입력될 때 학번에 어떤 값이 들어오는지 감시하고 학번이 없는 학생의 등록을 막음(개체 무결성 규칙 준수)
    - 참조 무결성 규칙
        - 참조하는 속성과 참조되는 속성사이에는 일관성이 있어야 함
        - DBMS 역할 : 외래키를 통해서 참조 관계를 맺어주면 참조 무결성 규칙을 지켜줄 수 있음
- 널(null) 값
    - 릴레이션에 저장될 수 있는 특별한 값
    - 사용자가 아무 값도 입력하지 않을 때 자동으로 저장
    - 없음을 나타내는 값이기 때문에 공백이나 0과는 다름
    - 릴레이션을 설계할 때 어떤 속성에 널 값이 입력되는 것을 허용할지 말지를 정해야 함
        - 학번, 주민등록번호, 학생 이름, 성별 등 반드시 있어야 하는 것에는 null이 허용되면 안 됨
        - 취미, 추가 연락처, 희망진로 등 필수가 아닌 것에는 허용 가능
- 요약
    - 개체 무결성 규칙 : 기본키 컬럼에는 널이 들어갈 수 없음
    - 참조 무결성 규칙 : 외래키로 연결되어 있을 때, 무결성 규칙을 사용자가 지정함
    - 기타 무결성 규칙 : DBMS마다 지원되는 어떤 기능의 범위가 다름(강하게 지원하는 경우 비용이 큼)

# MySQL 워크벤치의 기본 사용
- 오라클에서 제공하는 오픈소스 유틸리티 소프트웨어 GUI지원
- [워크벤치 / 콘솔] -> DBMS -> Database

---
# 관계 대수
- DBMS와 소통하기 위해 SQL을 사용해야 함

# 관계대수 개요
- E.F.Codd는 관계형 모델을 제안하면서 원하는 데이터를 추출할 수 있는 방법을 제시함
    - 관계 대수(relational algebra)
    - 관계 해석(relational calculus)
    - 위 두 가지는 데이터를 추출하는 능력은 동일함(표현력은 동등함)
    - 관계 대수란 테이블 형태의 데이터에서 원하는 정보를 어떻게 추출할 것인가라고 요약할 수 있음
- 수학연산과 유사하게 관계 대수의 연산도 표현할 수 있음
    - 연산의 대상, 연산의 결과 : 테이블
- 관계대수 연산의 특징
    - 관계 대수의 연산 대상(피연산자) : 릴레이션
    - 관계 대수의 연산 결과 : 릴레이션
    - 관계 대수 연산의 닫힘 성질(close property)라고 부름
- 관계 대수 연산자
    - 일반 집합 연산자
        - 합집합, 교집합, 차집합, 카디션 프로덕트
    - 순수 관계 연산자
        - 셀렉트, 프로젝트, 조인, 디비전
    - 주로 셀렉트, 프로젝트, 조인 세 가지를 사용함

# 일반 집합연산
- 합집합(∪) : 릴레이션 A와 릴레이션 B의 튜플들을 하나로 모은다.
    - 두 릴레이션의 속성의 개수(차수)가 같아야 한다.
    - 두 릴레이션에서 대응하는 속성의 도메인이 같아야 한다.(속성 이름은 달라도 된다.)
        = 합쳐지는 값의 성질이 같아야 한다.
- 교집합(∩) : 릴레이션 A와 릴레이션 B의 튜플들 중 중복되는 것들을 모은다.
    - 두 릴레이션의 속성의 개수와 대응하는 속성의 도메인이 같아야 연산 가능(합집합과 동일)
- 차집합(-) : 릴레이션 A에는 존재하지만 릴레이션 B에는 존재하지 않는 튜플들을 추출한다.
- 카티션 프로덕트(×) : 릴레이션 A의 모든 튜플에 대해 릴레이션 B의 모든 튜플들을 연결한다.

# 순수 관게연산
- 셀렉트(σ, σ조건식(A)) : 릴레이션 A에서 조건식을 만족하는 튜플들을 추출(cf. 테이블에서 행을 추출하는 연산)
    - 조건에 맞는 튜플들만 선택해서 새로운 릴레이션을 구성하는 것
    - 회원등급이 A이고 취미가 등산인 회원들의 정보를 보이시오
    - σ조건1(σ조건2(A)), σ조건1∧조건2(A) 형태로 사용 가능
- 프로젝트(π, π속성리스트(A)) : 릴레이션 A에서 리스트에 있는 속성들로만 구성된 튜플들을 추출(cf. 테이블에서 열을 추출하는 연산)
- 조인(▷◁) : 릴레이션 A와 B의 공통 속성을 이용하여 A와 B의 튜플들을 연결하여 새로운 릴레이션을 구성
- 디비전(÷) : 릴레이션 B의 모든 튜플과 관련이 있는 릴레이션 A의 튜플들을 추출
- 비교 연산자
    - >, >=, <, <=, =, <>(같지 않다, 다른 기호를 쓰는 경우도 있음 e.g. !=)
- 논리 연산자
    - ∧(and), ∨(or), ¬(not)
# 관계 대수의 응용
- 관계 대수 연산자를 적절히 활용하면 원하는 정보를 추출할 수 있다.
- 셀렉트, 프로젝트, 조인 연산자를 이해하자.
    - 프로젝트 회원이름, 취미(셀렉트 대전) : 회원과 대출 릴레이션 조인 -> 회원이름, 취미 속성 추출(프로젝션)
    - 홍길동 회원이 대출한 도서의 목록 : 회원과 대출 릴레이션 조인 -> 홍길동이 포함된 튜플 추출(셀렉션) -> 대출도서 속성 추출(프로젝션)

# SQL 언어 개요
- SQL : structured query language의 약자
    - 관계형 데이터베이스가 인기를 얻게 된 비결은 쉬운 SQL문법에 있음
    - 관계 대수 이론을 실제 사용할 수 있도록 언어 형태로 구현한 것
    - 표준화되어 모든 DBMS 제품에서 동일하게 사용 가능
- SQL의 명령어
    - DDL(Data Definition Language) : 데이터 정의어
        - CREATE : 데이터베이스 및 데이터베이스 내의 개체(테이블, 뷰, 인덱스 등)를 정의
        - ALTER : 데이터베이스 및 데이터베이스 내의 개체의 구조를 변경
        - DROP : 데이터베이스 및 데이터베이스 내의 개체를 삭제
    - DML(Data Mnipulation Language) : 데이터 조작어
        - INSERT : 테이블에 새로운 데이터(튜플)를 추가
        - UPDATE : 테이블에 저장된 데이터를 수정
        - DELETE : 테이블에 저장된 데이터(튜플)를 삭제
        - SELECT : 테이블에 저장된 데이터를 조건에 맞게 조회
    - DCL(Data Control Language) : 데이터 제어어
        - GRANT : 접근/사용 권한을 부여
        - REVOKE : 접근/사용 권한을 회수
- SQL 언어학습 : 가장 실용성이 높은 학습 주제
    - SQL 명령어나 테이블 이름, 컬럼 이름 등은 대소문자를 구분하지 않는다.
    - SQL 명령문은 한줄에 작성해도 되고, 여러줄에 걸쳐서 작성해도 된다.
    - SQL 문 뒤에는 세미콜론(;)을 붙인다. 세미콜론은 하나의 명령문의 끝을 의미한다. 그리고 명령문과 명령문을 구분하는 역할을 한다.
# 실습용 데이터베이스 설치
# SELECT문 개요
- 어떤 정보를 추출할 때 사용하는 명령문
- 데이터베이스의 목적은? 필요한 정보를 모아놓고 공유하는 시스템
    - 따라서 들어있는 데이터를 검색하는 일이 가장 많음 -> SELECT문을 많이 사용
- 기본 구조 : 
    SELECT 컬럼명 -> 필수
    FROM 테이블명  -> 필수
    WHERE 검색조건; -> 생략 가능
- 담당업무가 SALESMAN인 사원의 이름과 연봉
    - SELECT ename, sal FROM emp WHERE job='SALESMAN'; 
    - π이름,연봉(σ담당업무='SALESMAN'(사원))
- SELECT문의 실행 과정
    - SELECT ename, sal => 프로젝트(π)
    - FROM emp => 대상 테이블
    - WHERE job='SALESMAN'; => 셀렉트(σ)
- SELECT문 작성 팁
    - 기본 문법을 적는다.
    - 질의를 해결하기 위해서 어떤 테이블을 검색해야 하는가 = FROM 테이블명
    - 질의에서 요구되는 정보는 어떤 컬럼에 있는가 = SELECT 컬럼명
    - 데이터를 검색하기 위한 조건은 무엇인가 = WHERE 검색조건
- WHERE절에서 조건의 지정
    - WHERE절이 없으면 모든 튜플을 반환
    - 비교연산자들 : =, <>, >, >=, <, <=
    - 논리연산자
        - AND : 연결된 조건들을 모두 만족하는 튜플 검색
        - OR : 연결된 조건들 중 하나라도 만족하는 튜플 검색
        - NOT : 지정된 조건들을 만족하지 않는 튜플 검색
- WHERE절에서 값의 비교
    - 숫자, 문자, 날짜, null값(is 사용)
- 사원의 담당 업무 목록을 보이시오
    - SELECT job FROM emp; => 모든 job을 보여줌
    - SELECT DISTINCT job FROM emp => 모든 job 중 중복된 것을 제거하고 보여줌
- 와일드 문자(*) : 테이블에서 모든 컬럼을 의미

# SELECT문 추가사항
# 내장함수의 사용
- WHERE절에서 문자 컬럼의 부분 비교
    - LIKE : 문자 속성의 컬럼에 대해 지정한 문자열을 포함하는지 비교
    - % : LIKE와 함께 사용되며 임의의 개수인 문자를 표현
    - _ : LIKE와 함꼐 사용되며 하나의 문자를 표현
- WHERE절에서 값의 범위 지정
    - BETWEEN AND : 포함되는 값( >= AND <=)
    - NOT BETWEEN AND : 제외되는 값 (< OR >)
- WHERE절에서 비교할 값들의 집합을 지정
    - IN : 어느 하나라도 매칭이 되면 선택 (= OR = OR =)
    - NOT IN : 조건 값이 아닌 나머지 (<> AND <> AND <>)

# 정렬과 그룹
- 정렬 : 결과를 주어진 기준에 따라 튜플을 정렬하여 보여주는 기능
    - 담당업무가 SALESMAN인 사원에 대해 입사일자가 빠른 순으로 사원의 이름, 입사일자를 보이시오.
        - SELECT ename, hiredate 
        - FROM emp 
        - WHERE job = 'SALESMAN' 
        - ORDER BY hiredate ; -> 정렬을 위한 키워드
    - 정렬 기준
        - 오름차순(기본) : A - Z, ㄱ - ㅎ, 1 - 100
        - 내림차순 : Z - A, ㅎ - ㄱ, 100 - 1
    - 담당업무가 SALESMAN인 사원에 대해 연봉이 많은 순으로 사원의 이름과 연봉을 보이시오.
        - SELECT ename, sal
        - FROM emp
        - WHERE job = 'SALESMAN'
        - ORDER BY sal DESC ; -> 내림차순 정렬
    - 모든 사원의 부서번호, 이름, 담당업무를 보이되 8부서번호 순으로 정렬하여 보이시오. 같은 부서안에서는 이름 알파벳 순으로 정렬하시오.
        - SELECT deptno, ename, job
        - FROM emp
        - ORDER BY deptno, ename -> 두 기준으로 정렬
    - SQL 정렬 기준은 여러 개 지정 가능
- 그룹(GROUP) : 테이블에 대해서 어떤 질의를 했을 때 그 결과를 그룹으로 묶어서 봄
    - 각 부서번호별 사원의 수를 구하시오
        - SELECT deptno, COUNT(*) AS 사원수
        - FROM emp
        - GROUP BY deptno ; -> 그룹핑 후, COUNT(*) 튜플의 개수를 센다.
    - 각 부서번호별 평균 연봉을 구하시오
        - SELECT deptno, AVG(sal) AS 평균연봉
        - FROM emp
        - GROUP BY deptno ; -> deptno으로 그룹핑된 튜플의 평균값(sal)을 산출함
    - GROUP BY를 사용 시 SELECT 다음에 올 수 있는 컬럼들
        - GROUP BY에 사용한 컬럼
        - COUNT(), MAX(), MIN() 집계함수를 적용한 컬럼
        - 기타 컬럼은 에러가 나지는 않지만, 의미 없는 값이 온다.
- HAVING : GROUP BY를 적용한 결과에서 추가로 적용할 때 사용
    - 각 부서번호별 사원의 수를 구하시오. 단, 사원의 수가 5명 이상인 부서만 보이시오.
        - SELECT deptno, COUNT(*) AS 사원수
        - FROM emp
        - GROUP BY deptno
        - HAVING COUNT(*) >= 5 ;
    => 튜플에 대한 조건 = WHERE
    => GROUPING 결과에 대한 조건 = HAVING
- 각 부서번호별 사원의 수를 구하시오. 단, 사원의 수가 5명 이상인 부서만 보이되, 사원수가 많은 순으로 보이시오.
    - SELECT deptno, COUNT(*) AS 사원수
    - FROM emp
    - GROUP BY deptno -> 그룹핑
    - HAVING 사원수 >= 5 -> 조건지정
    - ORDER BY 사원수 DESC ; -> 정렬
- 각 부서번호별 급여합계를 구하시오. 단, 급여합계가 2500이상인 부서만 보이되 급여합계가 많은 순으로 하고 급여가 500 미만인 사원은 대상에서 제외하시오.
    - SELECT deptno, SUM(sal) AS 급여합계
    - FROM emp
    - WHERE sal >= 500
    - GROUP BY deptno
    - HAVING 급여합계 >= 2500
    - ORDER BY 급여합계 DESC ;

- LIMIT : 출력되는 데이터 제한 가능(비표준 문법이라 DBMS마다 조금씩 다를 수 있음)

# 기본키와 외래키
- 기본키(primary key)
    - 튜플을 식별하는 기준이 되는 컬럼
    - 개체 무결성 규칙을 구현하는 수단
        - 기본키 컬럼에는 null이 저장될 수 없음
        - 즉 테이블에 저장되는 튜플들은 중복된 것이 존재하면 안됨
    - 중복여부 검토를 위해 기본키 컬럼을 비교
    - 관련 용어
        - 후보키(candidate key) : 기본키가 될 수 있는 키, 식별자 역할이 가능한 키
        - 기본키(primary key)
        - 대체키(alternate key) : 기본키가 되지 않은 식별자 역할이 가능한 키
    - 역할
        - 튜플의 식별 기준이 되는 컬럼들
        - 튜플의 중복성 여부를 검토하는 기준
        - 검색을 빠르게 하기 위해 기본키 컬럼에는 인덱스가 설정됨(검색의 기준)
    - 데이터 조회나 검색에 주로 사용됨
- 외래키(참조 무결성 규칙 구현 수단)
    - 부모테이블과 자식테이블을 이어줄 때, 자식테이블에서 참조되는 키
    - 외래키는 항상 부모테이블의 기본키를 참조함
- 일반적으로 기본키와 외래키는 테이블이 생성될 때 설정됨
- 외래키에는 null값이 허용됨

# 조인 연산
- 두 개 이상의 테이블을 연결하여 조회하는 작업
- 모든 사원의 이름과 부서명, 근무지를 보이시오
    - SELECT emp.ename, dept.dname, dept.loc
    - FROM emp, dept -> 카티션프로덕트 적용
    - WHERE emp.deptno = dept.deptno ;
- 조인 연산 유의점
    - 조인 조건의 서술이 필수적임
    - 컬럼 이름 앞에 테이블 이름을 붙임
    - 두 테이블을 조인하기 위해 반드시 두 테이블이 참조관계에 있을 필요는 없음(필수는 아니지만 참조무결성을 위해서 필요함)
    - 외래키로 연결하지 않으면? DBMS가 참조 무결성을 지키지 못함
    - 컬럼의 이름이 명화하면 테이블 명을 생략해도 됨
    - 테이블의 별칭을 지정할 수 있음
        - SELECT ename, dname, loc
        - FROM emp e, dept d
        - WHERE e.deptno = d.deptno ;
- 조인 연산 종류
    - Inner join : 두 테이블의 일치되는 튜플만 표시(일반적 조인)
    - Left join : 왼쪽 테이블의 튜플은 모두 표시되고, 여기에 대응하는 오른쪽 테이블의 튜플 연결 / 오른쪽 튜플에서 연결할 튜플이 없으면 NULL로 표시
    - Right join : 오른쪽 테이블의 튜플은 모두 표시되고, 여기에 대응하는 왼쪽 테이블의 튜플 연결 / 왼쪽 튜플에서 연결할 튜플이 없으면 NULL로 표시
    - Outer join : 왼쪽, 오른쪽 튜플을 모두 표시 / 연결할 튜플이 없는 경우 NULL로 표시
- 셀프 조인(Self join)
    - 모든 사원의 이름과 사원의 매니저 이름을 보이시오
        - SELECT e.ename AS employee, m.ename AS manager
        - FROM emp e, emp m
        - WHERE e.mgr = m.empno ;
        - 같은 emp에 대해 e와 m으로 별칭을 설정하여 조건에서 사용함
        - 최상위에 있는 컬럼도 나오게 하기 위해서는 LEFT JOIN을 사용하면 됨
            - SELECT e.ename AS employee, m.ename AS manager FROM emp e LEFT JOIN emp m ON e.mgr = m.empno ;

# UNION, INTERSECT, MINUS
- 집합연산 상당 부분을 구현하는 SQL
- 합집합 : UNION
- 교집합 : INTERSECT
- 차집합 : MINUS
- 관계 대수에서 집합 연산이 가능하려면 구조가 같아야 함
    - 두 컬럼의 개수가 같아야 함
    - 대응하는 컬럼의 도메인(자료형)이 같아야 함
- 급여를 2500 이상 받거나 담당업무가 MANAGER인 사원의 이름과 입사일자를 보이시오
    - SELECT ename, hiredate
    - FROM emp
    - WHERE sal >= 2500
    - UNION (ALL -> 중복된 것도 포함)
    - SELECT ename, hiredate
    - FROM emp
    - WHERE job = 'MANAGER' ;
    => UNION만 사용되었을 때, WHERE sal >= 2500 OR job = 'MANGER' 조건을 사용하여 동일한 결과를 얻을 수 있음
- 급여를 2500 이상 받고 담당업무가 MANAGER인 사원의 이름과 입사일자를 보이시오
    - SELECT ename, hiredate
    - FROM emp
    - WHERE sal >= 2500
    - INTERSECT => AND 조건을 활용하면 동일한 결과를 얻을 수 있음
    - SELECT ename, hiredate
    - FROM emp
    - WHERE job = 'MANAGER' ;

- 급여를 2500 이상 받는 사원 중 담당업무가 'MANAGER'인 사원을 제외하여 이름과 입사일자를 보이시오
    - SELECT ename, hiredate
    - FROM emp
    - WHERE sal >= 2500
    - MINUS => AND <>(NOT) 조건으로 동일한 결과를 얻을 수 있음
    - SELECT ename, hiredate
    - FROM emp
    - WHERE job = 'MANAGER' ;

# 중첩 SQL
- SQL문 안에 또 다른 SQL문이 포함된 SQL
- 중첩 SQL은 언제 사용하면 좋을까?
    - WHERE 조건을 잘 써주면 해결되는 경우가 있음
    - 반드시 중첩 SQL을 써야만 해결되는 질의가 있음 -> 좋은 개발자의 조건
- 예시
    - SELECT ename, hiredate
    - FROM emp
    - WHERE sal >= (SELCET MIN(sal)
                    FROM emp             
                    WHERE job = 'ANALYST' ); => 서브쿼리
- 단일 값 서브쿼리 : 중첩 SQL에서 하나의 값을 도출함
- 다중 값 서브쿼리 : 중첩 SQL에서 여러 개의 값을 도출함
- 가장 많은 급여를 받는 사원의 이름, 담당업무, 급여액을 보이시오
    - SELECT ename, job, sal
    - FROM emp
    - WHERE sal = ( SELECT MAX(sal)
                    FROM emp ) ;
- 중첩 SQL의 이점
    - SQL이 간단해짐
    - 실행속도가 빨라짐
    - 중첩 SQL이 항상 빠른 것은 아님
- 중첩 SQL의 결과는 단일 값이 왔을 때 비교연산자를 사용할 수 있음
- 사원들 중 평균 이상의 연봉을 받는 사원들의 이름, 담당업무, 급여액을 보이시오
    - SELECT ename, job, sal
    - FROM emp
    - WHERE sal >= ( SELECT AVG(sal)
                     FROM emp ) ;
- 1981년도에 입사한 사원들 중 평균 이상의 연봉을 받는 사원들의 이름, 담당업무, 급여액, 입사일자를 보이시오
    - SELECT ename, job, sal, hiredate
    - FROM emp
    - WHERE sal >= ( SELECT AVG(sal)
                     FROM emp )
    - AND hiredate BETWEEN '1981-01-01' AND '1981-12-31' ;
- 부서이름 'S'를 포함하는 부서에 근무하는 사원들의 이름, 담당업무, 부서번호를 보이시오.
    - SELECT ename, job, deptno
    - FROM emp
    - WHERE deptno IN ( SELECT deptno
                        FROM dept
                        WHERE dname LIKE '%S%' ) ;
- 'SMITH', 'ALLEN' 사원과 다른 업무를 하는 사원들의 이름과 담당업무, 급여액을 보이시오.
    - SELECT ename, job, sal
    - FROM emp
    - WHERE job NOT IN ( SELECT job 
                         FROM emp
                         WHERE ename = 'SMITH' OR
                               ename = 'ALLEN' ) ;
- 다중 값 서브쿼리의 경우 IN을 사용
- 중첩 SQL은 간편성, 신속성을 위해 사용이 필요하다.
- Summary
    - SORT를 통해 질의 결과를 주어진 기준에 따라 정렬할 수 있고, GROUP BY를 통해 질의 결과를 그룹별로 집계하여 볼 수 있다.
    - 기본키는 DBMS가 튜플의 중복성을 확인하는 데 사용되고, 외래키는 참조무결성을 확인하는 데 사용된다.
    - 두 개 이상의 테이블을 공통속성을 통해 연결하여 하나의 테이블을 도출하는 것을 조인연산이라고 한다.
    - SQL은 관계 대수의 일부 집합 연산을 제공하고 있으나 널리 사용되지는 않는다.
    - 중첩 SQL은 SQL문 안에 또 다른 SQL문이 포함된 형태를 말한다.

# 데이터 정의어
- CREATE
    - 테이블을 포함해서 데이터베이스 안에 저장되는 모든 객체구조(스키마)를 정의함
    - 데이터베이스 자체도 CREATE문을 이용하여 생성함
    - CREATE(DATABASE)
        - CREATE DATABASE 데이터베이스이름 ;
    - CREATE(TABLE)
        - 외래키가 있는 경우, 해당 키를 참조하는 테이블을 먼저 생성해야 함
        - CREATE TABLE 테이블명 (
            컬럼명 자료형 [NOT NULL],
            컬럼명 자료형 [NOT NULL],
            ...,
            [CONSTRAINT 제약조건명 PRIMARY KEY (컬럼목록)],
            [CONSTRAINT 제약조건명 FOREIGN KEY (컬럼목록)
                                REFERENCES 테이블명(컬럼목록)],
                [ON UPDATE 처리방법] --> 외래키 관련 내용들
                [ON DELETE 처리방법]
        ) ;
        - 컬럼의 자료형(data type)은 DBMS 제품마다 명칭이 다름
            - CHAR : 고정 길이 문자 저장에 사용(성별, 주민번호, 국가코드), 값이 없으면 공백 저장
            - VARCHAR : 가변길이 문자 저장에 사용(주소, 건물명, 취미), 값이 없으면 저장공간 사용 안함
        - 초기값의 지정
            - gender char(1) DEFAULT 'M'
        - 컬럼에 대한 추가 지정사항
            - 컬럼 값의 중복 불가 지정(대체키)
                - cell_phone char(11) UNIQUE, --> 중복성 체크
        - 제약 조건의 지정
            - 기본키 지정 : CONSTRAINT pk_deptno PRIMARY KEY(deptno)
            - 외래키 지정 : CONSTRAINT fk_deptno FOREIGN KEY (deptno) REFERENCES my_dept(deptno) ON UPDATE CASCADE ON DELETE RESTRICT
            - ON UPDATE, ON DELETE 될 때 쓸 수 있는 제약 조건
                - RESTRICT : 변경되는 부모 테이블의 기본키 값을 참조하는 자식 테이블의 튜플이 있으면 UPDATE문이 실행되는 것을 제한한다.
                - CASCADE : 변경되는 부모 테이블의 기본키 값을 참조하는 자식 테이블의 튜플이 있으면 자식 테이블의 외래키 컬럼도 함께 변경한다.
                - SET NULL : 변경되는 부모 테이블의 기본키 값을 참조하는 자식 테이블의 튜플이 있으면 자식 테이블의 외래키 컬럼의 값을 NULL로 변경한다.
                - NO ACTION : 변경되는 부모 테이블의 기본키 값을 참조하는 자식 테이블의 튜플이 있어도 자식 테이블에 대해 아무일도 하지 않는다.(무결성이 깨짐)
        - MySQL에서 테이블의 구조 확인 : DESC 테이블명 ;
        - 질의 결과로부터 테이블 생성(질의 결과를 테이블로 저장) : CREATE TABLE emp_sal_high AS SELEcT * FROM my_db.emp WHERE sal >= 2000 ;
            - 테이블 생성 + 데이터 입력
- ALTER
    - CREATE문으로 생성한 데이터베이스 객체들의 구조를 변경함
    - 테이블에 새로운 컬럼 추가
        - ALTER TABLE my_dept
        - ADD COLUMN budget decimal(10,2) default 0 
                        AFTER dname ; --> 추가 위치 지정도 가능
    - 컬럼의 이름 변경 --> 저장된 데이터에는 영향이 없음
        - ALERT TABLE my_dept
        - CHANGE COLUMN budget dept_budget decimal(10,2) default 0 ;
    - 컬럼의 지정내용 변경 --> 저장된 데이터가 손실될 수 있음
        - ALTER TABLE my_dept
        - MODIFY COLUMN dept_budget decimal(8,0) ;
    - 컬럼의 삭제 --> 저장된 데이터 삭제
        - ALTER TABLE my_dept
        - DROP COLUMN dept_budget ;
    - 기본키 외래키의 지정
        - ALTER TABLE my_emp
        - ADD CONSTRAINT pk_empno PRIMARY KEY(empno),
        - ADD CONSTRAINT fk_deptno FOREIGN KEY (deptno) REFERENCES
                                    my_dept(deptno)
                ON UPDATE CASCADE ON DELETE RESTRICT ;
    - 테이블 이름의 변경 --> 저장된 데이터 영향 없음
        - ALTER TABLE emp_sal_high
        - RENAME sal_high ;
- DROP
    - CREATE문으로 생성한 데이터베이스 객체들을 삭제함
    - 생성된 테이블 삭제 = 테이블 구조와 저장된 데이터 모두 삭제됨
- 데이터베이스 객체들
    - 테이블
    - 뷰
    - 인덱스
    - 함수
    - 저장 프로시저

# 데이터 조작어
- INSERT : 테이블에 새로운 튜플을 추가한다.
- UPDATE : 테이블에 저장된 데이터를 수정한다.
- DELETE : 테이블에 저장된 튜플을 삭제한다.
- 하나의 테이블 안에서 튜플에 대한 명령어(c.f. 데이터 정의어(CREATE, ALTER, DROP)는 테이블 구조 자체 스키마에 대한 명령어)

- INSERT : 기본적으로 대상 테이블에 하나의 행(튜플)을 추가하는 명령어
    - INSERT INTO 테이블명 (컬럼1, 컬럼2, ..., 컬럼n)
    - VALUES (값1, 값2, ..., 값n);
    - 컬럼에 값을 입력할 때, 컬럼의 자료형에 맞춰야 함
    - 컬럼에 값을 입력할 때, 입력 순서는 조정가능
    - 컬럼에 값을 입력할 때, 테이블에 있는 순서대로 입력한다면 컬럼명을 생략해도 됨
    - 컬럼에 값을 입력할 때, 입력되지 않는 컬럼이 NULL이 허용되면 NULL이 들어가고, 아니면 입력 에러가 발생함
    - 여러 개 동시 INSERT 가능
        - INSERT INTO my_dept
        - SELECT * FROM my_db.dept WHERE deptno >= 30;

- UPDATE : 테이블에 저장된 데이터를 수정하는 데 사용하는 명령어
    - UPDATE 테이블명
    - SET 컬럼1 = 수정값1,
          컬럼2 = 수정값2,
          ...,
          컬럼n = 수정값n
    - WHERE 조건문 ;
    - WHERE 조건문 생략 시 모든 튜플에 대한 수정이 진행됨
    - UPDATE 명령어는 복구가 어렵기 때문에 주의해서 사용해야 함.
    - 안전모드(safe mode) : 실수로 대량의 데이터가 수정/삭제되는 것을 막는 모드
        - UPDATE, DELETE문에 WHERE절이 없는 경우
        - WHERE절의 조건문에 기본키 컬럼이 포함되지 않는 경우
        - set SQL_SAFE_UPDATES = 0/1; 로 설정 가능
    - 담당업무가 'SALESMAN'인 사원들의 급여를 현재보다 10%씩 올리시오
        - UPDATE my_emp
        - SET sal = sal * 1.1
        - WHERE job = 'SALESMAN' ; -> 다수의 튜플이 대상이 되기 때문에 safe mode에서는 동작하지 않음
- DELETE : 테이블에서 조건에 맞는 행(튜플)을 삭제하 때 사용하는 명령어
    - DELETE FROM 테이블명
    - WHERE 조건문;
    - UPDATE 명령어와 마찬가지로 사용에 유의

# 뷰
- 뷰 : 테이블을 바라보는 관점
    - 데이터 베이스는 한 조직의 데이터를 전체 관점에서 모아 중복이 없도록 관리
    - 따라서 실제 사용자에게는 불필요한 데이터일 수 있음
    - 뷰는 각 부서의 관점에서 테이블을 다룰 수 있는 수단
    - 부서마다 필요로 하는 사원 정보가 다름
    - 각각의 부서에서 필요로 하는 컬럼만 모아서 마치 새로운 어떤 테이블이 있는 것처럼 만들어 주는 방법
- 문법
    - CREATE VIEW 뷰이름
    - AS 뷰를 정의하는 SELECT문 ; -> 특정 부서에서 보고싶은 정보
- 뷰는 원하는 정보만 담고 있어서 매우 간편하고 관리가 용이함
- CREATE VIEW emp_high_salary
- AS SELECT empno, ename, deptno, sal
     FROM emp
     WHERE sal >= 2500 ;
- 가상의 테이블 뷰(데이터베이스의 독립적인 객체)
- 뷰의 사용
    - 일반 테이블과 동일하게 사용함
    - 뷰와 일반 테이블간의 조인이 가능함
- 뷰는 가상의 테이블(실체가 없음)
- 뷰는 가상의 테이블로 물리적인 데이터를 갖지 않음
- 뷰의 특징
    - 물리적인 데이터가 없음
    - 뷰를 통해 뷰 밖에 있는 정보 검색이 불가능함
- 뷰를 통해 뷰 밖에 정보들을 검색한느 것은 불가능함
- 컬럼 : 뷰 안에 포함된 컬럼에 대해서만 조회 가능함
- 튜플 : 뷰 안에 포함된 튜플에 대해서만 조회 가능함
- 뷰는 물리적인 테이블을 어떤 사용자 관점에서 바라볼 수 있도록 도와주는 창문 역할. 그래서 창문으로 바라보는 내용만 실제로 사용자에게 전달되는 것.
- 뷰는 물리적 테이블에 대한 창문
- 사용 사례
    - 부서 관점 : 각 부서에서 필요한 정보만 뷰로 정의하여 테이블을 단순화된 형태로 다루고자 하는 경우. 테이블 관리가 쉬워짐
    - 보안 : 조직의 보안상 민감한 정보를 감추는 경우, 연봉정보/인사고과 등, 민감한 정보를 제외하고 뷰를 만들어서 보안을 유지할 수 있음
    - 개발 용이성 : 다수의 테이블을 조인해서 복잡한 질의를 만들어야 되는 경우, 뷰를 만들어 두고 뷰에서 조회하면 조인이 간단해짐

# 인덱스
- 테이블을 검색할 때 검색 속도를 높여주는 데 사용되는 기술
- 인덱스가 왜 필요할까? DBMS는 최대한 사용자의 요구를 빠르게 처리해야 하는데, 정보를 빠르게 테이블에서 찾을 수 있는 방법이 필요함 이 때 데이터베이스에서 사용되는 가장 기본적인 방법이 바로 인덱스를 사용하는 것이다.
- 우리말로 색인이라고 하는데, 어떤 단어가 있는 위치를 알려주는 역할
- 인덱스가 없다면? 책의 모든 페이지를 확인하여 원하는 단어를 찾아내야 함
- 이와 같은 인덱스의 원리를 테이블에서 튜플을 찾는데 적용하는 것이 인덱스를 이용하는 것이다.
- 튜플을 찾는 방법
    - 순차 탐색(sequential search) : 처음부터 나올 때까지 순차적으로 찾는 방법
        - 성능이 낮은 단점
    - 이진 탐색(binary search) : 정렬된 데이터에서 중간값을 선택하여 찾고자 하는 값과 비교하여 더 작거나 크다면 거기에 해당하는 값들 중의 중간값을 선택하여 비교하는 것을 반복한다.
        - 순차 탐색의 단점을 개선하기 위해 등장
        - 조건은 데이터가 정렬되어 있어야 함
        - 순차 탐색에 비해 속도가 크게 빠른 대신 정렬에 비용이 많이 들어감
        - 중간에 데이터가 추가되면 정렬을 유지하기 위해 많은 비용이 들어감

    - 인덱스(index)의 사용
        - 순차 탐색은 많은 시간이 소요
        - 이진 탐색은 빠른 검색이 가능하지만, 정렬 상태 유지에 많은 비용(시간)이 소요
        - 인덱스를 별도로 만들어 정렬하여 인덱스에 해당하는 주소에 데이터를 연결하여 구성
        - 인덱스 정렬 비용이 전체 테이블의 정렬 비용보다 경제적임
        - 약간의 비용을 들여서 빠른 검색 성능을 제공하는 것
- 테이블에 인덱스 설정 방법
    - 인덱스 지정 시기
        - 테이블을 만들 때
        - 테이블을 만든 이후
    - 문법
        - ALERT TABLE 테이블이름
        - ADD [UNIQUE] INDEX 인덱스이름 (컬럼1, 컬럼2, ...)
- 유니크 인덱스 : 인덱스가 가리키는 위치에 가리키는 값이 하나만 있는 경우
    - 하나의 인덱스로 조회되는 튜플이 한 개인 경우
- 일반 인덱스 : 인덱스가 가리키는 위치에 가리키는 값이 여러 개인 경우
    - 하나의 인덱스로 조회되는 튜플이 여러 개인 경우
- 뷰는 사용자가 사용, 인덱스는 DBMS가 사용
- 인덱스의 삭제
    - 문법
        - ALERT TABLE emp
        - DROP INDEX idx_ename ;
- 인덱스의 확인
    - 문법
        - SHOW INDEX FROM emp ;
- 인덱스는 데이터를 찾는 데 효과적인데, 모든 컬럼마다 인덱스를 붙인다면?
    - 인덱스가 많아지면 비용이 증가하기 때문에, 꼭 필요한 컬럼에 대해서만 인덱스를 붙여야 함
- 인덱스의 효과가 없는 경우
    - 튜플의 수가 적은 경우(200~300개) : 작은 데이터를 하나하나 다루는 것에 많은 시간이 소요됨
    - 인덱스 값이 전체 테이블의 10~15% 이상인 경우
    - DBMS가 자동적으로 인덱스를 생성하는 경우
        - 기본키 + 인덱스 : 기본키로 조회할 확률이 높음
        - 외래키 + 인덱스 : 조인 시간 감소
- 인덱스의 효과가 있는 경우
    - 꼭 필요한 컬럼
    - 인덱스를 붙였을 때 효과가 있는 컬럼

# 저장 프로시저
- 저장 프로시저와 함수의 구성 : 프로그래밍 언어의 기본 문법 + SQL문법
- 저장 프로시저와 함수 배우는 것은 문법을 배우는 것임.
    1. 프로시저의 정의
        - DELIMITER //
        - <-- 실제 프로시저를 만드는 코드 --> 
        - CREATE PROCEDURE 프로시저 이름([입력변수 리스트]) 
        - BEGIN
            처리내용 --> 프로그램에서 처리해야하는 내용
        - END <-- 실제 프로시저를 만드는 코드 --> //
        - DELIMITER ;
    
    2. 프로시저의 정의 예제
        - my_db의 emp 테이블에 대해 사원번호를 입력하면 해당 사원의 모든 정보를 화면에 표시함
        - DELIMITER //
        - CREATE PROCEDURE p_emp_sel(id int)
        - BEGIN
        -   SELECT * FROM emp
        -   WHERE empno = id ;
        - END //
        - DELIMITER ;
        - 입력변수가 2개 이상일 경우 : CREATE PROCEDURE p_emp_sel(id int, dept int)
    3. 저장 프로시저의 실행
        - 저장 프로시저는 CALL 명령어에 의해 실행
        - 사원번호가 7566인 사원의 모든 정보를 보인다.
        - CALL p_emp_sel(7566) ;
        - 저장 프로시저의 실행은 SQL문(SELECT문)을 실행한 것과 같이 화면에서 결과 확인 가능
- 저장 프로시저에 사용되는 문법
    1. 주석문 
        - `/**/`
        - `#` 또는 `--` 이용
    2. 변수의 선언과 변수에 값 저장
        - DECLARE 변수명 자료형; --> 변수의 선언
        - SET 변수명 = 값 --> 변수에 값 저장
        - 변수의 선언과 동시에 값 저장
            - DELARE pi DECIMAL (5,2) DEFAULT 3.14;
        - 변수 pi의 값 출력
            - SELECT pi ;
        - 변수를 선언하고 값을 저장해 어떤 알고리즘을 위해 사용할 수 있음
        - SQL문의 실행 결과를 생성한 변수에 저장할 수 있음
    3. 비교문
        - `IF .. END IF`
        - `IF .. ELSE .. END IF`
        - IF 비교조건 THEN
            비교조건 만족시 실행할 명령문1 ;
            비교조건 만족시 실행할 명령문N ;
        - END IF
        - IF 비교조건 THEN
            비교조건 만족시 실행할 명령문 ;
        - ELSE
            비교조건 불만족시 실행할 명령문 ;
        - END IF
    4. 반복문
        - 일반 프로그래밍 언어는 대부분 반복문으로 FOR문을 제공하지만, MySQL에서는 FOR문을 제공하지 않음
        - MySQL은 WHILE문과 REPEAT문을 제공함
        - WHILE 비교조건 DO
            명령문1 ;
            명령문N ;
        - END WHILE
        - 1~100의 합을 출력하는 코드
            - DECLARE count int DEFAULT 1 ;
            - DECLARE sum int DEFAULT 0 ;
            - WHILE count <= 100 DO
                SET sum = sum + count ;
                SET count = count + 1 ;
            - END WHILE
            - SELECT sum ;
# 사용자 정의 함수
- 특징
    - 데이터베이스에 저장되는 프로그램의 한 종류
    - 내장 함수와는 다르게 반드시 SQL문 안에서 사용(독자 사용 불가)
    - RETURN값이 있음
    - MySQL의 경우, 시스템 파라미터 : SET GLOBAL log_bin_trust_function_creators = 1; 을 통해 접근/사용 권한 부여
- 문법
    - 저장 프로시저의 문법과 동일
    - DELIMITER //
    - CREATE FUNCTION 함수 이름(입력변수 리스트)
        RETURNS 반환 값의 자료형
    - BEGIN
        명령문들 ;
        RETURN 반환 값 ;
    - END //
    - DELIMITER ;
- 급여액을 입력하면 높은 연봉인지 낮은 연봉인지 알려주는 사용자 정의 함수
    - DELIMITER //
    - CREATE FUNCTION f_grade(value decimal(8,2)) --> 사용자 정의 함수 f_grade
        RETURNS varcahr(40)
    - BEGIN
        DECLARE grade varchar(40) ;
        SET grade = 'Low salary' ;
        IF (value > 2500) THEN
            SET grade = 'High salary' ;
        END IF ;
        RETURN grade ;
    - END //
    - DELIMITER ;
- 저장 프로시저와 차이점
    - 저장 프로시저
        - CALL 함수를 이용해서 SQL문과 상관없이 실행 가능
        - 반환값 없음
    - 사용자 정의 함수
        - 반드시 SQL문에서만 실행 가능
        - 반드시 반환되는 RETURN 값이 있음
# 데이터베이스 설계의 개념
- 데이터베이스 설계 : 응용 SW 개발을 위해 기반이 되는 데이터베이스의 구조, 즉 스키마를 설계하는 과정
- 잘 설계된 데이터베이스는 응용SW의 성공을 위한 열쇠
- 잘못된 데이터베이스 설계 = 전체적인 업무 흐름 방해
- SW/데이터베이스 설계 = 현실세계의 업무에 대한 분석의 결과로 만들어짐
- 데이터베이스 설계의 이해 = 다른 사람의 설계를 이해할 수 있을 정도의 수준
- 응용 SW의 개발 절차
    - 요구사항 분석
        - 개발계획 수립
        - 업무 분석
    - 설계
        - 데이터모델링 : 논리적 DB설계, 업무에 필요한 데이터 포착
        - 프로세스 모델링
        - 상관 모델링 : 데이터, 프로세스 비교 및 보완
        - 물리DB 설계 : 세부설계
        - 프로그램(로직) 설계
    - 구현
        - DB구축
        - 프로그램 개발
    - 통합 및 테스트
        - DB튜닝
        - 프로그램 테스트
    - 유지보수
        - RUN & 유지보수
- 논리적 설계(데이터 모델링)
    - 현실세계를 데이터의 관점에서 파악하여 개념적인 모델로 표현하는 단계
- 물리적 설계
    - 실제 데이터베이스 구축을 위한 테이블, 뷰, 인덱스, 용량 등을 설계
- 데이터 모델링(논리적 설계)의 결과 : ERD
    - Entity Relationship Diagram
    - 테이블 기술서 등

# ERD
- Entity Relationship Diagram
- 논리적 DB설계(데이터 모델링)의 결과물
- 데이터베이스 용어와 모델링 용어
    - 테이블(table) = 엔티티(entity)
    - 컬럼(column), 열 = 속성(attribute)
    - 튜플(tuple), 행(row) = 인스턴스(instance)
    - 기본키(primary key) = 주식별자(primary identifier)
    - 외래키(foreign key) = 외래 식별자(foreign identifier)
- ERD : 현실 세계의 정보와 정보들의 관계를 개념화하여 표현한 것
- 표기법
    - 까마귀발 표기법(Crow's foot)
    - 엔티티 : 업무의 관심 대상이 되는 정보를 갖고 있거나 그에 대한 정보를 관리할 필요가 있는 유형, 무형의 사물(개체)
    - 속성 : 엔티티에서 관리해야할 최소 단위의 정보 항목, 테이블의 컬럼으로 구현
    - 주식별자와 외래식별자 : 기본키(primary key)와 외래키(foreign key)에 대응하는 개념
    - 관계 : 두 엔티티 사이의 관련성을 나타내는 용어, 두 엔티티가 외래 식별자에 의해서 연결되어 있다는 것을 의미 => 참조 관계
- 데이터 모델링을 지원하는 SW : 데이터베이스 설계 도구 erwin 등
    - 편리하다는 장점

# 정규화
- 데이터 모델링의 핵심 개념
- 데이터 모델링 : 현실세계 -> 관찰/분석 -> 시스템에 필요한 데이터를 ERD의 형태로 표현한 것
    - 엔티티/속성의 정의
    - 주식별자의 정의(기본키)
    - 관계/외래식별자의 정의(외래키, 참조)
    - 정규화
    --> 초벌 설계 후 정리과정을 거치게 됨
- 정규화
    - 설계된 데이터베이스 안에 존재하는 데이터의 중복을 제거하여 데이터 무결성을 유지하는 과정
    - 데이터에 똑같은 정보가 중복 저장되는 것을 막기 위한 과정
    - 정규화를 거치면 엔티티 수가 늘어남
    - 데이터베이스 설계의 대원칙 중 하나 : "동일한 정보는 반드시 한 번만 기록함"
    - 데이터 중복은 여러가지 문제를 발생시킴 -> 데이터의 중복 제거 == 정규화
- 데이터가 중복 저장되는 이유와 해결방법
    - 제 1정규화 : 반복된 속성이나 한 속성에 여러 값이 중복 저장되는 경우 중복되는 것을 해소
        - 반복이 되는 부분과 반복이 안되는 부분의 테이블을 구분(1대 N으로 설정)
        - 1001 : 사과, 배, 딸기    -->      - 1001 : 사과 - 1001 : 배 - 1001 : 딸기
        - 1002 : 사과, 오렌지      -->      - 1002 : 사과 - 1002 : 오렌지
        - 1003 : 배              -->      - 1003 : 배
    - 제 2정규화 : 일반 속성들 중에서 주식별자의 일부에 함수적으로 종속된 것을 찾아 해소
        - 부서 : 부서번호, 부서명 -> 자식 테이블에서 부서번호를 외래키로 연결하여 사용
    - 제 3정규화 : 일반 속성들 사이에서 함수적으로 종속된 것들을 찾아 해서
        - 고객 : 고객번호, 고객명, 고객주소 -> 자식테이블에서 고객번호를 연결하여 사용
- 논리적 DB 설계(데이터 모델링)
    - DBMS의 종류나 제품에 상관없이 진행(ERD는 어떤 DBMS 제품을 사용해도 적용 가능)
    - 설계 요소
        - 엔티티(entity)
        - 속성(attribute)
        - 주식별자(primary identifier)
        - 외래식별자(foreign identifier)
- 물리적 DB 설계
    - 특정 DBMS 제품을 전제로 진행(적용 DBMS의 특성을 고려함)
    - 설계 요소
        - 테이블(table)
        - 컬럼(column)
        - 기본키(primary key)
        - 외래키(foreign key)
        - 뷰(view)      ---> 데이터 모델링 단계에서는 X
        - 인덱스(index)  ---
- 물리적 데이터베이스 설계의 결과(ERD) : 테이블 기술서

# 데이터베이스 보안 개요
- 기밀성(Confidentiality)
    - 승인되지 않은 사용자가 무단으로 데이터를 액세스하는 것은 막아야 한다. 승인된 사용자는 승인된 목적으로만 사용하도록 관리해야 한다.
    - 프라이버시를 침해할 수 있는 정보의 공개로부터 데이터를 보호하는 것
    - 최소 권한 원칙 : 기밀성을 위해 사용자의 데이터 액세스 권한은 담당하는 업무에 따라 필요한 만큼만 차등적으로 제공
- 무결성(integrity)
    - 데이터를 일관성 있게 유지하고 오류 없이 유지하는 것
    - 데이터베이스 내에 있는 데이터가 불일치나 이상이 없도록 하는데 초점
    - 데이터베이스를 사용하는 전체 조직의 관점에서의 무결성도 중요
        - 특정기간 동안만 액세스가 허용
        - 적정 시점에 파쇄
        - 정보를 외부로 반출하는 것은 통제되어야 함
- 가용성(availability)
    - 승인된 사용자가 요구할 때마다 승인된 데이터에 대한 액세스가 가능해야 함
        - 어떤 이유로 시스템의 사용이 중단된다면 조직 전체에 손해를 끼칠 수 있기 때문
- 보안취약성
- DBMS의 보안
    - 인증(authentication)
        - 데이터베이스를 이용할 수 있기 위해서는 별도의 계정을 부여받아야하며, 로그인 과정을 통해 이용 권한이 있는 사용자임을 입증해야 함
        - DBMS는 권한이 있는 사용자에 대한 계정, 비밀번호 정보를 관리
    - 접근 제어(Access Control)
        - DBMS에서 권한여부 파악
    - 감사(auditing)
        - 사용자의 데이터베이스 작업을 모니터링하고 보안로그(log)에 기록하는 것
        - DB보안담당자 : 필요 시 보안 로그를 통해 특정 사용자의 부정행위나 불법행위의 여부를 판단
        - DB관리자 : 민감한 정보가 조회되거나 갱신될 때 이를 보안 로그에 기록하도록 설정
    - 암호화(encription)
        - 기본적으로 데이터베이스 전체는 탈취되어도 열어볼 수 없도록 암호화를 할 수 있는 기능을 제공
        - 비밀번호, 주민번호, 신용카드번호 등 테이블 내에 저장되는 개별 정보를 별도로 암호화 하는 방법을 제공
    - 무결성 제어(integrity control)
        - DBMS는 여러 방법으로 데이터 무결성을 유지
        - DBMS는 허가되지 않은 사용자의 데이터 변경이나 파괴, 저장, 그리고 데이터를 손상시킬 수 있는 시스템 오류, 고장들로부터 데이터베이스를 보호하는 기능을 제공
        - 적절한 시스템 통제와 다양한 백업 및 복구 절차 등을 통하여 데이터베이스 보호

# 사용자 계정 생성과 권한 관리
- 사용자 계정의 생성
    - 문법
        - CREATE USER 사용자계정명@접속위치
        - IDENTIFIED BY 비밀번호;
        - 접속위치의 예
            - localhost : 사용자가 DBMS가 설치된 컴퓨터를 통해 로그인 가능
            - % : 사용자가 외부에서 네트워크를 통해 원격으로 로그인할 수 있음
            - 128.10.% : 사용자가 네트워크 IP 주소가 128.10으로 시작하는 컴퓨터를 통해 원격으로 로그인할 수 있음
                - 접속위치 한정 시 IP주소 세팅 가능
                - 사용자 계정이 똑같아도 접속위치에 따라 로그인이 될 수 있고, 안될 수도 있음
    - 예시
        - CREATE USER 'salesman_1'@'localhost' IDENTIFIED BY '1234' ;
        - CREATE USER 'salesman_1'@'%' IDENTIFIED BY '1234' ;
    - 사용자 계정 SQL 확인
        - SELECT mysql.user ;
    - Note.Root 계정
        - 관리하는 모든 데이터베이스에 대한 모든 권한 보유
        - 유출에 유의해야 함
        - 대부분 root 계정보다 권한을 축소한 관리자 계정을 생성하여 사용함
- 사용자 권한 관리
    - 사용자 계정이 생성된 직후에는 데이터베이스에 로그인하는 권한 외에는 아무 권한도 없음
    - GRANT : 사용자에게 권한 부여
        - GRANT 부여할 권한(SELECT, INSERT, UPDATE) ON 데이터베이스이름.객체 TO 사용자계정 또는 역할 (WITH GRANT OPTION --> 선택사항으로 권한을 부여받는 사용자 또는 역할이 또 다른 사용자나 역할에게 자신이 받은 권한을 부여할 수 있는지 여부를 지정);
        - ALL PRIVILEGES : 모든 권한
        - INSERT, UPDATE
        - SELECT
        - my_db.* : my_db에 있는 모든 객체
        - my_db.emp : my_db에 있는 emp 테이블
    - REVOKE : 사용자에서 권한 회수

# 역할 관리
- 역할(role)의 필요성
    - 권한의 개별 부여 => 권한 부여의 어려움이 있음(많은 시간 소요, 관리 필요성)
    - 같은 팀/역할을 가진 사람을 그룹화하여 한 번에 관리
    - 관리의 어려움을 해결하고 효율적 권한 관리를 가능하게 하는 수단
- 역할을 통한 권한 부여
    - 동일한 권한을 갖는 사용자들을 하나의 역할로 묶음
    - 권한을 역할에 부여
    - 사용자들에게 역할을 부여
    - 장점
        - 새로운 개발자가 들어오면 이미 생성된 역할을 부여하여 필요한 권한들을 손쉽게 할당
        - 어떤 팀에 새로운 권한을 부여하면 팀 내 역할을 할당받은 사용자들에게 자동적으로 권한이 부여됨
        - 어떤 팀에 더 이상 필요없는 권한을 그 팀의 역할에서 회수하면 역할을 할당받은 모든 사용자에게서 권한이 회수됨
- MySQL에서 역할의 생성과 부여
    - CREATE ROLE 역할이름;
    - 역할에 권한 부여
        - GRANT select, insert, update ON my_db.emp TO team1;
        - GRANT select ON my_db.dept TO team1;
    - 역할을 사용자에게 부여
        - GRANT team1 TO 'user1'@'localhost';
    - 역할에 부여된 권한의 확인
        - SHOW GRANTS FOR team1;
        - SHOW GRANTS FOR 'user1'@'localhost';