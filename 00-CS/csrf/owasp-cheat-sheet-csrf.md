- https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html


## Introduction
CSRF(교차 사이트 요청 위조)는 악성 웹사이트, 이메일, 블로그, 인스턴트 메시지 또는 프로그램이 사용자가 인증되었을 때 사용자의 웹 브라우저가 신뢰할 수 있는 사이트에서 원치 않는 작업을 수행하도록 유도할 때 발생하는 공격의 한 유형입니다. CSRF 공격은 브라우저 요청에 세션 쿠키를 포함한 모든 쿠키가 자동으로 포함되기 때문에 작동합니다. 따라서 사용자가 사이트에 인증된 경우 사이트는 합법적인 인증 요청과 위조된 인증 요청을 구분할 수 없습니다. 적절한 권한 부여를 사용하면 이 공격은 차단되며, 이는 요청자의 신원과 권한을 확인하는 챌린지 응답 메커니즘이 필요하다는 것을 의미합니다.

성공적인 CSRF 공격의 영향은 취약한 애플리케이션과 사용자의 권한에 의해 노출된 기능으로 제한됩니다. 예를 들어, 이 공격으로 인해 자금 이체, 비밀번호 변경 또는 사용자의 자격 증명으로 구매가 이루어질 수 있습니다. 실제로 공격자는 CSRF 공격을 사용하여 적어도 무단 트랜잭션이 수행될 때까지 피해자 모르게 피해자의 브라우저를 통해 대상 시스템이 기능을 수행하도록 합니다.

요컨대, CSRF를 방어하기 위해서는 다음과 같은 원칙을 따라야 합니다:

- 프레임워크에 CSRF 보호 기능이 내장되어 있는지 확인하고 사용하세요.
    - 프레임워크에 CSRF 보호 기능이 내장되어 있지 않은 경우 모든 상태 변경 요청(사이트에서 동작을 유발하는 요청)에 CSRF 토큰을 추가하고 백엔드에서 유효성을 검사합니다.
- 상태 저장 소프트웨어의 경우 싱크로나이저 토큰 패턴 사용
- 상태 비저장 소프트웨어의 경우 이중 제출 쿠키 사용
- <form> 태그를 사용하지 않는 API 기반 사이트의 경우 사용자 지정 요청 헤더 사용을 고려하세요.
- 심층 방어 완화 섹션에서 하나 이상의 완화를 구현합니다.
    - 세션 쿠키의 경우 동일 사이트 쿠키 속성을 고려하되, 해당 도메인의 모든 하위 도메인이 쿠키를 공유하는 보안 취약점이 발생할 수 있으므로 도메인 전용 쿠키를 설정하지 않도록 주의하세요. 이는 특히 하위 도메인이 제어할 수 없는 도메인에 대한 CNAME을 가지고 있을 때 문제가 됩니다.
    - 매우 민감한 작업에 대해 사용자 상호 작용 기반 보호 구현을 고려하세요.
    - 표준 헤더로 출처 확인을 고려하세요.
- 크로스 사이트 스크립팅(XSS)은 모든 CSRF 완화 기술을 무력화시키는 데 사용될 수 있다는 점을 기억하세요!
    - XSS 결함을 방지하는 방법에 대한 자세한 지침은 OWASP XSS 방지 치트시트를 참조하세요.
- 상태 변경 작업에 GET 요청을 사용하지 마세요.
    - 어떤 이유로든 이 작업을 수행하는 경우 해당 리소스를 CSRF로부터 보호하세요.

## Token Based Mitigation
- 싱크로나이저 토큰 패턴은 CSRF를 완화하는 가장 인기 있고 권장되는 방법 중 하나입니다.

### Use Built-In Or Existing CSRF Implementations for CSRF Protection
- 싱크로나이저 토큰 방어는 많은 프레임워크에 내장되어 있습니다. 사용자 지정 토큰 생성 시스템을 구축하기 전에 사용 중인 프레임워크에 기본적으로 CSRF를 보호하는 옵션이 있는지 조사하는 것이 좋습니다. 예를 들어, .NET에는 CSRF에 취약한 리소스에 토큰을 추가하는 보호 기능이 내장되어 있습니다. CSRF에 취약한 리소스를 보호하기 위해 토큰을 생성하는 이러한 기본 제공 CSRF 보호 기능을 사용하기 전에 키 관리 및 토큰 관리와 같은 적절한 구성을 수행할 책임은 사용자에게 있습니다.

### Synchronizer Token Pattern
- CSRF 토큰은 서버 측에서 생성해야 합니다. 사용자 세션당 또는 각 요청마다 한 번씩 생성할 수 있습니다. 요청당 토큰은 공격자가 탈취한 토큰을 악용할 수 있는 시간 범위가 최소화되므로 세션당 토큰보다 더 안전합니다. 그러나 이로 인해 사용성 문제가 발생할 수 있습니다. 예를 들어, 이전 페이지에 더 이상 유효하지 않은 토큰이 포함될 수 있으므로 브라우저의 '뒤로' 버튼 기능이 종종 방해받게 됩니다. 이 이전 페이지와 상호 작용하면 서버에서 CSRF 오탐지 보안 이벤트가 발생합니다. 토큰을 처음 생성한 후 세션별 토큰 구현에서 해당 값은 세션에 저장되며 세션이 만료될 때까지 이후의 각 요청에 사용됩니다.

- 클라이언트에서 요청이 발생하면 서버 측 컴포넌트는 사용자 세션에서 찾은 토큰과 비교하여 요청에 포함된 토큰의 존재 여부와 유효성을 확인해야 합니다. 요청 내에서 토큰을 찾을 수 없거나 제공된 값이 사용자 세션 내의 값과 일치하지 않으면 요청을 거부해야 합니다. 이벤트를 진행 중인 잠재적 CSRF 공격으로 기록하는 등의 추가 조치도 고려해야 합니다.

- CSRF tokens should be:

    - Unique per user session.
    - Secret
    - Unpredictable (large random value generated by a secure method).

- CSRF 토큰은 토큰이 없으면 공격자가 백엔드 서버에 유효한 요청을 생성할 수 없기 때문에 CSRF를 방지합니다.

- 동기화된 토큰 패턴의 경우 CSRF 토큰은 쿠키를 사용하여 전송되어서는 안 됩니다.

- CSRF 토큰은 HTML 또는 JSON 응답과 같은 응답 페이로드의 일부로 클라이언트에 전송될 수 있습니다. 그런 다음 양식 제출 시 숨겨진 필드로 서버에 다시 전송하거나, 사용자 지정 헤더 값 또는 JSON 페이로드의 일부로 AJAX 요청을 통해 서버에 전송할 수 있습니다. 서버 로그나 URL에서 토큰이 유출되지 않았는지 확인하세요. GET 요청의 CSRF 토큰은 브라우저 기록, 로그 파일, HTTP 요청의 첫 줄을 기록하는 네트워크 유틸리티, 보호된 사이트가 외부 사이트로 연결되는 경우 리퍼러 헤더 등 여러 위치에서 유출될 가능성이 있습니다.

- For example:
```
<form action="/transfer.do" method="post">
<input type="hidden" name="CSRFToken" value="OWY4NmQwODE4ODRjN2Q2NTlhMmZlYWEwYzU1YWQwMTVhM2JmNGYxYjJiMGI4MjJjZDE1ZDZMGYwMGEwOA==">
[...]
</form>
```

- 사용자 지정 헤더가 있는 요청은 자동으로 동일 출처 정책의 적용을 받기 때문에 JavaScript를 통해 사용자 지정 HTTP 요청 헤더에 CSRF 토큰을 삽입하는 것이 숨겨진 필드 양식 매개변수에 토큰을 추가하는 것보다 더 안전한 것으로 간주됩니다.

### Double Submit Cookie
- 서버에서 CSRF 토큰의 상태를 유지하는 것이 문제가 되는 경우, 이중 제출 쿠키 패턴이라는 대체 기술을 사용할 수 있습니다. 이 기법은 구현하기 쉽고 상태가 저장되지 않습니다. 이 기술을 구현하는 방법에는 여러 가지가 있으며, 순진한 패턴이 가장 일반적으로 사용되는 변형입니다.

#### Naive Double Submit Cookie

- 나이브 이중 제출 쿠키는 확장 가능하고 구현하기 쉬운 기술로, 쿠키와 요청 매개변수 모두에 무작위 값을 전송하고 서버가 쿠키 값과 요청 값이 일치하는지 확인하는 방식입니다. 사용자가 방문하면(로그인 CSRF를 방지하기 위해 인증하기 전이라도) 사이트는 (이상적으로는 암호학적으로 강력한) 임의의 값을 생성하여 세션 식별자와 별도로 사용자 컴퓨터의 쿠키로 설정해야 합니다. 그런 다음 사이트는 모든 트랜잭션 요청에 이 무작위 값을 숨겨진 양식 값으로 포함하거나 요청 헤더에 포함해야 합니다. 서버 측에서 두 값이 모두 일치하면 서버는 이를 정상적인 요청으로 수락하고, 일치하지 않으면 요청을 거부합니다.

- 간단히 말해, 공격자는 교차 사이트 요청 중에 쿠키 값에 액세스할 수 없습니다. 따라서 숨겨진 양식 값이나 요청 매개변수/헤더에 일치하는 값을 포함할 수 없습니다.

- 나이브 이중 제출 쿠키 방법은 CSRF 공격에 대응하기 위한 좋은 초기 단계이지만 특정 공격에 여전히 취약합니다. 이 리소스에서 일부 취약점에 대한 자세한 정보를 확인할 수 있습니다. 따라서 보다 안전한 구현인 서명된 이중 제출 쿠키 패턴을 사용하는 것이 좋습니다.

