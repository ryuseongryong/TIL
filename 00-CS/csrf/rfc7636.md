- https://datatracker.ietf.org/doc/html/rfc7636

## 요약
- 인증 코드 부여를 활용하는 Oauth2.0 public clients는 인증 코드 가로채기 공격에 취약하다. 이 사양에서 공격과 코드 교환용 증명 키(PKCE)를 사용하여 위협을 완화하는 기술에 대해 설명한다.

## Introduction
- OAuth 2.0(RFC6749) 공용 클라이언트는 인증 코드 가로채기 공격에 취약하다.
- 이 공격에서 공격자는 통신 경로 내에서 인증 엔드포인트에서 반환된 인증코드를 가로챈다. 통신 경로 내의 인증 엔트포인트에서 반환된 인증코드를 가로챈다. 클라이언트 운영 체제 내의 애플리케이션 통신과 같이 전송 계층 보안에 의해 보호되자 않는 통신이다.
- 공격자가 인증 코드에 액세스하면 다음을 수행하여 액세스 토큰을 획득한다.
- OAuth 2.0[RFC6749] 퍼블릭 클라이언트는 인증 코드 가로채기 공격에 취약하다. 이 공격에서 공격자는 클라이언트 운영 체제 내 애플리케이션 간 통신 등 TLS로 보호되지 않는 통신 경로 내에서 인증 엔드포인트에서 반환된 인증코드를 가로챈다. 공격자가 인증 코드에 액세스하면 이를 사용하여 액세스 토큰을 얻을 수 있다.
- 그림 1은 공격을 나타낸다. 
  1단계에서는 스마트폰처럼 유저가 사용하는 디바이스에서 실행되는 기본 애플리케이션이 브라우저/운영 체제를 통해 OAuth 2.0인증 요청을 발행한다. 이 경우 리디렉션 엔드포인트 URI는 일반적으로 사용자 지정 URI 체계를 사용한다. 1단계는 가로챌 수 없는 보안 API를 통해 발생하지만 고급 공격 시나리오에서는 잠재적으로 관팔될 수 있다. 
  그런 다음 요청은 2단계에서 OAuth 2.0인증 서버로 전달된다.
  OAuth에서는 TLS를 사용해야 하므로 이 통신은 TLS로 보호되며 가로채기가 불가능하다. 인증 서버는 3단계에서 인증 코드를 반환한다. 4단계에서는 1단계에서 제공된 리디렉션 엔드포인드 URI를 통해 인증 코드가 요청자에게 반환된다.
- 악성 앱이 합법적인 OAuth 2.0 앱 외에도 사용자 지정 구성표에 대한 처리기로 자신을 등록할 수 있다는 점에 유의해야한다. 일단 그렇게 하면 악성 앱은 이제 4단계에서 인증 코드를 가로챌 수 있다. 이를 통해 공격자는 각각 단계 5와 6에서 액세스 토큰을 요청하고 얻을 수 있다.

- ```
    +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
    | End Device (e.g., Smartphone)  |
    |                                |
    | +-------------+   +----------+ | (6) Access Token  +----------+
    | |Legitimate   |   | Malicious|<--------------------|          |
    | |OAuth 2.0 App|   | App      |-------------------->|          |
    | +-------------+   +----------+ | (5) Authorization |          |
    |        |    ^          ^       |        Grant      |          |
    |        |     \         |       |                   |          |
    |        |      \   (4)  |       |                   |          |
    |    (1) |       \  Authz|       |                   |          |
    |   Authz|        \ Code |       |                   |  Authz   |
    | Request|         \     |       |                   |  Server  |
    |        |          \    |       |                   |          |
    |        |           \   |       |                   |          |
    |        v            \  |       |                   |          |
    | +----------------------------+ |                   |          |
    | |                            | | (3) Authz Code    |          |
    | |     Operating System/      |<--------------------|          |
    | |         Browser            |-------------------->|          |
    | |                            | | (2) Authz Request |          |
    | +----------------------------+ |                   +----------+
    +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+

             Figure 1: Authorization Code Interception Attack

  ```

- 이 공격이 작동하려면 여러 가지 전제 조건이 충족되어야 합니다:
  1. 공격자는 클라이언트 장치에 악성 애플리케이션을 등록하고 다른 애플리케이션에서도 사용되는 사용자 지정 URI 체계를 등록합니다. 운영 체제에서는 여러 애플리케이션이 사용자 정의 URI 체계를 등록할 수 있도록 허용해야 합니다.
  2. OAuth 2.0 인증 코드 부여가 사용됩니다.

3. 공격자는 OAuth 2.0 [RFC6749] "client_id" 및 "client_secret"(프로비저닝된 경우)에 액세스할 수 있습니다. 모든 OAuth 2.0 기본 앱 클라이언트 인스턴스는 동일한 "client_id"를 사용합니다. 클라이언트 바이너리 애플리케이션에 프로비저닝된 비밀은 기밀로 간주될 수 없습니다.

4. 다음 조건 중 하나가 충족됩니다.

  4a. 공격자는 설치된 애플리케이션을 통해 인증 엔드포인트의 응답만 관찰할 수 있습니다. "code_challenge_method" 값이 "plain"이면 이 공격만 완화됩니다.
  4b. 보다 정교한 공격 시나리오에서는 공격자가 인증 끝점에 대한 요청(응답 외에도)을 관찰할 수 있습니다. 그러나 공격자는 중간자 역할을 할 수 없습니다. 이는 OS에서 http 로그 정보가 유출되어 발생했습니다. 이를 완화하려면 "code_challenge_method" 값을 "S256" 또는 암호화 보안 "code_challenge_method" 확장에 의해 정의된 값으로 설정해야 합니다.

- 이것은 사전 조건의 긴 목록이지만 설명된 공격은 실제로 관찰되었으며 OAuth 2.0 배포에서 고려해야 합니다. OAuth 2.0 위협 모델([RFC6819]의 섹션 4.4.1)은 완화 기술을 설명하지만 안타깝게도 클라이언트별 인스턴스 비밀 또는 클라이언트별 인스턴스 리디렉션 URI에 의존하기 때문에 적용할 수 없습니다.

- 이 공격을 완화하기 위해 이 확장은 "코드 검증기"라고 불리는 동적으로 생성된 암호화 임의 키를 활용합니다. 모든 인증 요청에 대해 고유한 코드 검증기가 생성되며, "코드 챌린지"라고 하는 변환된 값이 인증 서버로 전송되어 인증 코드를 얻습니다. 획득한 인증코드는 '코드 검증기'를 통해 토큰 엔드포인트로 전송되고, 서버는 이를 이전에 수신한 요청 코드와 비교하여 클라이언트가 '코드 검증기' 소유 증명을 수행할 수 있다. 이 일회성 키는 TLS를 통해 전송되고 가로채기가 불가능하므로 공격자가 이 키를 알지 못하기 때문에 이는 완화책으로 작동합니다.