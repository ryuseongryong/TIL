- https://medium.com/full-stack-architecture/structured-message-formats-thoughts-on-what-to-log-501306e916de

로깅과 메시징은 소프트웨어 엔지니어링에서 가장 화려하지는 않지만 꼭 필요한 부분입니다. 프로젝트의 시작부터 로깅을 올바르게 수행하는 것은 필수적입니다. 구체적으로, 구조화된 로그 메시지에는 무엇이 포함되어야 할까요?

저희는 Winston을 사용하여 구조화된 로그를 생성할 수 있는 반 의견 구조화된 메시징 라이브러리를 구축했습니다.

이 게시물의 주제가 아닙니다:
- 메시지를 저장하거나 여러 컴퓨팅 인스턴스에서 생성된 모든 메시지를 단일 대상으로 수집하는 것에 관한 것이 아닙니다.
- Winston, Bunyan 등의 로깅 라이브러리.
- RFC5424 Syslog와 같은 업계 표준 정의 등에 관한 내용이 아닙니다.
- 다음과 같은 도구를 사용하여 메시지 처리

이 글에서는 로그를 구조화해야 하는 이유와 각 로그 인스턴스에 대해 제공할 수 있는 정보의 종류에 대해 설명합니다.

### 로깅과 메시징
로깅과 메시지의 구조는 동일할 수 있습니다. 하지만 사용법은 크게 다릅니다. 메시징과 로깅에 대한 글을 참조하세요: 구현과 의도에 대한 글을 참조하세요.

### 왜 메시지와 로깅에 구조화된 형식을 사용해야 할까요?
임시 형식을 사용하여 정보를 기록하면 컴퓨팅 환경에서 일어나는 일에 대한 인사이트를 얻기가 어렵습니다. 특히 이러한 목적으로 로그를 사용해야 하는 데이터 분석가의 경우 더욱 그렇습니다.

일관된 메시지 형식을 제공하면 가능합니다:

- 아파치 스파크와 같은 시스템에서 로그를 쉽게 소비하고 분석할 수 있습니다.
- Kafka에서 메시지 라우팅 자동화
- 사람이 쉽게 검토할 수 있도록 로그 메시지 재포맷(JSON -> YAML)
구조화된 로깅에는 데이터 형식이 필요합니다. 이 글에서는 JSON 사용을 권장합니다.

### 디자인 고려 사항
다양한 로깅 형식을 검토하고 다양한 배경과 요구 사항을 가진 사람들과 대화를 나눈 결과, 다음과 같은 몇 가지 시사점을 얻을 수 있었습니다:

- Local Development: 로깅은 너무 시끄러워서는 안 됩니다. 따라서 메시지의 요소 수를 최소화해야 합니다.
- Local Development: 오류는 빨간색, 정보는 녹색, 경고는 노란색 등 로그 메시지를 시각적으로 잘 표현하는 것이 좋습니다.
- Idempotence: 동일한 메시지를 두 번 보내도 이중으로 계산되지 않습니다.
- Verification: 일부 상황에서는 전송 중에 메시지가 변경되지 않았는지 확인해야 할 수도 있습니다.

### 최소한의 것부터 시작하기
로컬에서 애플리케이션을 실행하려면 여러 클라우드 제공업체에 수백 개의 애플리케이션이 있는 회사에서 애플리케이션을 실행하는 것과는 다른 메시지 형식이 필요합니다. IT 부서는 로그 메시지의 출처가 어느 클라우드 제공업체인지 알아야 합니다. 로컬에서 애플리케이션을 실행하는 개발자는 이러한 정보에 반드시 관심이 있는 것은 아닙니다.

하지만! 우리는 메시지 형식이 일관되고 해당 메시지를 소비하는 사람과 관련이 있기를 원합니다. 따라서 작은 메시지 형식부터 시작하여 이를 기반으로 구축해 나가겠습니다.

다음 JSON은 메시지의 일부를 표시합니다. 개발자는 로컬에서 디버깅할 때 이를 사용할 수 있습니다.

## Structured Message Properties

### id(required)
생성된 모든 메시지에는 전 세계적으로 고유한 ID가 부여됩니다. 메시지를 소비하는 시스템은 메시지를 한 번만 저장할 수 있습니다(동일한 메시지가 어떻게든 두 번 전송되는 경우). 이러한 방식으로 설계된 시스템은 무력화됩니다.

Example: "id": “c7963876–135c-11eb-adc1–0242ac120002”

참고: 특정 UUID 유형을 권장하지 않습니다.

### level(required)
로그 수준을 사용하면 메시지의 중요도에 따라 로그 메시지를 필터링할 수 있습니다.

참고: 로깅 플랫폼마다 서로 다른 로그 수준 열거를 사용하는데, 몇 가지 예로 Winston, Log4J, log4net 및 Python의 로깅을 들 수 있습니다. 대기업의 경우 이러한 로깅 라이브러리 중 하나 이상을 사용하고 있을 수 있으므로 차이점을 고려하는 것이 중요합니다. IT, 인프라, 개발 운영, 데이터 과학과 같은 그룹은 서로 다른 로그 수준에 따라 부정적인 영향을 받습니다.

Example: "level": "warn" , "level": "info"

### topics(required)
토픽은 메시지를 라우팅하는 데 도움이 되며, 토픽을 기반으로 라우팅하는 서비스를 사용하는 경우 특히 유용합니다: Kafka, Kinesis 등.

최소한 메시지에는 log 또는 event 토픽이 포함되어야 합니다.

특히 이벤트인 경우에는 토픽을 통해 메시지의 목적을 더 세분화할 수 있습니다.

Examples: "topics": ["event", "auth", "login"], "topics": ["event", "auth", "logout"]

토픽에 로그 수준을 추가하면 백엔드에서 메시지를 더 쉽게 소비할 수 있습니다: "topics": ["log", "warn"],,, "topics": ["log": "error"].

참고: 수준을 토픽 속성으로 옮기는 것을 고려했지만 로그의 루트에 수준 속성을 두는 것이 일반적인 관행입니다.

### priority(required)
우선순위는 이벤트가 처리 대기열을 "점프"할 수 있도록 하여 라우팅에 더욱 도움이 될 수 있습니다. 시스템마다 다른 우선순위를 나타내는 값이 있을 수 있습니다. Microsoft의 메시지 우선순위, Mail Kit 등이 그 예입니다.

Examples: “priority": 1, “priority": 2

### message(required)
사람이 읽을 수 있는 간단한 메시지입니다. 이 메시지는 추가 처리가 필요 없는 최종 형식의 메시지입니다.

Examples: “message": "User logged out.”, “message": "Error opening file.”

### template(optional)
템플릿 필드를 사용하면 오류 메시지의 현지화가 가능합니다.

다음과 같은 원본 템플릿을 사용할 수 있습니다:
“template”: “Running SQL for ${data.name}: ‘${data.query}’.”

번역기를 통해 실행하면 :
“template”: “Ejecutando SQL para ${data.name}: ‘${data.query}’.”.

이 예제에서는 자바스크립트의 템플릿 리터럴을 사용하고 있습니다. 이 표현식에는 메시지에서 값을 가져오는 위치를 정의하는 문자열이 포함되어 있습니다. 예를 들어, data.name 표현식은 메시지의 데이터 개체에서 이름 값을 가져옵니다. context.app.env 표현식은 컨텍스트 객체 아래에 있는 앱 객체에서 env 값을 가져옵니다.

또한 각 메시지에 대해 변경되는 값을 추출하면 소비자를 기반으로 메시지의 서식을 다시 지정할 수 있습니다. 개발자의 오류 메시지를 기록한 다음 다시 서식을 지정하여 프런트엔드 애플리케이션 사용자에게 전달할 수 있습니다.

### transactionId(required)
트랜잭션이 완료될 때까지 개발자가 트랜잭션을 추적할 수 있도록 여러 서비스에 걸쳐 있는 트랜잭션에 tarnsactId를 사용합니다. 트랜잭션 소스(예: UI에서 사용자가 클릭한 버튼)에서 tarnsactId가 생성됩니다.

tarnsactId는 디버깅에 사용되어 시스템의 성능 측면에 대한 인사이트를 얻을 수 있습니다.

참고: tarnsactId가 제공되지 않은 경우 로깅 서비스에서 tarnsactId를 생성합니다.

참고: tarnsactId는 개발자의 추가적인 노력이 필요합니다. 예를 들어, 개발자는 HTTP 헤더를 통해 클라이언트 서비스에 tarnsactId를 전달하고 다른 서비스에도 이 아이디를 전달해야 합니다.

Example: "transactId": "d5d98834–443d-4ac4-b3e0–5935fe476b56"

### sessionId(optional)
세션아이디는 세션을 관리하는 데 사용되는 고유 아이디입니다.

Example: "sessionId": "d9af77b4–1dfe-4a73-a8c2-f0c454e1dc70"

### time(required)
시간 객체에 포함된 내용입니다:
- format(optional) : 날짜 형식으로 설정합니다. UTC 오프셋이 있는 iso8601을 사용하고 있습니다.
- created(required) : 메시지의 생성 날짜와 시간입니다.
- expires(optional) : 메시지의 만료 날짜 및 시간입니다.

Example:
"time": {
  "format": "iso8601",
  "created": "2020-10-20T04:39:34+0700",
  "expires": "2020-12-20T09:00:34+0700"
}

### pii(optional)
메시지 내의 정보가 개인 식별 정보로 간주되는 경우가 있을 수 있습니다. 메시지 처리를 위해 메시지에서 PPI를 보내야 할 수도 있습니다. PPI를 기록하지 마세요.

PII 목록을 제공하면 시스템에서 데이터를 보는 사람을 기준으로 정보를 조합할 수 있습니다.

PII 속성에는 난독화할 데이터를 정의하는 문자열이 포함되어 있습니다. data.email 표현식은 이메일 주소를 난독화합니다.

Examples: "pii": ["data.email", "message"] 를 입력하면 다음과 같은 결과가 나타납니다.
{
  level: "warning",
  message: "***************************",
  data: {
    "email": "s******r@*******.com"
  }
}

### schema(optional)
스키마 객체는 데이터를 네이티브 객체 인스턴스로 변환하는 데이터 탈수화 시 데이터 속성에 적용할 수 있는 스키마의 이름과 버전을 정의합니다. 스키마를 사용하면 JOI와 같은 도구에서 데이터 속성에 있는 정보의 유효성을 검사할 수 있습니다.

name(optional) : 데이터 속성에 있는 스키마의 이름 또는 유형입니다.
ver(required) : 데이터 속성에서 찾은 스키마 버전입니다.

Example:
"schema" : {
  "name": "sql",
  "ver": "1.0.0"
}

### data(optional)
데이터 속성은 모든 유형의 데이터를 입력할 수 있는 영역을 제공합니다. 예를 들어, 메시지 속성에 다양한 정보를 데이터에 입력하고 템플릿 속성을 활용할 수 있습니다.

Example:
"data" : {
  "query": "SELECT * FROM types;",
  "name": "Alan",
}

### context (required)
컨텍스트는 메시지 작성 당시의 상황(컨텍스트)을 파악할 수 있는 정보를 제공합니다. 컨텍스트는 버그를 추적할 때 유용합니다.

app.env(required) - 소프트웨어의 환경. 예: 개발, 스테이지, 프로덕트 등.
app.name(optional) - 애플리케이션/서비스의 이름입니다.
app.platform(optional) - 애플리케이션/서비스가 상주하는 플랫폼. 플랫폼은 함께 설치된 애플리케이션/서비스의 집합체입니다.
app.file(optional) - 메시지의 파일 줄 번호입니다.
compute.host(optional) - 애플리케이션의 호스트 이름입니다.
shardId(optional) - 애플리케이션이 클러스터에서 실행되는 경우, 클러스터 내의 컴퓨팅 인스턴스를 식별하는 데 shardId가 사용됩니다.
processId (optional) - 프로세스의 ID입니다.
hostedBy.name(optional) - 서비스 또는 클라우드 플랫폼 이름입니다.
hostedBy.___(optional) - 호스트에 특정한 속성. 예를 들어, AWS의 경우 지역, 애플리케이션이 실행 중이던 역할 등을 포함할 수 있습니다.

Example:
"context" : {
    "app": {
      "env": "dev",
      "name": "loginService",
      "platform": "magicCrm",
      "file": "/Users/me/proj/login-service/query.ts",
      "line": 34,
    },
    "compute": {
      "host": "localhost",
      "shardId" : "9bc423dc-61f2-419c-9f53-8f417a74863e",
      "processId": "4545",
    },
    "hostedBy": {
      "name": "aws",
      "___": "hosted by specific properties",
    },
  },


### hash(optional)
해시 코드는 메시지 무결성을 확인합니다. 참고! 메시지에 해시 속성을 추가하기 전에 해시를 계산하세요.

algo(required) - 해시값을 생성하는 데 사용되는 알고리즘입니다. 몇 가지 알고리즘의 예로는 Md5, Sha1, Sha256, Sha384, Sha512, Crc32, Crc32b, Gost, Whirlpool, Ripemd160 및 Crypt 해시가 있습니다.
code(required) - 해시 코드 값입니다.

Example:
"hash": {
  "algo": "Sha1",
  "code": "4d90a79012905e89ea4473258e1874fcce12a593"
}

참고: 속성 순서도 중요합니다. 따라서 메시지를 역직렬화했다가 다시 직렬화하면 속성 순서가 변경되어 해시 코드가 무효화될 수 있습니다.
