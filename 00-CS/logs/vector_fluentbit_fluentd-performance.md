- https://medium.com/ibm-cloud/log-collectors-performance-benchmarking-8c5218a08fea

# Who is the winner — Comparing Vector, Fluent Bit, Fluentd performance

위의 인용문은 이 글의 주제인 로그 수집기 성능 벤치마킹을 비롯한 여러 상황에서 적절하게 활용될 수 있습니다.

많은 최신 애플리케이션은 OpenShift 또는 Kubernetes와 같은 클라우드 환경에서 마이크로 서비스로 배포됩니다. 중요한 애플리케이션을 사용할 수 없게 되면 조직은 심각한 영향을 받게 되므로 문제를 신속하게 해결하는 것이 필수적입니다.

통합 가시성은 로그, 메트릭, 및 추적을 사용하여 시스템의 내부 작동을 이해하는 데 도움이 되는 영역입니다. 로그는 통합 가시성을 위해 수집, 변환 및 저장할 수 있는 기본 데이터 소스입니다. 로그 수집은 CPU, 메모리, 스토리지와 같은 리소스 측면에서 비용이 많이 들며, 로그를 지속적으로 전송하는 많은 마이크로 서비스가 배포된 클라우드 환경에서는 더 많은 리소스를 필요로 합니다.

로그 수집기인 플루언트, 플루언트 비트, 벡터의 성능을 로그 수집 속도, CPU, 메모리를 기준으로 비교해 보겠습니다.

## 로그 수집기란 무엇인가요?

그림 1에서 볼 수 있듯이. 로그 수집기는 여러 소스(예: 파일, 시스템, 감사, 통계)에서 로그를 소비합니다. 수집기는 메타데이터로 항목을 보강하고, 구문 분석, 필터링 등을 포함하는 변환 작업을 수행할 수 있습니다. 그런 다음 이러한 로그는 여러 유형의 영구 스토리지로 전송됩니다.

https://miro.medium.com/v2/format:webp/1*vSC0LTgvjohDIyoPgzxfCQ.png

로그 소스는 서로 다른 비율로 로그를 생성하며 누적 볼륨이 수집기의 처리 용량보다 높을 수 있습니다. 이러한 경우 일부 로그가 누락될 수 있습니다. 이 시나리오를 로그 손실이라고 합니다. 로그는 매우 중요하기 때문에 수집기가 최대한 효율적으로 작동하는 것이 매우 중요합니다. 비교 대상인 로그 수집기를 살펴보겠습니다:

Fluentd: 통합 로깅 계층을 위한 오픈 소스 데이터 수집기입니다. Fluentd는 로그를 기계가 읽을 수 있는 대중적인 형식인 JSON으로 처리합니다. 주로 C로 작성되며, 사용자에게 유연성을 제공하는 씬 루비 래퍼를 사용합니다. Fluentd를 사용하면 데이터 수집과 소비를 통합하여 데이터를 더 잘 사용하고 이해할 수 있습니다. 여러 노드에서 클러스터 수준에서 로그 데이터를 수집하고 다양한 유형의 싱크로에 전달할 수 있습니다.

Fluent Bit: 또 다른 오픈 소스 수집기 유형으로, 다양한 소스에서 메트릭 및 로그와 같은 모든 데이터를 수집하고 필터를 통해 보강한 후 여러 대상으로 전송합니다. Fluent Bit는 C언어로 작성되었으며, 낮은 CPU 및 메모리 사용량으로 높은 처리량이라는 성능을 염두에 두고 설계되었습니다.

Vector: Rust가 내장된 Vector는 빠르고 메모리 효율적이며 가장 까다로운 워크로드도 처리할 수 있도록 설계되었습니다. Vector는 로그와 메트릭을 지원하므로 모든 통합 가시성 데이터를 쉽게 수집하고 처리할 수 있습니다.

## 실험 및 결과
베어메탈(BM) 서버에서 벤치마킹 성능 실험을 수행했습니다. 베어 메탈 플랫폼은 6개의 노드로 구성된 클러스터로 구성되어 있으며 이 실험에만 사용되었습니다. 각 노드에는 8개의 CPU와 64GB RAM이 있습니다. 워크로드 프로파일에 따라 다양한 유형의 부하를 생성할 수 있는 벤치마킹 프레임워크를 개발했습니다. 사용자 선호도에 따라 벤치마킹 프레임워크는 무작위 로그를 생성하거나 로드 생성기를 사용하여 실제 로그를 생성할 수 있습니다. 각 로그 유형의 예는 다음과 같습니다:

Random Log:
```
2021/03/30 15:51:21 goloader seq - 0000000000000000D34418F1172036F4 - 0000000044 - lkFklgcrEATMPbePsTgEOgkcDVyQIcwGuWRyZULhpUDBOpWSpBPjUGWicYGPSbnihsJsZtJokCFThVnRSvgmOQEEQqsdAtitFBvT

```
Realistic Log:
```
E0427 11:44:58.439709 1 memcache.go:206] couldn’t get resource list for metrics.k8s.io/v1beta1: an error on the server

```

프레임워크는 표 1에 표시된 것처럼 프로파일이라고 하는 여러 유형의 워크로드를 지원하며, 이는 초당 로그 생성량(LGPS)으로 측정됩니다. 각 프로파일에는 낮은 LGPS 또는 높은 LGPS 비율로 로그를 생성하는 저스트레스 및 고스트레스 컨테이너의 수가 다릅니다. 프로파일의 작동 방식을 설명하기 위해 Heavy Loss 프로파일을 예로 들어보겠습니다. 이 프로파일에는 LGPS가 1500인 저스트레스 컨테이너 8개와 20000인 고스트레스 컨테이너 2개가 있어 총 52000 LGPS가 생성됩니다.

https://miro.medium.com/v2/format:webp/1*7kooNvvQameopDDMkXV5AA.png

프레임워크가 로그 생성을 시작하면 로그 생성 프로세스를 안정화시키는 데 몇 분 정도 걸립니다. 30분 동안 워크로드 생성 프로세스를 실행하고 CPU 및 메모리와 같은 각 메트릭의 평균값을 구합니다.

초당 로그 수(LPS)라는 메트릭을 정의합니다. 이 메트릭은 수집기가 초당 수집한 로그 라인 수를 나타냅니다. 그림 2와 그림 3은 다양한 수집기에 대한 LPS와 메모리 소비량을 보여줍니다. 벡터의 성능이 가장 우수하며 이 차이는 워크로드가 많은 프로파일에서 더 크게 나타납니다. 예를 들어, 과중한 워크로드 프로파일의 경우 차선책인 수집기(Fluent Bit)와 비교했을 때 LPS가 2배 이상 높습니다. 마찬가지로 메모리 소비량도 워크로드가 많은 프로파일의 경우 Vector가 가장 적고 거의 0.5배에서 0.2배에 불과합니다.

그림 4와 5는 다양한 수집기에 대한 CPU와 CPU당 LPS를 보여줍니다. 과부하 프로파일의 경우 벡터가 다른 수집기에 비해 거의 2배~3배 더 많은 CPU를 소비하는 것을 관찰했습니다. 또한 그림 2에서 벡터의 LPS도 매우 높다는 것을 알 수 있습니다. 이는 다른 수집기들이 그렇게 할 수 없는 반면, 벡터는 사용 가능한 CPU를 활용하여 LPS를 확장할 수 있다는 것을 나타냅니다. CPU 성능을 비교하기 위해 그림 5에 표시된 것처럼 CPU당 LPS를 측정하는 정규화를 수행했습니다. 최고 성능의 수집기(Fluent Bit)와 벡터의 차이는 특히 높은 워크로드 프로파일의 경우 크지 않은 것으로 나타났습니다.

또한 AWS 플랫폼에서 벤치마킹을 실행하고 싶었지만 초기 실험을 통해 실험을 다른 시간에 실행할 때 성능에 큰 차이가 있다는 것을 알게 되었습니다. 저희는 아마존의 범용(gp2라고 함) m4.2xlarge 인스턴스를 사용했습니다. gp2 인스턴스에서는 스로틀링이 특히 워크로드가 많은 실험에 큰 영향을 미치는 것을 관찰했습니다. AWS는 모든 Amazon EC2 고객에게 공정한 사용을 보장하고자 하기 때문에 AWS gp2에서는 클러스터 IOPS가 제한됩니다. 이러한 실험은 짧은 지연 시간이 필요한 IOPS 집약적이고 처리량 집약적인 워크로드를 위해 설계된 프로비저닝된 IOPS 기반 인스턴스에서 실행할 계획입니다.

결론:

대부분의 경우 Vector의 성능이 CPU당 LPS와 LPS 측면에서 가장 우수하다는 것을 확인했습니다. 확장성이 뛰어나고 메모리 소비량도 다른 수집기에 비해 현저히 적습니다. CPU 소비량 측면에서는 플루언트 비트의 성능이 가장 우수했습니다.
