- https://opensource.com/article/18/4/ext4-filesystem

# Understanding Linux filesystems: ext4 and beyond
ext3 및 그 이전의 다른 파일 시스템과의 차이점을 포함하여 ext4의 역사에 대해 알아보세요.

이전 Linux 배포판의 기본값이 ext3, ext2, 그리고 더 거슬러 올라가면 ext였던 것처럼, 대부분의 최신 Linux 배포판은 기본적으로 ext4 파일 시스템을 사용합니다.

리눅스나 파일시스템을 처음 접하는 분이라면 ext4가 ext3에 비해 어떤 점이 달라졌는지 궁금할 수 있습니다. 또한 btrfs, xfs, zfs와 같은 대체 파일시스템에 대한 뉴스가 쏟아지는 상황에서 ext4가 여전히 활발하게 개발 중인지 궁금할 수도 있습니다.

한 개의 글에서 파일시스템에 대한 모든 것을 다룰 수는 없지만, Linux의 기본 파일시스템의 역사와 현재 상태, 앞으로의 전망에 대해 알아볼 수 있도록 노력하겠습니다.

이 개요를 준비하면서 Wikipedia의 다양한 ext 파일 시스템 문서, kernel.org의 ext4에 대한 위키 항목, 그리고 제 경험을 많이 참고했습니다.

## A brief history of ext

## MINIX filesystem
확장자가 있기 전에는 MINIX 파일 시스템이 있었습니다. 리눅스의 역사를 잘 모르시는 분들을 위해 설명하자면, MINIX는 IBM PC/AT 마이크로컴퓨터를 위한 아주 작은 유닉스와 유사한 운영 체제였습니다. 앤드류 타넨바움이 교육 목적으로 개발하여 1987년에 소스 코드(인쇄본 형태!)를 공개했습니다.

MINIX의 소스를 열람할 수는 있었지만 실제로는 무료 오픈 소스 소프트웨어(FOSS)가 아니었습니다. 탄네바움의 책을 출판한 출판사는 MINIX를 운영하기 위해 69달러의 라이선스 비용을 책값에 포함시켜 요구했습니다. 하지만 당시로서는 엄청나게 저렴한 가격이었기 때문에, 단순히 운영 체제 코딩을 가르치는 데만 사용하려던 Tannenbaum의 원래 의도를 뛰어넘어 MINIX의 채택이 빠르게 증가했습니다. 1990년대에 들어서면서 전 세계 대학에서 MINIX 설치가 활발해졌고, 젊은 라이너스 토발즈는 1991년에 처음 발표되어 1992년 12월에 GPL로 배포된 오리지널 리눅스 커널을 개발하는 데 MINIX를 사용했습니다.

잠깐만요, 이건 파일 시스템 기사잖아요? 예, MINIX에는 초기 버전의 리눅스도 의존했던 자체 파일시스템이 있었습니다. MINIX 파일 시스템은 파일 이름을 최대 14자까지만 처리할 수 있고 64MB의 저장 공간만 다룰 수 있었습니다. 1991년 당시 일반적인 하드 드라이브의 크기는 이미 40~140MB였습니다. 리눅스에는 분명히 더 나은 파일 시스템이 필요했습니다!

## ext
라이너스가 초창기 리눅스 커널을 해킹하는 동안 레미 카드는 최초의 확장자 파일 시스템을 개발했습니다. 리눅스가 처음 발표된 지 불과 1년 후인 1992년에 처음 구현된 ext는 MINIX 파일시스템의 최악의 문제를 해결했습니다.

1992년의 ext는 리눅스 커널의 새로운 가상 파일 시스템(VFS) 추상화 계층을 사용했습니다. 그 이전의 MINIX 파일 시스템과 달리, ext는 최대 2GB의 저장 공간을 처리하고 255자의 파일 이름을 처리할 수 있었습니다.

하지만 원시적인 타임스탬프(오늘날 우리가 익히 알고 있는 아이노드 생성, 파일 액세스, 파일 수정을 위한 세 개의 개별 스탬프가 아닌 파일당 하나의 타임스탬프)로 인해 ext의 수명은 그리 길지 않았습니다. 불과 1년 후, ext2는 점심을 먹었습니다.

## ext2
레미는 1년 후 ext를 대체할 ext2를 설계했기 때문에 ext의 한계를 금방 깨달았습니다. ext는 여전히 "장난감" 운영 체제에 뿌리를 두고 있었지만, ext2는 처음부터 BSD의 버클리 패스트 파일 시스템과 동일한 원칙에 따라 상용 등급의 파일 시스템으로 설계되었습니다.

Ext2는 기가바이트 단위의 최대 파일 크기와 테라바이트 단위의 파일 시스템 크기를 제공했으며, 1990년대에 확고하게 자리를 잡았습니다. 리눅스 커널은 물론이고 MINIX, 그리고 타사 모듈을 통해 MacOS와 Windows에서도 사용할 수 있게 되면서 빠르고 광범위하게 채택되었습니다.

하지만 1990년대의 대부분의 파일 시스템과 마찬가지로 ext2 파일 시스템은 데이터가 디스크에 기록되는 동안 시스템이 충돌하거나 전원이 꺼지면 치명적인 손상을 입기 쉬웠습니다. 또한 시간이 지남에 따라 조각화(하나의 파일이 회전하는 디스크 주위에 물리적으로 흩어져 여러 곳에 저장되는 현상)로 인해 상당한 성능 저하가 발생했습니다.

이러한 문제에도 불구하고 ext2는 오늘날에도 일부 특수한 경우, 즉 휴대용 USB 썸 드라이브의 포맷으로 사용되고 있습니다.

## ext3
ext2가 채택된 지 6년 후인 1998년, 스티븐 트위디는 이를 크게 개선하기 위해 노력하고 있다고 발표했습니다. 이것이 바로 2001년 11월에 커널 버전 2.4.15와 함께 메인라인 Linux에 채택된 ext3입니다.

Ext2는 대부분의 Linux 배포판에서 매우 잘 작동했지만, 당시의 FAT, FAT32, HFS 및 기타 파일 시스템과 마찬가지로 전원 손실 시 치명적인 손상이 발생하기 쉬웠습니다. 파일시스템에 데이터를 쓰던 중 전원이 끊기면 파일시스템은 일관성이 없는 상태, 즉 작업이 절반은 완료되고 절반은 완료되지 않은 상태로 남을 수 있습니다. 이로 인해 저장 중인 파일과 무관한 방대한 양의 파일이 손실되거나 손상될 수 있으며, 심지어 전체 파일시스템이 마운트 해제될 수도 있습니다.

Ext3와 1990년대 후반에 개발된 Microsoft의 NTFS와 같은 기타 파일시스템은 이 문제를 해결하기 위해 저널링을 사용합니다. 저널은 쓰기가 트랜잭션에 저장되는 디스크의 특수 할당으로, 트랜잭션이 디스크에 쓰기를 완료하면 저널에 있는 데이터가 파일시스템 자체에 커밋됩니다. 해당 작업이 커밋되기 전에 시스템이 충돌하면 새로 재부팅된 시스템은 이를 불완전한 트랜잭션으로 인식하고 처음부터 없었던 것처럼 롤백합니다. 즉, 작업 중인 파일은 여전히 손실될 수 있지만 파일 시스템 자체는 일관성을 유지하며 다른 모든 데이터는 안전합니다. ext3의 Linux 커널 구현에서는 저널, 정렬, 쓰기백의 세 가지 수준의 저널링을 사용할 수 있습니다.

- Journal은 위험도가 가장 낮은 모드로, 파일시스템에 커밋하기 전에 데이터와 메타데이터를 모두 저널에 기록합니다. 이렇게 하면 쓰는 파일과 파일 시스템 전체의 일관성이 보장되지만 성능이 크게 저하될 수 있습니다.
- Ordered 모드는 대부분의 Linux 배포판에서 기본 모드이며, 정렬 모드는 메타데이터를 저널에 쓰지만 데이터를 파일시스템에 직접 커밋합니다. 이름에서 알 수 있듯이 이 모드에서는 작업 순서가 엄격합니다: 먼저 메타데이터를 저널에 커밋하고, 데이터를 파일시스템에 쓴 다음, 저널에 있는 관련 메타데이터를 파일시스템 자체에 플러시합니다. 이렇게 하면 충돌이 발생해도 불완전한 쓰기와 관련된 메타데이터가 여전히 저널에 남아 있고, 파일시스템이 저널을 롤백하면서 불완전한 쓰기를 정리할 수 있습니다. 정렬 모드에서는 크래시가 발생하면 크래시 중에 활발하게 쓰던 파일이 손상될 수 있지만, 파일시스템 자체와 활발하게 쓰던 파일이 아닌 파일은 안전이 보장됩니다.
- Writeback는 세 번째이자 가장 안전하지 않은 저널링 모드입니다. 쓰기백 모드에서는 정렬 모드와 마찬가지로 메타데이터는 저널링되지만 데이터는 저널링되지 않습니다. 정렬 모드와 달리, 메타데이터와 데이터는 모두 최상의 성능을 위해 원하는 순서대로 기록할 수 있습니다. 이렇게 하면 성능이 크게 향상될 수 있지만 안전성은 훨씬 떨어집니다. 다시 쓰기 모드는 여전히 파일 시스템 자체의 안전성을 보장하지만, 충돌이 발생하는 동안 또는 그 전에 쓰여진 파일은 손실이나 손상에 취약합니다.

이전의 ext2와 마찬가지로 ext3는 16비트 내부 주소 지정을 사용합니다. 즉, 블록 크기가 4K인 경우 처리할 수 있는 최대 파일 크기는 최대 파일 시스템 크기인 16TiB에서 2TiB입니다.

## ext4
당시 ext3의 주요 개발자였던 Theodore Ts'o는 2006년에 ext4를 발표했고, 2년 후 커널 버전 2.6.28에서 리눅스 메인라인에 추가되었습니다. Ts'o는 ext4를 ext3를 크게 확장했지만 여전히 오래된 기술에 의존하고 있는 임시방편 기술이라고 설명합니다. 그는 언젠가는 진정한 차세대 파일 시스템으로 대체될 것으로 예상합니다.

Ext4는 기능적으로 ext3와 매우 유사하지만 대용량 파일 시스템 지원, 향상된 조각화 방지 기능, 더 높은 성능 및 향상된 타임스탬프를 제공합니다.

## ext4 vs ext3
Ext3와 Ext4에는 몇 가지 구체적인 차이점이 있는데, 여기서는 이에 대해 집중적으로 설명하겠습니다.

### Backwards compatibility
Ext4는 ext3와 최대한 하위 호환되도록 특별히 설계되었습니다. 따라서 ext3 파일시스템을 ext4로 업그레이드할 수 있을 뿐만 아니라, ext4 드라이버가 ext3 모드에서 ext3 파일시스템을 자동으로 마운트할 수 있으므로 두 코드베이스를 별도로 유지 관리할 필요가 없습니다.

### Large filesystems
Ext3 파일시스템은 32비트 주소 지정을 사용하여 2TiB 파일과 16TiB 파일시스템으로 제한했습니다(블록 크기 4KB 가정, 일부 ext3 파일시스템은 더 작은 블록 크기를 사용하므로 이보다 더 제한됨).

Ext4는 48비트 내부 주소 지정을 사용하므로 이론적으로 최대 1,000,000TiB(1EiB)의 파일시스템에 최대 16TiB까지 파일을 할당할 수 있습니다. ext4의 초기 구현은 일부 유저랜드 유틸리티에 의해 여전히 16TiB 파일 시스템으로 제한되었지만, 2011년부터는 e2fsprogs가 16TiB 이상의 ext4 파일 시스템 생성을 직접 지원하고 있습니다. 한 가지 예로, 레드햇 엔터프라이즈 리눅스는 계약상 ext4 파일시스템을 최대 50TiB까지만 지원하며, 100TiB 이하의 ext4 볼륨을 권장합니다.

### Allocation improvements
Ext4는 스토리지 블록을 디스크에 쓰기 전에 할당하는 방식에 많은 개선 사항을 도입하여 읽기 및 쓰기 성능을 모두 크게 향상시킬 수 있습니다.

#### Extents
익스텐션은 한 번에 예약하고 주소를 지정할 수 있는 연속된 물리적 블록의 범위(4KB 블록 크기 가정 시 최대 128MiB)입니다. 익스텐션을 활용하면 특정 파일에 필요한 이노드 수가 줄어들고, 대용량 파일을 쓸 때 조각화가 현저히 줄어들고 성능이 향상됩니다.

### Multiblock allocation
Ext3는 새 블록이 할당될 때마다 블록 할당자를 한 번씩 호출합니다. 이로 인해 여러 개의 쓰기가 동시에 열려 있을 때 조각화가 심해질 수 있습니다. 그러나 ext4는 지연 할당을 사용하여 쓰기를 통합하고 아직 커밋하지 않은 쓰기에 대해 블록을 할당하는 방법에 대해 더 나은 결정을 내릴 수 있습니다.

### Persistent pre-allocation
파일에 디스크 공간을 미리 할당할 때, 대부분의 파일 시스템은 파일을 만들 때 해당 파일의 블록에 0을 써야 합니다. Ext4에서는 대신 fallocate()를 사용할 수 있는데, 이 함수는 먼저 쓸 필요 없이 공간의 가용성을 보장하고 인접한 공간을 찾으려고 시도합니다. 이렇게 하면 스트리밍 및 데이터베이스 애플리케이션의 쓰기와 향후 쓰기된 데이터 읽기 성능이 크게 향상됩니다.

### Delayed allocation
이 기능은 논쟁의 여지가 많은 기능입니다. 지연 할당을 사용하면 ext4는 데이터를 디스크에 커밋할 준비가 될 때까지 데이터를 쓸 실제 블록을 할당할 때까지 기다릴 수 있습니다. (반면, ext3는 데이터가 쓰기 캐시로 계속 흘러가는 동안에도 즉시 블록을 할당합니다.)

데이터가 캐시에 누적될 때 블록 할당을 지연시키면 파일시스템이 블록 할당 방법에 대해 더 현명한 선택을 할 수 있으므로 조각화(쓰기 및 나중에 읽기)가 줄어들고 성능이 크게 향상됩니다. 하지만 안타깝게도 프로그래머가 데이터가 디스크에 완전히 플러시되었는지 확인하고자 할 때 fsync()를 호출하도록 특별히 작성되지 않은 프로그램에서는 데이터 손실 가능성이 높아집니다.

한 프로그램이 파일을 완전히 다시 쓴다고 가정해 보겠습니다:

fd=open("file" ,O_TRUNC); write(fd, data); close(fd);

레거시 파일시스템에서는 close(fd); 만으로도 파일의 내용이 디스크에 플러시되도록 보장할 수 있습니다. 엄밀히 말하면 쓰기가 트랜잭션이 아니더라도 파일을 닫은 후 충돌이 발생해도 데이터가 손실될 위험은 거의 없습니다.

프로그램 오류, 디스크 오류, 정전 등으로 인해 쓰기가 성공하지 못하면 파일의 원본 버전과 최신 버전이 모두 손실되거나 손상될 수 있습니다. 파일이 작성되는 동안 다른 프로세스가 파일에 액세스하면 손상된 버전이 표시됩니다. 그리고 다른 프로세스가 파일을 열어 놓고 그 내용이 변경될 것으로 예상하지 못하는 경우(예: 실행 중인 여러 프로그램에 매핑된 공유 라이브러리) 충돌이 발생할 수 있습니다.

이러한 문제를 피하기 위해 일부 프로그래머는 O_TRUNC를 아예 사용하지 않습니다. 대신 새 파일에 쓰고 닫은 다음 이전 파일 위에 이름을 바꾸는 방법을 사용합니다:

fd=open("newfile"); write(fd, data); close(fd); rename("newfile", "file");

지연 할당이 없는 파일 시스템에서는 위에서 설명한 잠재적인 손상 및 충돌 문제를 피하기에 충분합니다: rename()은 원자 연산이므로 충돌로 인해 중단되지 않으며, 실행 중인 프로그램은 파일 핸들이 열려 있는 한 연결되지 않은 이전 버전의 파일을 계속 참조할 수 있습니다. 그러나 ext4의 지연 할당으로 인해 쓰기가 지연되고 순서가 변경될 수 있기 때문에, 새로운 파일의 내용이 실제로 디스크에 기록되기 전에 이름 바꾸기("newfile","file")가 수행될 수 있으며, 이로 인해 병렬 프로세스가 잘못된 버전의 파일을 다시 가져오는 문제가 발생할 수 있습니다.

이를 완화하기 위해 Linux 커널(버전 2.6.30부터)은 이러한 일반적인 코드 사례를 감지하여 해당 파일을 즉시 할당하도록 시도합니다. 이는 데이터 손실 가능성을 줄이기는 하지만 완전히 방지하지는 못하며, 새 파일에는 전혀 도움이 되지 않습니다. 개발자의 경우, 데이터가 디스크에 즉시 기록되도록 보장하는 유일한 방법은 fsync()를 적절히 호출하는 것뿐이라는 점에 유의하세요.

### Unlimited subdirectories
Ext3는 총 32,000개의 하위 디렉터리로 제한되었지만, ext4는 무제한으로 허용됩니다. 커널 2.6.23부터 ext4는 HTree 인덱스를 사용하여 많은 수의 하위 디렉터리로 인한 성능 저하를 완화합니다.

### Journal checksumming
Ext3는 저널을 체크섬하지 않았기 때문에 커널의 직접적인 제어를 벗어난 자체 캐시가 있는 디스크 또는 컨트롤러 장치에 문제가 발생했습니다. 자체 캐시가 있는 컨트롤러나 디스크가 순서대로 쓰기를 수행하지 않으면 Ext3의 저널링 트랜잭션 순서가 깨져 충돌이 발생하는 동안(또는 그 전 일정 시간 동안) 쓰여지는 파일이 손상될 수 있습니다.

이론적으로 이 문제는 쓰기 배리어를 사용하면 해결할 수 있습니다. 파일 시스템을 마운트할 때 마운트 옵션에서 barrier=1을 설정하면 장치가 fsync() 호출을 끝까지 준수합니다. 실제로는 스토리지 장치와 컨트롤러가 쓰기 배리어를 준수하지 않는 경우가 많아서 성능(및 경쟁사와 비교하는 벤치마크)은 향상되지만, 방지했어야 할 데이터 손상의 가능성이 열려 있는 것으로 밝혀졌습니다.

저널을 체크섬하면 파일시스템이 충돌 후 첫 번째 마운트에서 일부 항목이 유효하지 않거나 순서가 잘못되었다는 것을 인식할 수 있습니다. 따라서 저장 장치가 거짓말을 하거나 장벽을 준수하지 않는 경우에도 일부 또는 순서가 잘못된 저널 항목을 롤백하여 파일 시스템을 추가로 손상시키는 실수를 방지할 수 있습니다.

### Fast filesystem checks
ext3에서는 fsck가 호출될 때 삭제된 파일과 비어 있는 파일을 포함한 전체 파일 시스템을 검사해야 했습니다. 반면, ext4에서는 할당되지 않은 블록과 inode 테이블 섹션을 그대로 표시하여 fsck가 이를 완전히 건너뛸 수 있습니다. 이렇게 하면 대부분의 파일 시스템에서 fsck를 실행하는 시간이 크게 단축되며 커널 2.6.24부터 구현되었습니다.

### Improved timestamps
Ext3는 1초 단위로 세분화된 타임스탬프를 제공했습니다. 대부분의 용도로는 충분하지만, 미션 크리티컬 애플리케이션은 훨씬 더 엄격한 시간 제어를 원하는 경우가 많습니다. Ext4는 나노초 단위의 타임스탬프를 제공함으로써 이러한 엔터프라이즈, 과학, 미션 크리티컬 애플리케이션에 적합합니다.

또한 Ext3 파일시스템은 2038년 1월 18일 이후의 날짜를 저장하기에 충분한 비트를 제공하지 못했습니다. Ext4는 여기에 2비트를 추가하여 유닉스 시대를 408년 더 연장했습니다. 서기 2446년에 이 글을 읽고 계신다면 이미 더 나은 파일시스템으로 옮겼을 테지만, 1970년 1월 1일 UTC 00:00 이후의 시간을 여전히 측정하고 계신다면 제 사후에도 매우 기쁠 것 같습니다.

### Online defragmentation
ext2나 ext3 모두 온라인 조각 모음, 즉 마운트된 상태에서 파일 시스템 조각 모음을 직접 지원하지 않았습니다. Ext2에는 이름에서 알 수 있듯이 e2defrag라는 유틸리티가 포함되어 있었지만, 이 유틸리티는 파일 시스템이 마운트되지 않은 상태에서 오프라인으로 실행해야 했습니다. (이것은 루트 파일시스템에서 특히 문제가 됩니다.) ext3의 경우 상황은 더욱 심각했습니다. ext3는 ext2에 비해 심각한 조각화 문제가 발생할 가능성이 훨씬 적었지만, ext3 파일시스템에 대해 e2defrag를 실행하면 치명적인 손상과 데이터 손실이 발생할 수 있었습니다.

ext3는 원래 "조각화의 영향을 받지 않는" 것으로 간주되었지만, 동일한 파일에 대한 대규모 병렬 쓰기 프로세스를 사용하는 프로세스(예: BitTorrent)는 이것이 전적으로 사실이 아니라는 것을 분명히 보여주었습니다. Shake와 같은 여러 사용자 공간 해킹과 해결 방법이 이 문제를 해결했지만, 파일 시스템을 인식하는 진정한 커널 수준의 조각 모음 프로세스에 비해 속도가 느리고 여러 가지 면에서 만족스럽지 못했습니다.

Ext4는 온라인, 커널 모드, 파일 시스템 인식, 블록 및 확장자 수준 조각 모음 유틸리티인 e4defrag로 이 문제를 정면으로 해결합니다.

## Ongoing ext4 development
몬티 파이썬 전염병의 피해자가 말했듯이, Ext4는 "아직 완전히 죽지 않았습니다!"입니다. 주요 개발자는 이를 진정한 차세대 파일시스템으로 가는 과정의 임시방편으로 간주하고 있지만, 아직까지는 (기술 또는 라이선스 문제로 인해) 루트 파일시스템으로 배포할 준비가 된 후보 중 어느 것도 없습니다.

메타데이터 체크섬, 일급 할당량 지원, 대용량 할당 블록 등 몇 가지 주요 기능이 아직 ext4의 향후 버전으로 개발되고 있습니다.

### Metadata checksumming
ext4에는 중복 슈퍼블록이 있으므로, 그 안에 있는 메타데이터를 체크섬하면 파일시스템이 기본 슈퍼블록이 손상되어 대체 슈퍼블록을 사용해야 하는지 여부를 스스로 파악할 수 있습니다. 체크섬을 하지 않고도 손상된 슈퍼블록에서 복구할 수 있지만, 사용자가 먼저 슈퍼블록이 손상되었다는 사실을 인지한 다음 대체 슈퍼블록을 사용하여 파일시스템을 수동으로 마운트해야 합니다. 손상된 기본 슈퍼블록으로 파일시스템 읽기-쓰기를 마운트하면 경우에 따라 추가 손상이 발생할 수 있으므로, 경험이 많은 사용자라도 이 방법은 충분한 해결책이 아닙니다!

차세대 파일 시스템인 btrfs나 zfs가 제공하는 매우 강력한 블록별 체크섬과 비교하면, ext4의 메타데이터 체크섬은 매우 약한 기능입니다. 하지만 없는 것보다는 훨씬 낫습니다.

"모든 것을 체크섬하라!"는 당연한 말처럼 들리지만, 사후에 파일시스템에 체크섬을 적용하는 데는 몇 가지 중요한 과제가 있습니다. 자세한 내용은 설계 문서를 참조하세요.

### First-class quota support
잠깐, 할당량?! 익스플로러 2 시절부터 있었잖아요! 네, 하지만 항상 뒷전으로 밀려났고 항상 형편없었습니다. 여기서 자세히 설명할 필요는 없지만, 디자인 문서에는 할당량을 사용자 공간에서 커널로 이동하고 더 정확하고 성능 좋게 적용하는 방법이 설명되어 있습니다.

### Large allocation blocks
시간이 지날수록 이러한 성가신 스토리지 시스템은 점점 더 커지고 있습니다. 일부 솔리드 스테이트 드라이브는 이미 8K 하드웨어 블록 크기를 사용하고 있기 때문에, 현재 4K 블록으로 제한되어 있는 ext4의 한계는 점점 더 커지고 있습니다. 스토리지 블록이 커지면 '여유 공간'(파일을 저장하는 데 블록의 일부 또는 파일의 마지막 부분만 필요할 때 남는 공간)이 증가하는 대신 조각화가 줄어들고 성능이 크게 향상될 수 있습니다.

## Practical limitations of ext4
Ext4는 강력하고 안정적인 파일 시스템으로, 2018년에는 대부분의 사람들이 루트 파일 시스템으로 사용해야 할 것입니다. 하지만 모든 것을 처리할 수는 없습니다. 현재 또는 미래에 ext4에서 기대하지 말아야 할 몇 가지 사항에 대해 간략하게 알아보겠습니다.

ext4는 최대 1 EiB(1,000,000TiB에 해당)의 데이터를 처리할 수 있지만, 그렇게 하려고 해서는 안 됩니다. 단순히 더 많은 블록의 주소를 기억할 수 있는 것 이상의 확장성 문제가 있으며, ext4는 현재 50~100TiB의 데이터 이상으로 확장되지 않으며 앞으로도 확장되지 않을 가능성이 높습니다.

또한 Ext4는 데이터의 무결성을 보장하기에 충분하지 않습니다. ext3 시절에 저널링 기능이 크게 발전한 것은 사실이지만, 데이터 손상의 일반적인 원인 중 많은 부분을 다루지 못합니다. 데이터가 이미 디스크에 저장된 상태에서 손상된 경우(하드웨어 결함, 우주선의 영향, 또는 시간이 지남에 따른 단순한 데이터 성능 저하 등) ext4는 이러한 손상을 감지하거나 복구할 수 있는 방법이 없습니다.

앞의 두 가지 항목에 비추어 볼 때, ext4는 순수한 파일 시스템일 뿐 스토리지 볼륨 관리자가 아닙니다. 즉, 이론적으로 손상된 데이터를 복구할 수 있는 패리티 또는 중복 디스크가 여러 개 있더라도 ext4는 이를 알거나 유용하게 사용할 수 있는 방법이 없습니다. 이론적으로는 자동 손상 탐지 및 복구 기능을 잃지 않고 파일 시스템과 스토리지 볼륨 관리 시스템을 개별 계층으로 분리할 수 있지만, 현재 스토리지 시스템의 설계 방식은 그렇지 않으며 새로운 설계에는 상당한 어려움이 따릅니다.

## Alternate filesystems
시작하기 전에 경고 한 마디: 배포판의 메인라인 커널에 내장되어 있지 않고 직접 지원되지 않는 대체 파일시스템은 매우 주의하세요!

파일시스템이 안전하다고 해도 커널 업그레이드 중에 문제가 발생하면 루트 파일시스템으로 사용하는 것은 정말 끔찍한 일이 될 수 있습니다. 대체 미디어에서 부팅하고 커널 모듈, 그럽 구성, DKMS를 수동으로 인내심을 갖고 들여다보는 것에 익숙하지 않다면, 중요한 시스템에서 루트 파일시스템을 사용하는 것을 망설이지 마세요.

배포판에서 직접 지원하지 않는 파일시스템을 사용해야 할 이유가 있을 수 있지만, 사용해야 한다면 시스템을 가동하고 사용할 수 있게 된 후에 마운트할 것을 강력히 권장합니다. (예를 들어, ext4 루트 파일시스템이 있지만 대부분의 데이터를 zfs 또는 btrfs 풀에 저장할 수 있습니다.)

### XFS
XFS는 리눅스에서 익스플로러가 아닌 파일시스템의 메인스트림에 해당합니다. 2001년부터 Linux 커널에 내장된 64비트 저널링 파일시스템으로, 대용량 파일시스템에 대한 고성능과 높은 수준의 동시성(즉, 한 번에 많은 수의 프로세스가 모두 파일시스템에 쓰는 것)을 제공합니다.

XFS는 RHEL 7부터 레드햇 엔터프라이즈 리눅스의 기본 파일시스템이 되었습니다. 가정이나 소규모 비즈니스 사용자에게는 여전히 몇 가지 단점이 있는데, 특히 기존 XFS 파일시스템의 크기를 조정하는 것이 매우 번거롭기 때문에 다른 파일시스템을 만들어 데이터를 복사하는 것이 더 합리적일 수 있습니다.

XFS는 안정적이고 성능이 뛰어나지만, 50TiB 이상의 대용량 파일 시스템과 같이 ext4에서 발생하는 특정 문제를 해결하지 않는 한 기본값(예: RHEL7)이 아닌 곳에서는 사용을 권장할 만큼 최종 사용 환경에서의 구체적인 차이점이 충분하지 않습니다.

XFS는 ZFS, btrfs, 심지어 WAFL(독점적인 SAN 파일시스템)과 같은 방식으로 '차세대' 파일시스템이 아닙니다. ext4와 마찬가지로 더 나은 파일 시스템으로 가기 위한 임시방편으로 간주해야 합니다.

### ZFS
ZFS는 이론적으로 1조 기가바이트에 해당하는 제타바이트에서 이름을 따온 것으로, 이 정도 용량의 스토리지 시스템을 처리할 수 있다는 의미에서 썬마이크로시스템즈에서 개발했습니다.

진정한 차세대 파일 시스템인 ZFS는 볼륨 관리(단일 파일 시스템에서 여러 개별 저장 장치를 처리하는 기능), 블록 수준의 암호화 체크섬(매우 높은 정확도로 데이터 손상을 감지할 수 있음), 자동 손상 복구(중복 또는 패리티 스토리지 사용 가능), 빠른 비동기 증분 복제, 인라인 압축 등의 기능을 제공합니다. 그 외에도.

Linux 사용자의 관점에서 볼 때 ZFS의 가장 큰 문제점은 라이선스입니다. ZFS는 GPL과 상충되는 반허락 라이선스인 CDDL 라이선스를 받았습니다. 리눅스 커널과 함께 ZFS를 사용하는 것이 어떤 영향을 미치는지에 대해 "GPL 위반이다", "CDDL 위반이다", "법정에서 테스트되지 않았을 뿐 완전히 괜찮다"는 등 다양한 의견이 있습니다. 특히, Canonical은 2016년부터 지금까지 법적 문제 없이 기본 커널에 ZFS 코드를 인라인으로 포함시켰습니다.

현재로서는 저 역시 열렬한 ZFS 사용자인데도 ZFS를 루트 Linux 파일 시스템으로 추천하고 싶지 않습니다. Linux에서 ZFS의 이점을 활용하려면 ext4에 작은 루트 파일시스템을 설정한 다음 남은 스토리지에 ZFS를 설치하고 데이터, 애플리케이션 등 원하는 것을 넣되, 배포판에서 zfs 루트를 명시적으로 지원할 때까지는 루트 파일시스템을 ext4에 유지하세요.

### btrfs
B트리 파일시스템의 줄임말이자 보통 "버터"라고 발음되는 Btrfs는 2007년 크리스 메이슨이 오라클에 재직하던 시절에 발표했습니다. Btrfs는 다중 장치 관리, 블록별 체크섬, 비동기식 복제, 인라인 압축 등을 제공하는 등 ZFS와 거의 동일한 목표를 지향합니다.

2018년 현재, btrfs는 표준 단일 디스크 파일 시스템으로 상당히 안정적이고 유용하지만 볼륨 관리자로는 사용하지 않는 것이 좋습니다. 많은 일반적인 사용 사례에서 ext4, XFS 또는 ZFS에 비해 심각한 성능 문제를 겪고 있으며, 차세대 기능인 복제, 다중 디스크 토폴로지, 스냅샷 관리에는 심각한 성능 저하부터 실제 데이터 손실에 이르기까지 다양한 버그가 발생할 수 있습니다.

SUSE Enterprise Linux는 2015년에 기본 파일 시스템으로 채택한 반면, Red Hat은 2017년 RHEL 7.4부터 더 이상 btrfs를 지원하지 않겠다고 발표하는 등 btrfs의 현재 상태는 논란의 여지가 있습니다. 한 가지 주목해야 할 점은 btrfs를 지원하는 프로덕션 배포에서는 ZFS와 같은 다중 디스크 볼륨 관리자가 아닌 단일 디스크 파일 시스템으로 사용한다는 점입니다. 심지어 Synology는 스토리지 어플라이언스에서 btrfs를 사용하지만 기존 Linux 커널 RAID(mdraid) 위에 계층화하여 디스크를 관리하고 있습니다.

