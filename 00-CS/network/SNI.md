- https://en.wikipedia.org/wiki/Server_Name_Indication

# Server Name Indication
SNI(서버 이름 표시)는 클라이언트가 핸드셰이킹 프로세스를 시작할 때 연결을 시도하는 호스트 이름을 나타내는 TLS(전송 계층 보안) 컴퓨터 네트워킹 프로토콜의 확장입니다.[1] 이 확장 기능을 사용하면 서버가 동일한 IP 주소와 TCP 포트 번호에 가능한 여러 인증서 중 하나를 제공할 수 있으므로 모든 사이트가 동일한 인증서를 사용하지 않고도 동일한 IP 주소로 여러 보안(HTTPS) 웹사이트(또는 TLS를 통한 기타 서비스)를 서비스할 수 있게 해 줍니다. 이는 개념적으로는 HTTP/1.1 네임 기반 가상 호스팅과 동일하지만 HTTPS용입니다. 또한 프록시는 TLS/SSL 핸드셰이크 중에 클라이언트 트래픽을 올바른 서버로 전달할 수 있습니다. 원하는 호스트 이름은 원래 SNI 확장자에서 암호화되지 않으므로 도청자가 어떤 사이트가 요청되는지 알 수 있습니다. SNI 확장은 2003년에 RFC 3546에서 지정되었습니다.

## Background of the problem
SNI 이전에는 TLS 연결을 할 때 클라이언트가 연결하려는 사이트를 지정할 수 있는 방법이 없었습니다. 따라서 하나의 서버가 단일 수신기에서 여러 사이트를 호스팅하는 경우 서버는 TLS 프로토콜에서 어떤 인증서를 사용할지 알 방법이 없었습니다. 더 자세히 설명하자면, TLS 연결을 할 때 클라이언트는 웹 서버에 디지털 인증서를 요청합니다. 서버가 인증서를 보내면 클라이언트는 이를 검사하고 연결하려는 이름과 인증서에 포함된 이름을 비교합니다. 일치하는 이름이 있으면 정상적으로 연결이 진행됩니다. 일치하지 않으면 사용자에게 불일치에 대한 경고가 표시되고 불일치는 중간자 공격 시도를 나타낼 수 있으므로 연결이 중단될 수 있습니다. 그러나 일부 애플리케이션에서는 사용자가 경고를 우회하여 연결을 진행할 수 있도록 허용하며, 사용자는 인증서 및 더 나아가 연결을 신뢰하는 책임을 져야 합니다.

그러나 서버가 책임질 모든 이름을 포괄하는 단일 인증서를 얻는 것은 어렵거나 모든 이름의 전체 목록을 미리 확보하지 못하여 불가능할 수도 있습니다. 여러 호스트 이름을 담당하는 서버는 각 이름(또는 작은 이름 그룹)에 대해 다른 인증서를 제시해야 할 가능성이 높습니다. 한 사람[2]이 관리하는 여러 도메인을 단일 인증서에 포함하기 위해 subjectAltName을 사용할 수 있습니다. 이러한 '통합 커뮤니케이션 인증서'는 도메인 목록이 변경될 때마다 다시 발급해야 합니다.

이름 기반 가상 호스팅을 사용하면 동일한 IP 주소의 단일 서버(일반적으로 웹 서버)에서 여러 DNS 호스트 네임을 호스팅할 수 있습니다. 이를 위해 서버는 클라이언트가 프로토콜의 일부로 제공한 호스트 네임을 사용합니다(HTTP의 경우 호스트 헤더에 이름이 표시됨). 그러나 HTTPS를 사용하는 경우 서버가 HTTP 헤더를 보기 전에 TLS 핸드셰이크가 발생합니다. 따라서 서버는 HTTP 호스트 헤더의 정보를 사용하여 어떤 인증서를 제공할지 결정할 수 없었고 따라서 동일한 IP 주소에서 동일한 인증서가 적용되는 이름만 제공할 수 있었습니다.

실제로 이는 안전하고 효율적인 브라우징을 위해 HTTPS 서버가 IP 주소당 하나의 도메인(또는 소규모 도메인 그룹)만 제공할 수 있다는 것을 의미했습니다. 각 사이트에 대해 별도의 IP 주소를 할당하면 지역 인터넷 레지스트리에 IP 주소 요청을 정당화해야 하고 이제 IPv4 주소가 고갈되기 때문에 호스팅 비용이 증가합니다. IPv6의 경우 주소 공간이 고갈되지 않았음에도 불구하고 한 대의 컴퓨터에 여러 개의 IP를 보유하게 되어 관리 오버헤드가 증가합니다. 그 결과 많은 웹사이트가 보안 통신을 사용하는 데 사실상 제약을 받게 되었습니다.

## Technical principals
SNI는 클라이언트가 TLS 협상의 ClientHello 메시지의 일부로 가상 도메인의 이름을 보내도록 하여 이 문제를 해결합니다.[3] 이렇게 하면 서버가 올바른 가상 도메인을 조기에 선택하고 브라우저에 올바른 이름이 포함된 인증서를 제공할 수 있습니다. 따라서 SNI를 구현하는 클라이언트와 서버를 사용하면 단일 IP 주소를 가진 서버가 공통 인증서를 얻는 것이 비현실적인 도메인 이름 그룹에 서비스를 제공할 수 있습니다.

SNI는 2003년 6월에 RFC 3546, TLS(전송 계층 보안) 확장을 통해 IETF의 인터넷 RFC에 추가되었습니다. 이 표준의 최신 버전은 RFC 6066입니다.

## Security implications
서버 이름 표시 페이로드는 암호화되지 않으므로 클라이언트가 연결을 시도하는 서버의 호스트 이름이 수동 도청자에게 표시됩니다. 이 프로토콜의 취약점은 네트워크 필터링 및 모니터링용 보안 소프트웨어[4][5][6]와 검열을 위한 정부에 의해 악용되었습니다.[7] 현재 서버 이름 표시를 숨기려는 여러 기술이 시도되고 있습니다.

### Domain fronting
도메인 프런팅은 SNI에서 원하는 호스트 이름을 동일한 서버 또는 더 자주 콘텐츠 전송 네트워크라고 하는 서버 네트워크에서 호스팅하는 다른 이름으로 대체하는 기술입니다. 클라이언트가 도메인 프런팅을 사용하면 서버가 올바른 콘텐츠를 제공할 수 있도록 SNI의 서버 도메인은 암호화되지 않은 상태로 바꾸지만 HTTP 호스트 헤더(TLS로 암호화됨)에는 그대로 둡니다. 도메인 프런트닝은 SNI 자체를 정의하는 표준을 위반하므로 호환성이 제한됩니다(많은 서비스에서 SNI 호스트가 HTTP 헤더 호스트와 일치하는지 확인하고 도메인 프런트닝 SNI와의 연결을 유효하지 않은 것으로 거부합니다). 과거에는 도메인 프런팅이 정부의 검열을 피하기 위해 사용되었지만[8] 주요 클라우드 제공업체(Google, Amazon의 AWS, CloudFront)가 TOS에서 이를 명시적으로 금지하고 기술적 제한을 두고 있기 때문에[9] 그 인기가 줄어들었습니다.

### Encrypted Client Hello
암호화된 클라이언트 헬로(ECH)는 TLS 1.3 프로토콜 확장으로, TLS 1.3 협상 초기 단계에서 전송되는 전체 클라이언트 헬로 메시지를 암호화할 수 있습니다.[10] ECH는 신뢰 측(웹 브라우저)이 미리 알아야 하는 공개 키로 페이로드를 암호화하므로 브라우저 공급업체에 미리 알려진 대형 CDN에 가장 효과적입니다.

이 확장 기능의 초기 2018년 버전은 암호화된 SNI(ESNI)[11]라고 불렸으며, 도메인 도청의 위험을 해결하기 위해 "실험적" 방식으로 구현되었습니다.[12][13][14] Firefox 85에서는 ESNI 지원이 제거되었습니다.[15] ECH와 달리 암호화된 SNI는 전체 클라이언트 헬로가 아닌 SNI만 암호화했습니다.[16] 2018년 10월에 이 버전의 옵션 지원이 Firefox에 통합되었고[17] DoH(DNS over HTTPS) 활성화가 필요했습니다.[18].

2020년 3월, SNI만 암호화하는 것만으로는 충분하지 않다는 분석 결과에 따라 ESNI는 ECH 확장으로 재작업되었습니다. 예를 들어, 사양에 따르면 사전 공유 키 확장은 세션 재개를 용이하게 하는 모든 데이터를 포함할 수 있으며, 심지어 ESNI로 암호화된 서버 이름과 정확히 동일한 서버 이름의 일반 텍스트 사본을 전송하는 것도 허용합니다. 또한 확장 프로그램을 하나씩 암호화하려면 모든 확장 프로그램의 암호화된 변형이 필요하며, 각 확장 프로그램은 잠재적으로 개인정보 보호에 영향을 미칠 수 있으며, 이 경우에도 광고된 확장 프로그램 집합이 노출될 수 있습니다. 마지막으로, ESNI의 실제 배포는 상호 운용성의 한계를 드러냈습니다.[19] 2020년 3월에는 ECHO라는 약칭으로 사용되었고[16] 2020년 5월에는 ECH로 변경되었습니다[20].

ESNI와 ECH는 모두 TLS 1.3에서 처음 정의된 KeyShareEntry에 의존하기 때문에 TLS 1.3과만 호환됩니다.[21][22] 또한 ECH를 사용하려면 클라이언트는 1.3 이하의 TLS 버전을 제안해서는 안 됩니다.[23]

또 다른 인터넷 초안에서는 핸드셰이크 프로세스를 단축하기 위해 HTTPS 및 SVCB DNS 레코드 유형을 통해 ECH 공개 키를 전송하는 매개 변수를 통합했습니다.[24][25][26]

2020년 8월, 중국의 만리방화벽은 ESNI 트래픽을 차단하기 시작했지만 ECH 트래픽은 여전히 허용했습니다.[26][27]

2020년 10월, 러시아 ISP인 로스텔레콤과 이동통신사 텔레2는 ESNI 트래픽을 차단하기 시작했습니다.[27] 같은 해 9월, 러시아 검열 부처인 로스콤나드조르는 웹사이트 접속 검열을 방해하는 다양한 암호화 프로토콜을 금지할 계획이었는데, 그중에는 TLS 1.3과 ESNI가 포함되어 있었습니다.[28][29][30][31

2023년 7월, IETF117 회의에서 ECH를 연구하는 회원들은 크롬과 파이어폭스에서 1% 샘플 테스트를 진행하고 있으며, 최종 초안이 2024년 1월까지 IESG 평가에 제출될 것으로 예상합니다.[31][32][33]

2023년 9월, Cloudflare는 호스팅 도메인에 대해 ECH를 지원하기 시작했습니다.[33][34]

2023년 10월, Mozilla는 컴퓨터 네트워크에서 도청으로부터 HTTPS 리소스 레코드에 대한 DNS 요청을 보호하기 위해[34][35] DoH(DNS over HTTPS)도 활성화되어 있는 경우 Firefox v118에서 기본적으로 ECH를 활성화했습니다[36].

### Implementation
2004년에 에델키 프로젝트에서 OpenSSL에 TLS/SNI를 추가하는 패치를 만들었습니다.[37] 2006년에 이 패치는 OpenSSL의 개발 브랜치로 포팅되었고, 2007년에 OpenSSL 0.9.8(0.9.8f에서 처음 출시[38])로 다시 포팅되었습니다. SNI를 지원하는 최초의 웹 브라우저는 2006년에 등장했고(Mozilla Firefox 2.0, Internet Explorer 7), 이후 웹 서버(2009년에 Apache HTTP Server, 2012년에 Microsoft IIS)가 등장했습니다.

애플리케이션 프로그램이 SNI를 구현하려면 사용하는 TLS 라이브러리가 이를 구현해야 하며 애플리케이션은 호스트 이름을 TLS 라이브러리에 전달해야 합니다. 더 복잡한 문제는 TLS 라이브러리가 애플리케이션 프로그램에 포함되어 있거나 기본 운영 체제의 구성 요소일 수 있다는 것입니다. 이 때문에 일부 브라우저는 모든 운영 체제에서 실행할 때 SNI를 구현하는 반면 다른 브라우저는 특정 운영 체제에서만 실행할 때만 구현합니다.

