- https://en.wikipedia.org/wiki/Protection_ring

컴퓨터 과학에서 계층적 보호 도메인은[1][2 ] 보호 링이라고도 하며, 내결함성( 내결함성 향상)과 악의적인 동작( 컴퓨터 보안 제공)으로부터 데이터와 기능을 보호하는 메커니즘입니다.

컴퓨터 운영 체제는 리소스에 대한 다양한 수준의 액세스를 제공합니다. 보호 링은 컴퓨터 시스템 아키텍처 내에서 두 개 이상의 계층적 수준 또는 권한 계층 중 하나입니다. 이는 일반적으로 하드웨어 또는 마이크로코드 수준에서 다양한 CPU 모드를 제공하는 일부 CPU 아키텍처에 의해 하드웨어적으로 강화됩니다. 링은 가장 높은 권한(가장 신뢰할 수 있는, 보통 0번)에서 가장 낮은 권한(가장 신뢰할 수 없는, 보통 가장 높은 링 번호)까지 계층 구조로 배열되어 있습니다. 대부분의 운영 체제에서 링 0은 가장 많은 권한을 가진 레벨로, 특정 CPU 기능(예: 제어 레지스터) 및 I/O 컨트롤러와 같은 물리적 하드웨어와 가장 직접적으로 상호 작용합니다. 가상화의 보급이 증가함에 따라 많은 CPU에서 하이퍼바이저를 위한 또 다른 레벨(개념적으로 링 -1)을 추가했습니다.

외부 링이 임의의 사용을 허용하는 대신 미리 정의된 방식으로 내부 링의 리소스에 액세스할 수 있도록 하는 특수 메커니즘이 제공됩니다. 링 간의 액세스를 올바르게 게이팅하면 한 링 또는 권한 수준의 프로그램이 다른 링의 프로그램을 위한 리소스를 오용하지 못하도록 방지하여 보안을 강화할 수 있습니다. 예를 들어, 링 3에서 사용자 프로그램으로 실행되는 스파이웨어는 하드웨어 액세스가 디바이스 드라이버를 위해 예약된 링 1 기능이어야 하므로 사용자에게 알리지 않고 웹 카메라를 켜지 못하도록 해야 합니다. 높은 번호의 링에서 실행되는 웹 브라우저와 같은 프로그램은 낮은 번호의 링으로 제한된 리소스인 네트워크에 대한 액세스를 요청해야 합니다.

*링 0~3이 표시되어 있지만 기본적으로 주요 OS는 링 3, 사용자 공간과 링 0, 커널 모드 외에는 아무것도 사용하지 않습니다. 이는 사용자 공간 프로그램이 중요한 커널 기능에 액세스하지 못하도록 차단하여 커널을 보호하는 데 충분한 수준의 권한 분리를 제공합니다. 흔히 오해하는 것은 sudo 등을 사용하여 루트로 실행하면 링 0에서 실행된다는 것입니다. 사실이 아닙니다! 시스템 구성에 따라 '루트' 권한을 부여하는 UID 0이긴 하지만 여전히 사용자 공간 프로세스로서 링 3에 있는 것입니다. 커널 모드 드라이버를 제어하지 않고는 링 0으로 전환할 수 없습니다(이는 이 과정의 범위를 크게 벗어난 것이며 Linux를 필요로 하는 작업의 99.99%에 해당됨). : https://www.hoppersroppers.org/fundamentals/AdvancedLinux/3-LinuxPermissions.html

## 구현

다중 보호 링은 오늘날의 유닉스 운영 체제 제품군의 보안성이 뛰어난 전신인 Multics 운영 체제에서 도입한 가장 혁신적인 개념 중 하나였습니다. GE 645 메인프레임 컴퓨터에는 다른 GE-600 시리즈 컴퓨터와 동일한 두 가지 모드와 메모리 관리 장치("Appending Unit")의 세그먼트 수준 권한 등 일부 하드웨어 액세스 제어가 있었지만 하드웨어에서 링을 완벽하게 지원하기에는 충분하지 않았기 때문에 Multics는 소프트웨어에서 링 전환을 트래핑하여 링을 지원했습니다;[3] 후속 제품인 Honeywell 6180은 하드웨어로 구현하여 8개의 링을 지원했고,[4] Multics의 보호 링은 CPU 모드와 분리되어 링 0을 제외한 모든 링의 코드와 일부 링 0 코드는 슬레이브 모드에서 실행되었습니다.[5]

그러나 대부분의 범용 시스템은 실행되는 하드웨어가 그보다 더 많은 CPU 모드를 제공하더라도 두 개의 링만 사용합니다. 예를 들어 Windows 7 및 Windows Server 2008(및 이전 버전)은 링 0은 커널 모드에, 링 3은 사용자 모드에 해당하는 두 개의 링만 사용하는데,[6] 이는 이전 버전의 Windows NT가 두 가지 보호 수준만 지원하는 프로세서에서 실행되었기 때문입니다[7].

많은 최신 CPU 아키텍처(널리 사용되는 인텔 x86 아키텍처 포함)에는 링 보호 기능이 포함되어 있지만, 유닉스와 같은 Windows NT 운영 체제는 이 기능을 완전히 활용하지 않습니다. OS/2는 커널 코드 및 장치 드라이버에 링 0, 권한 있는 코드(I/O 액세스 권한이 있는 사용자 프로그램)에 링 2, 권한 없는 코드(거의 모든 사용자 프로그램)에 링 3의 세 가지 링을 사용하여 어느 정도 활용하고 있습니다. DOS에서는 커널, 드라이버 및 애플리케이션이 일반적으로 링 3에서 실행되는 반면(그러나 이는 보호 모드 드라이버 또는 DOS 확장기를 사용하는 경우에만 해당되며, 실제 모드 OS에서는 시스템이 사실상 보호되지 않은 상태로 실행됩니다), EMM386과 같은 386 메모리 관리자는 링 0에서 실행됩니다. 이 외에도 DR-DOS의 EMM386 3.xx는 선택적으로 일부 모듈( DPMS 등)을 링 1에서 대신 실행할 수 있습니다. OpenVMS는 (권한이 낮은 순서대로) 커널, 관리자, 수퍼바이저 및 사용자라는 네 가지 모드를 사용합니다.

이 설계 구조에 대한 새로운 관심은 Xen VMM 소프트웨어의 확산, 모놀리식 대 마이크로 커널에 대한 지속적인 논의 (특히 Usenet 뉴스 그룹 및 웹 포럼), NGSCB 이니셔티브의 일부인 Microsoft의 Ring-1 설계 구조, 인텔 VT-x (이전의 Vanderpool) 같은 x86 가상화 기반 하이퍼바이저로 인해 발생했습니다.

원래 멀티틱스 시스템에는 8개의 링이 있었지만, 최신 시스템에는 그보다 적은 수의 링이 있습니다. 하드웨어는 특수 머신 레지스터의 도움으로 실행 중인 명령어 스레드의 현재 링을 항상 인식하고 있습니다. 일부 시스템에서는 가상 메모리 영역에 하드웨어에서 링 번호가 대신 할당되기도 합니다. 한 가지 예로 프로그램 카운터(PC) 의 상위 3비트가 링 레지스터로 사용되는 Data General Eclipse MV/8000이 있습니다. 따라서 예를 들어 0xE200000으로 설정된 가상 PC에서 실행되는 코드는 자동으로 링 7에 속하게 되며, 다른 메모리 섹션에서 서브루틴을 호출하면 자동으로 링 전송이 발생합니다.

하드웨어는 한 링에서 다른 링으로 제어를 전달할 수 있는 방법을 엄격하게 제한하고 링 간에 수행할 수 있는 메모리 액세스 유형에 대한 제한도 시행합니다. x86을 예로 들면, 호출 명령어에서 참조하는 특수한[설명 필요] 게이트 구조가 있는데, 이 구조는 링 아키텍처를 사용하는 많은 운영 체제에서 수퍼바이저 호출로 작동하여 제어를 안전한 방식으로[설명 필요] 하위 수준(더 신뢰할 수 있는) 링의 사전 정의된 진입점으로 전송하는 역할을 합니다. 하드웨어 제한은 우발적이거나 악의적인 보안 침해의 기회를 제한하도록 설계되었습니다. 또한 가장 권한이 높은 링에는 가상 메모리 하드웨어를 우회하는 실제 메모리 주소 지정과 같은 특수 기능이 부여될 수 있습니다.

ARM 버전 7 아키텍처는 애플리케이션(PL0), 운영 체제(PL1), 하이퍼바이저(PL2)의 세 가지 권한 수준을 구현합니다. 특이하게도 레벨 0(PL0)은 가장 권한이 낮은 레벨이고 레벨 2는 가장 권한이 높은 레벨입니다.[9] ARM 버전 8은 AArch64[10]의 경우 애플리케이션(EL0), 운영 체제(EL1), 하이퍼바이저(EL2), 보안 모니터/펌웨어(EL3)의 네 가지 예외 레벨을 구현합니다:D1-2454 및 AArch32.[10]:G1-6013

링 보호는 일부 시스템에서 프로세서 모드 (마스터/커널/특권/감독자모드 대 슬레이브/비특권/사용자 모드)와 결합할 수 있습니다. 두 가지를 모두 지원하는 하드웨어에서 실행되는 운영 체제는 두 가지 보호 방식을 모두 사용하거나 한 가지 방식만 사용할 수 있습니다.

링 아키텍처를 효과적으로 사용하려면 하드웨어와 운영 체제 간의 긴밀한 협력이 필요합니다. 여러 하드웨어 플랫폼에서 작동하도록 설계된 운영 체제는 링이 지원되는 모든 플랫폼에 존재하지 않는 경우 링을 제한적으로만 사용할 수 있습니다. 하드웨어가 링을 통해 더 세분화된 보안을 제공하더라도 보안 모델은 '커널'과 '사용자'로 단순화되는 경우가 많습니다.

## 모드

### 감독자 모드
컴퓨터 용어로 슈퍼바이저 모드는 시스템 수준 소프트웨어에서 실행되는 코드에 의해 변경될 수 있는 하드웨어 매개 플래그입니다. 시스템 수준의 작업이나 스레드는 실행 중에도 이 플래그를 설정할 수 있지만 사용자 수준의 애플리케이션은 설정할 수 없습니다. 이 플래그는 다양한 디스크립터 테이블의 레지스터를 수정하거나 인터럽트를 비활성화하는 등의 작업을 수행하는 것과 같은 머신 코드 작업을 실행할 수 있는지 여부를 결정합니다. 두 가지 모드로 작동하는 아이디어는 "더 많은 권한에는 더 많은 책임이 따른다"는 개념에서 비롯된 것으로, 수퍼바이저 모드의 프로그램은 실패하면 전체 컴퓨터 시스템이 다운될 수 있으므로 절대 실패하지 않을 것으로 신뢰합니다.

수퍼바이저 모드는 "일부 프로세서의 실행 모드로, 특권 명령을 포함한 모든 명령을 실행할 수 있습니다. 또한 다른 주소 공간, 메모리 관리 하드웨어 및 기타 주변 장치에 대한 액세스 권한을 부여할 수도 있습니다. 운영 체제가 일반적으로 실행되는 모드입니다."[11]

모놀리식 커널에서는 운영 체제가 관리자 모드에서 실행되고 애플리케이션은 사용자 모드에서 실행됩니다. 엑소커널 또는 마이크로커널과 같은 다른 유형의 운영 체제는 이 동작을 반드시 공유하지는 않습니다.

PC 세계의 몇 가지 예입니다:

- Linux, macOS, Windows는 수퍼바이저/사용자 모드를 사용하는 세 가지 운영 체제입니다. 특수 기능을 수행하려면 사용자 모드 코드는 운영 체제의 신뢰할 수 있는 코드가 필요한 작업을 수행하고 실행을 다시 사용자 공간으로 반환하는 커널 공간 또는 수퍼바이저 모드로 시스템 호출을 수행해야 합니다. 로드 가능한 커널 모듈을 사용하여 커널 공간에 추가 코드를 추가할 수 있지만, 이 코드는 사용자 모드의 액세스 제어 및 안전 제한이 적용되지 않으므로 필요한 권한이 있는 사용자만 추가할 수 있습니다.
- DOS ( EMM386과 같은 386 메모리 관리자가 로드되지 않은 경우)는 물론 기타 간단한 운영 체제 및 많은 임베디드 장치는 영구적으로 감독자 모드에서 실행되므로 드라이버를 사용자 프로그램으로 직접 작성할 수 있습니다.

대부분의 프로세서에는 최소 두 가지 모드가 있습니다. x86 프로세서는 네 가지 링으로 나뉜 네 가지 모드가 있습니다. 링 0에서 실행되는 프로그램은 시스템에서 무엇이든 할 수 있으며, 링 3에서 실행되는 코드는 나머지 컴퓨터 시스템에 영향을 주지 않고 언제든 실패할 수 있어야 합니다. 링 1과 링 2는 거의 사용되지 않지만 다른 수준의 액세스 권한으로 구성할 수 있습니다.

대부분의 기존 시스템에서 사용자 모드에서 커널 모드로 전환하면 성능에 높은 비용이 발생합니다. 기본 요청 getpid를 기준으로 대부분의 시스템에서 1000~1500사이클의 비용이 발생하는 것으로 측정되었습니다. 이 중 약 100개만 실제 전환(사용자에서 커널 공간으로 70개, 다시 40개)을 위한 것이고 나머지는 "커널 오버헤드"입니다.[12][13] L3 마이크로커널에서는 이 오버헤드를 최소화하여 전체 비용을 약 150사이클로 줄였습니다.

모리스 윌크스는 다음과 같이 썼습니다:[14]

... 결국 링이 제공하는 계층적 보호가 시스템 프로그래머의 요구 사항과 거의 일치하지 않으며 두 가지 모드만 있는 단순한 시스템에서 거의 또는 전혀 개선되지 않는다는 것이 분명해졌습니다. 보호 링은 하드웨어에서 효율적으로 구현하는 데는 적합했지만 그 외에는 별다른 장점이 없었습니다. [...] 세분화된 보호의 매력은 보호 고리가 해답을 제공하지 못한다는 것이 밝혀진 후에도 여전히 남아 있었습니다.... 이것은 다시 맹목적인 골목으로 판명되었습니다 ...

성능과 결정성을 확보하기 위해 일부 시스템은 장치 드라이버가 아닌 애플리케이션 로직으로 볼 수 있는 기능을 커널 모드에 배치하며, 보안 애플리케이션(액세스 제어, 방화벽 등) 및 운영 체제 모니터가 그 예로 꼽힙니다. 커널 기반 애플리케이션 기능을 위한 로컬 데이터베이스를 제공하고 커널 기능이 사용자 모드에서 실행되는 데이터베이스 시스템과 상호작용할 때 발생할 수 있는 컨텍스트 전환을 제거하기 위해 커널 모드 배포를 위해 특별히 개발된 임베디드 데이터베이스 관리 시스템인 eXtremeDBKernel Mode가 하나 이상 있습니다[15].

함수가 링을 가로질러 다른 방향으로 이동하는 경우도 있습니다. 예를 들어 Linux 커널은 일반적으로 시스템 호출, 즉 링 전환이 필요한 함수가 포함된 vDSO 섹션을 프로세스에 주입합니다. 이러한 함수는 시스템 호출을 수행하는 대신 커널에서 제공하는 정적 데이터를 사용합니다. 이렇게 하면 링 전환이 필요하지 않으므로 시스템 호출보다 가볍습니다. gettimeofday 함수는 이러한 방식으로 제공될 수 있습니다.

### 하이퍼바이저 모드

인텔과 AMD의 최신 CPU는 하이퍼바이저가 링 0 하드웨어 액세스를 제어할 수 있는 x86 가상화 지침을 제공합니다. 상호 호환되지는 않지만, 인텔 VT-x (코드명 "밴더풀")와 AMD-V (코드명 "퍼시피카")는 모두 새로운 "링 -1"을 생성하여 게스트 운영 체제가 다른 게스트나 호스트 OS에 영향을 주지 않고 기본적으로 링 0 작업을 실행할 수 있도록 합니다.

가상화를 지원하기 위해 VT-x와 SVM은 링 0 아래에 새로운 권한 수준을 삽입합니다. 둘 다 하이퍼바이저에서 사용하기 위해 "링 -1"에서만 작동하는 9개의 새로운 머신 코드 명령어를 추가합니다.[16].

## 권한 수준

x86 명령어 집합의 권한 수준은 현재 프로세서에서 실행 중인 프로그램이 메모리 영역, I/O 포트 및 특수 명령어와 같은 리소스에 액세스할 수 있는 권한을 제어합니다. 권한 수준은 가장 높은 권한인 0부터 가장 낮은 권한인 3까지 4단계로 나뉩니다. 대부분의 최신 운영 체제는 커널/이렉티브에 레벨 0을 사용하고 애플리케이션 프로그램에는 레벨 3을 사용합니다. 레벨 n에서 사용할 수 있는 모든 리소스는 레벨 0~n에서도 사용할 수 있으므로 권한 수준은 링입니다. 권한이 낮은 프로세스가 권한이 높은 프로세스에 액세스하려고 하면 일반 보호 오류 예외가 OS에 보고됩니다.

네 가지 권한 수준을 모두 사용할 필요는 없습니다. 현재 시장 점유율이 높은 운영 체제인 Microsoft Windows, macOS, Linux, iOS 및 Android는 대부분 권한 수준을 관리자 또는 사용자(U/S 비트)로 지정하는 데 단 하나의 비트만 있는 페이징 메커니즘을 사용합니다. Windows NT는 2단계 시스템을 사용합니다.[17]8086의 실제 모드 프로그램은 레벨 0(최고 권한 수준)에서 실행되는 반면 8086의 가상 모드는 모든 프로그램을 레벨 3에서 실행합니다.[18]

x86 ISA 제품군에서 지원하는 여러 권한 수준의 향후 잠재적 용도로는 컨테이너화 및 가상 머신이 있습니다. 호스트 운영 체제 커널은 전체 권한 액세스 권한(커널 모드)을 가진 명령어를 사용할 수 있는 반면, 가상 머신 또는 컨테이너의 게스트 OS에서 실행되는 애플리케이션은 사용자 모드에서 가장 낮은 수준의 권한을 사용할 수 있습니다. 가상 머신과 게스트 OS 커널은 자체적으로 중간 수준의 명령어 권한을 사용하여 게스트 운영 체제의 관점에서 시스템 호출과 같은 커널 모드 작업을 호출하고 가상화할 수 있습니다[19].

### IOPL

IOPL(I/O 권한 수준) 플래그는 모든 IA-32 호환 x86 CPU에서 볼 수 있는 플래그입니다. FLAGS 레지스터에서 비트 12와 13을 차지합니다. 보호 모드와 긴 모드에서는 현재 프로그램 또는 작업의 I/O 권한 수준을 표시합니다. 작업 또는 프로그램이 I/O 포트에 액세스하려면 작업 또는 프로그램의 현재 권한 수준(CPL)(CPL0, CPL1, CPL2, CPL3)이 IOPL보다 낮거나 같아야 합니다.

현재 권한 수준이 링 0인 경우에만 POPF(D ) 및 IRET(D) 를 사용하여 IOPL을 변경할 수 있습니다.

IOPL 외에도 TSS의 I/O 포트 권한은 작업의 I/O 포트 액세스 기능을 결정하는 데도 관여합니다.

### 기타
x86 시스템에서 x86 하드웨어 가상화(VT-x 및 SVM)는 "링 -1", 시스템 관리 모드는 "링 -2", 인텔 관리 엔진 및 AMD 플랫폼 보안 프로세서는 "링 -3"이라고도 합니다[20].

## 하드웨어 기능 사용
많은 CPU 하드웨어 아키텍처는 일반적으로 실행되는 운영 체제에서 활용되는 것보다 훨씬 더 많은 유연성을 제공합니다. 복잡한 CPU 모드를 올바르게 사용하려면 운영 체제와 CPU 간에 매우 긴밀한 협력이 필요하므로 OS를 CPU 아키텍처에 묶어두는 경향이 있습니다. OS와 CPU가 서로를 위해 특별히 설계된 경우에는 문제가 되지 않지만(일부 하드웨어 기능은 여전히 활용되지 않을 수 있음), OS가 여러 다른 CPU 아키텍처와 호환되도록 설계된 경우에는 CPU 모드 기능의 상당 부분이 OS에 의해 무시될 수 있습니다. 예를 들어, Windows에서 두 가지 수준(링 0 및 링 3)만 사용하는 이유는 과거에 지원되었던 일부 하드웨어 아키텍처(예: PowerPC 또는 MIPS)가 두 가지 권한 수준만 구현했기 때문입니다.[6]

Multics는 특수한 CPU 아키텍처를 위해 특별히 설계된 운영 체제로서(Multics를 위해 특별히 설계된), 사용 가능한 CPU 모드를 최대한 활용했습니다. 하지만 이는 규칙의 예외였습니다. 오늘날 OS와 하드웨어 간의 높은 수준의 상호 운용은 보안과 안정성에 대한 잠재적 이점에도 불구하고 비용 효율적이지 않은 경우가 많습니다.

궁극적으로 CPU의 작동 모드를 구분하는 목적은 소프트웨어에 의한 시스템 환경의 우발적 또는 고의적 손상(및 그에 따른 시스템 보안 침해)으로부터 하드웨어를 보호하기 위한 것입니다. 시스템 소프트웨어의 "신뢰할 수 있는" 부분만 커널 모드의 제한 없는 환경에서 실행할 수 있으며, 패러다임적 설계에서는 꼭 필요한 경우에만 실행할 수 있습니다. 다른 모든 소프트웨어는 하나 이상의 사용자 모드에서 실행됩니다. 프로세서가 사용자 모드에서 오류 또는 예외 조건을 생성하는 경우 대부분의 경우 시스템 안정성은 영향을 받지 않지만, 프로세서가 커널 모드에서 오류 또는 예외 조건을 생성하는 경우 대부분의 운영 체제는 복구 불가능한 오류로 시스템을 중단합니다. 모드 계층 구조가 존재하는 경우(링 기반 보안), 한 권한 수준에서 결함 및 예외가 발생하면 더 높은 권한 수준만 불안정해질 수 있습니다. 따라서 링 0(가장 높은 권한을 가진 커널 모드)에서 오류가 발생하면 전체 시스템이 다운되지만 링 2의 오류는 링 3 이상과 링 2 자체에만 영향을 미칩니다.

높은 권한 수준에서 낮은 권한 수준(커널 모드에서 사용자 모드로 전환하는 경우)으로 전환하는 경우 모드 간 전환은 실행 중인 스레드의 재량이지만, 낮은 권한 수준에서 높은 권한 수준으로 전환하는 것은 특수 명령을 실행하거나 외부 인터럽트를 수신할 때 통과하는 안전한 하드웨어 제어 '게이트'를 통해서만 가능합니다.

마이크로커널 운영 체제는 보안과 우아함을 위해 권한 모드에서 실행되는 코드의 양을 최소화하려고 하지만 궁극적으로는 성능을 희생합니다.

