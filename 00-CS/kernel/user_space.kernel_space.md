- https://en.wikipedia.org/wiki/User_space_and_kernel_space
# 사용자 공간 및 커널 공간

최신 컴퓨터 운영 체제는 일반적으로 가상 메모리를 사용하여 사용자 공간과 커널 공간이라는 별도의 주소 공간을 제공합니다.[a] 이러한 분리는 주로 악의적이거나 잘못된 소프트웨어 동작으로부터 메모리를 보호 하고 하드웨어를 보호하는 역할을 합니다.

커널 공간은 권한이 있는 운영 체제 커널, 커널 확장 및 대부분의 장치 드라이버를 실행하기 위해 엄격하게 예약되어 있습니다. 반면 사용자 공간은 애플리케이션 소프트웨어와 일부 드라이버가 실행되는 메모리 영역으로, 일반적으로 프로세스당 하나의 주소 공간을 사용합니다.

## 개요
사용자 공간 (또는 사용자랜드)이라는 용어는 운영 체제의 커널 외부에서 실행되는 모든 코드를 의미합니다.[1] 사용자 공간은 일반적으로 운영 체제가 커널과 상호 작용하는 데 사용하는 다양한 프로그램 및 라이브러리 ( 입출력을 수행하고, 파일 시스템 개체를 조작하는 소프트웨어, 애플리케이션 소프트웨어 등)를 의미합니다.

각 사용자 공간 프로세스는 일반적으로 자체 가상 메모리 공간에서 실행되며, 명시적으로 허용되지 않는 한 다른 프로세스의 메모리에 액세스할 수 없습니다. 이는 오늘날의 주류 운영 체제에서 메모리 보호의 기초이며 권한 분리를 위한 기본 요소입니다. 별도의 사용자 모드를 사용하여 효율적인 가상 머신을 구축할 수도 있습니다( Popek 및 Goldberg 가상화 요구 사항 참조). 충분한 권한이 있는 프로세스는 디버거의 경우처럼 커널에 다른 프로세스의 메모리 공간 일부를 자신의 메모리 공간에 매핑하도록 요청할 수 있습니다. 프로그램은 다른 프로세스와 공유 메모리 영역을 요청할 수도 있지만, 프로세스 간 통신을 허용하는 다른 기술도 사용할 수 있습니다.

- 사용자 모드
    - 사용자 애플리케이션 : bash, LibreOffice, GIMP, Blender, 0 A.D., Mozilla Firefox, ...
    - 시스템 구성요소 : 
        - init daemon: OpenRC, runit, systemd...	
        - System daemons: polkitd, smbd, sshd, udevd...	
        - Window manager: X11, Wayland, SurfaceFlinger (Android)	
        - Graphics: Mesa, AMD Catalyst, ...	
        - Other libraries: GTK, Qt, EFL, SDL, SFML, FLTK, GNUstep, ...
    - C 표준 라이브러리 :
        - fopen, execv, malloc, memcpy, localtime, pthread_create... (up to 2000 subroutines)
            * glibc는 빠름을 목표로 하고, musl은 경량화를 목표로 하며, uClibc는 임베디드 시스템을 대상으로 하고, bionic은 안드로이드용으로 작성되었습니다. 모두 POSIX/SUS와 호환되는 것을 목표로 합니다.
- 커널 모드
    - Linux 커널
        - stat, splice, dup, read, open, ioctl, write, mmap, close, exit, etc. (about 380 system calls)
            * Linux 커널 시스템 호출 인터페이스 (SCI)는 POSIX/SUS 호환을 목표로 합니다[2].
        - 프로세스 스케줄링 하위 시스템	
        - IPC 하위 시스템	
        - 메모리 관리 하위 시스템	
        - 가상 파일 하위 시스템	
        - 네트워킹 하위 시스템
        - 기타 구성 요소: ALSA, DRI, evdev, klibc, LVM, 장치 매퍼, Linux 네트워크 스케줄러, 넷필터
        - Linux 보안 모듈: SELinux, TOMOYO, AppArmor, Smack

## 구현
커널 모드와 별도로 사용자 모드를 구현하는 가장 일반적인 방법은 운영 체제 보호 링을 사용하는 것입니다. 보호 링은 CPU 모드를 사용하여 구현됩니다. 일반적으로 커널 공간 프로그램은 감독자 모드라고도 하는 커널 모드에서 실행되고 사용자 공간의 일반 애플리케이션은 사용자 모드에서 실행됩니다.

대부분의 운영 체제는 단일 주소 공간 운영 체제로,모든 사용자 모드 코드를 위한 단일 주소 공간을 가지고 있습니다. (커널 모드 코드는 동일한 주소 공간에 있거나 두 번째 주소 공간에 있을 수 있습니다.) 다른 많은 운영 체제에는 모든 사용자 모드 프로세스에 대해 별도의 주소 공간인 프로세스별 주소 공간이 있습니다.

실험적인 운영 체제에서 취하는 또 다른 접근 방식은 모든 소프트웨어에 대해 단일 주소 공간을 사용하고 프로그래밍 언어의 의미론에 의존하여 임의의 메모리에 액세스할 수 없도록 하는 것입니다. 애플리케이션은 액세스 권한이 없는 객체에 대한 참조를 획득할 수 없습니다.[3][4] 이 방식은 JXOS, Unununium 및 Microsoft의 Singularity 연구 프로젝트에 구현되어 있습니다.

