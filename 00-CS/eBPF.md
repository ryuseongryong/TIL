# Hello eBPF! Goodbye Sidecars?

- 이 글은 Hello eBPF! Goodbye Sidecars?(https://www.youtube.com/watch?v=0JFd0W2CcMw)를 번역하면서 정리한 글입니다.

## 발표자
- Liz Rice(Chief Open Source Officer, Isovalent)
- Isovalent는 Cilium을 만든 회사
- Emeritus TOC Chair, CNCF
- Board Member, OpenUK

## Intro
- eBPF가 왜 그렇게 강력한 지
- Cilium은 CNCF에서 관리하는 프로젝트(incubating project), eBPF기반으로 동작함
- eBPF는 네트워킹, observability, 보안 인프라 도구를 위한 강력한 플랫폼인 이유
- 앞으로 사이드카 모델을 사용하지 않아도 되는 이유

## Body
### Sidecars
- 이전에 공통 인프라 도구(로그 및 추적, 보안 도구 등)를 구축하려면 응용 프로그램과 동일한 언어로 작성된 코드를 다시 작성하거나 가져와야 했음
- 하지만 컨테이너 환경으로 이동하면서 프로그래밍 언어와 동일한 언어를 사용할 필요가 없어졌음
- 대신 공통된 코드를 컨테이너에 넣고 모든 파드에서 동일한 컨테이너를 실행할 수 있게 됨
- 이 컨테이너를 사이드카 컨테이너라고 하고, 로깅, 추적, 보안 도구 및 서비스 매시에서 널리 사용됨

### eBPF
- Extended Berkely Packet Filter의 약어
- 실제로 패킷 필터링 이상의 기능을 수행하기 때문에 이 약어는 큰 의미가 없음
- eBPF를 사용하면 커널 동작 방식을 커스터마이징하여 커널을 동적으로 프로그래밍 할 수 있고, JS가 웹 페이지 동작을 동적으로 변경할 수 있는 것과 유사함
- 애플리케이션 개발자로서 우리는 사용자 공간에서 코드를 작성하고 사용자 공간 애플리케이션이 하드웨어에 닿는 모든 작업을 수행하려고 할 때마다 파일 읽기 쓰기, 메모리 할당, 네트워크 메시지 전송 등 이 모든 작업에 하드웨어 상호 작용이 필요하며 사용자 공간에서 이 작업을 수행할 수 없음
- 사용자 공간에 있는 애플리케이션은 이러한 모든 활동을 커널에 요청해야 함
- 프로그래밍 언어는 추상화를 제공하기에 일반적으로 이에 대해 생각하지 않기 때문에 커널이 호출되고 있다는 사실을 알지 못함.
- eBPF를 사용하면 이벤트에 의해 트리거되는 커널 내부에서 실행되는 프로그램을 작성할 수 있고 해당 이벤트는 트리거되는 모든 함수일 수 있고, 추적 지점일 수 있고, 네트워크일 수 있음
- 이벤트가 발생할 때마다 네트워킹 스택의 특정 지점에 도착하는 패킷 커스텀 eBPF 프로그램이 실행되고, 다양한 유형의 이벤트에 eBPF 프로그램을 연결하면 커널에서 일어나는 일을 관찰하고 보안 목적이나 쿠버네티스 네트워킹 툴링을 위해 해당 이벤트에 반응하는 데 사용할 수 있음
- 애플리케이션은 여전히 사용자 공간에서 실행되지만 파드 안의 컨테이너 안에 위치함
- 머신/가상머신 당 하나의 커널만 있으므로 호스트 당 하나의 커널이 있고, 그 커널은 애플리케이션 네트워크 메시지를 보내고 받거나 파일을 읽고 쓰는 것과 같은 흥미로운 작업을 수행하려는 경우, 이전과 마찬가지로 해당 호스트에서 실행되는 모든 컨테이너의 모든 프로세스에서 공유되므로 커널은 해당 호스트에서 일어나는 모든 일을 인식하고 관여할 수도 있음
- 호스트의 올바른 이벤트에 eBPF 프로그램을 연결하면 해당 호스트의 모든 파드에서 실행 중인 모든 애플리케이션을 인식하는 툴을 구축할 수 있음(모든 파드를 관리할 필요 없이 호스트만 관리하면 됨)
- 사이드카에서는 사이드카 컨테이너가 파드에서 일어나는 일을 인식하기 위해 동일한 네임스페이스 내에서 실행해야 하는 애플리케이션과 동일한 Linux 네임스페이스에서 실행되어야 하고, 이를 파드 내부로 가져가려면 일부 yaml 코드가 필요함
- 일반적으로 이 yaml은 admission controller나 CI/CD르 통해 자동으로 생성되지만, 뭔가 잘못되거나 구성이 잘못되면 yaml이 해당 파드에 주입되지 않고 해당 파드의 관리가 이루어지지 않으며, 해당 파드는 관측할 수 없게 됨
- 반면 eBPF는 앱 구성 변경이 필요가 없음. 커널에 eBPF 프로그램을 로드하고 있고, 이벤트에 eBPF 프로그램을 연결하자마자 파드가 이미 실행중인지 여부에 관계없이 이벤트가 트리거 될 것이기 때문(파드를 다시 시작할 필요가 없음)
- 또한 eBPF는 해당 노드의 모든 활동과 악의적인 활동, 예상 활동까지 인식하므로 툴링으로 악의적인 활동을 볼 수 있다.
- 노드에서 실행되는 프로세스 사이클 모델은 또한 리소스를 상당히 낭비할 수 있음. 모든 파드는 애플리케이션뿐만 아니라 사이드카 컨테이너에도 충분한 메모리와 CPU를 갖도록 구성해야 하고, 모든 파드 내부에 상태 및 구성 정보가 중복되는 사본이 있어야 함. 설게상 파드는 서로 격리되어 있으므로 공유 파일이나 네트워크 액세스, 네트워크 메시지를 통해서만 정보를 공유할 수 있음.
- eBPF 개념에서, 맵은 커널의 eBPF 프로그램과 사용자 공간, 툴링 에이전트 간에 데이터를 매우 효율적으로 공유하는 데이터 구조이므로 이미 많은 도구들이 있음.
- eBPF와 그것을 활용하는 도구들이 이미 많이 작성되어 있음. Pixie로 클러스터의 모든 노드에서 메트릭과 모든 종류의 다른 메트릭을 수집하고 이를 한데 모아 다양한 그래픽 방식으로 표시할 수 있음.
또 다른 통합 가시성 도구는 개별 패킷을 볼 수 있는, 네트워킹 정보에 대한 가시성을 제공하는 Cilium의 Hubble 구성 요소. 트래픽이 서로 다른 쿠버네티스 간에 어떻게 흐르는지 보여주는 서비스 맵 구축을 볼 수 있음.
애플리케이션 3, 4, 7계층 모두에서 메트릭 정보를 얻을 수 있음. Hubble은 Cilium 프로젝트의 일부이며 Cilium은 효율적인 네트워킹 연결을 제공하기 위해 eBPF도 사용함.
- eBPF가 네트워킹 스택의 이벤트에 프로그램을 첨부할 수 있고, 이를 사용하여 스택의 일부를 우회하여 쿠버네티스 네트워크 내에서 패킷을 훨씬 더 효율적으로 전달할 수 있으며, 연결성을 제공할 뿐만 아니라 (Cilium에서는) 보안성까지 제공함
- 투명한 암호화(TE)를 제공하여 커널의 노드 간 트래픽을 암호화할 수 있고, 네트워크 정책을 시행하기 위해 eBPF를 사용할 수 있음. 네트워크 정책에 어긋나는 네트워크 패킷을 삭제하고 (약 1년 전부터) Cilium에 몇 가지 기능을 추가하여 서비스 메시 역할을 할 수 있도록 함.
- 서비스 메시란 서비스 수준에서 앱 간 연결을 제공하는 것으로 기본 네트워크를 추상화하고, 가시성, 보안, 트래픽 관리와 같은 추가 기능을 제공함. 
- Cilium이 서비스 메시의 세계에 가져온 혁신은 사이드카 없이 서비스 메시를 구축하는 것. 모든 서비스 메시는 네트워크 프록시를 사용하여 애플리케이션 7계층에서 트래픽을 처리 가능.
- 다른 서비스 메시는 해당 프록시에 사이드카 모델을 사용했기 때문에 모든 애플리케이션 파드에 프록시가 주입되어 있음. Cilium의 서비스 메시 구현을 통해 사이드카 모델을 피하고 여러 파드에서 네트워크 프록시를 공유할 수 있으므로 서비스 혼란에 대한 Kelsey가 말한 것 처럼 모든 단일 파드에서 프록시를 구성하는 것과 관련된 복잡성과 리소스 사용을 피할 수 있음.
- 이것을 eBPF와 결합하면 훨씬 더 효율적인 네트워킹 경로를 제공함(네트워킹 경로가 짧아진다는 것은 사이드카 모델에서 네트워킹 지연 시간 감소를 뜻함, 모든 단일 네트워크 패킷은 해당 프록시를 통과하기 위해 네트워킹 스택을 여러 번 통과해야 하고, 두 개의 파드가 모두 프록시를 사용하는 경우 양쪽 끝에서 프록시를 통과해야 하기 때문에 네트워킹 경로가 매우 복잡해짐)
- 7계층의 트래픽이 관련되어 있기 때문에 프록시를 한 번만 통과하고 필요할 때문 프록시를 통과하는 두 개의 다른 파드 간의 직접 네트워킹 경로를 만들 수 있고, Cilium beta testers로부터 받은 피드백은 운영 복잡성을 피하고 지연 시간을 개선할 수 있는 이 기능이 정말 매력적이라는 것

