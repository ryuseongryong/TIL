# Hello eBPF! Goodbye Sidecars?

- 이 글은 Hello eBPF! Goodbye Sidecars?(https://www.youtube.com/watch?v=0JFd0W2CcMw)를 번역하면서 정리한 글입니다.

## 발표자
- Liz Rice(Chief Open Source Officer, Isovalent)
- Isovalent는 Cilium을 만든 회사
- Emeritus TOC Chair, CNCF
- Board Member, OpenUK

## Intro
- eBPF가 왜 그렇게 강력한 지
- Cilium은 CNCF에서 관리하는 프로젝트(incubating project), eBPF기반으로 동작함
- eBPF는 네트워킹, observability, 보안 인프라 도구를 위한 강력한 플랫폼인 이유
- 앞으로 사이드카 모델을 사용하지 않아도 되는 이유

## Body
### Sidecars
- 이전에 공통 인프라 도구(로그 및 추적, 보안 도구 등)를 구축하려면 응용 프로그램과 동일한 언어로 작성된 코드를 다시 작성하거나 가져와야 했음
- 하지만 컨테이너 환경으로 이동하면서 프로그래밍 언어와 동일한 언어를 사용할 필요가 없어졌음
- 대신 공통된 코드를 컨테이너에 넣고 모든 파드에서 동일한 컨테이너를 실행할 수 있게 됨
- 이 컨테이너를 사이드카 컨테이너라고 하고, 로깅, 추적, 보안 도구 및 서비스 매시에서 널리 사용됨

### eBPF
- Extended Berkely Packet Filter의 약어
- 실제로 패킷 필터링 이상의 기능을 수행하기 때문에 이 약어는 큰 의미가 없음
- eBPF를 사용하면 커널 동작 방식을 커스터마이징하여 커널을 동적으로 프로그래밍 할 수 있고, JS가 웹 페이지 동작을 동적으로 변경할 수 있는 것과 유사함
- 애플리케이션 개발자로서 우리는 사용자 공간에서 코드를 작성하고 사용자 공간 애플리케이션이 하드웨어에 닿는 모든 작업을 수행하려고 할 때마다 파일 읽기 쓰기, 메모리 할당, 네트워크 메시지 전송 등 이 모든 작업에 하드웨어 상호 작용이 필요하며 사용자 공간에서 이 작업을 수행할 수 없음
- 사용자 공간에 있는 애플리케이션은 이러한 모든 활동을 커널에 요청해야 함
- 프로그래밍 언어는 추상화를 제공하기에 일반적으로 이에 대해 생각하지 않기 때문에 커널이 호출되고 있다는 사실을 알지 못함.
- eBPF를 사용하면 이벤트에 의해 트리거되는 커널 내부에서 실행되는 프로그램을 작성할 수 있고 해당 이벤트는 트리거되는 모든 함수일 수 있고, 추적 지점일 수 있고, 네트워크일 수 있음
- 이벤트가 발생할 때마다 네트워킹 스택의 특정 지점에 도착하는 패킷 커스텀 eBPF 프로그램이 실행되고, 다양한 유형의 이벤트에 eBPF 프로그램을 연결하면 커널에서 일어나는 일을 관찰하고 보안 목적이나 쿠버네티스 네트워킹 툴링을 위해 해당 이벤트에 반응하는 데 사용할 수 있음
- 애플리케이션은 여전히 사용자 공간에서 실행되지만 파드 안의 컨테이너 안에 위치함
- 머신/가상머신 당 하나의 커널만 있으므로 호스트 당 하나의 커널이 있고, 그 커널은 애플리케이션 네트워크 메시지를 보내고 받거나 파일을 읽고 쓰는 것과 같은 흥미로운 작업을 수행하려는 경우, 이전과 마찬가지로 해당 호스트에서 실행되는 모든 컨테이너의 모든 프로세스에서 공유되므로 커널은 해당 호스트에서 일어나는 모든 일을 인식하고 관여할 수도 있음
- 호스트의 올바른 이벤트에 eBPF 프로그램을 연결하면 해당 호스트의 모든 파드에서 실행 중인 모든 애플리케이션을 인식하는 툴을 구축할 수 있음(모든 파드를 관리할 필요 없이 호스트만 관리하면 됨)
- 사이드카에서는 사이드카 컨테이너가 파드에서 일어나는 일을 인식하기 위해 동일한 네임스페이스 내에서 실행해야 하는 애플리케이션과 동일한 Linux 네임스페이스에서 실행되어야 하고, 이를 파드 내부로 가져가려면 일부 yaml 코드가 필요함
- 일반적으로 이 yaml은 admission controller나 CI/CD르 통해 자동으로 생성되지만, 뭔가 잘못되거나 구성이 잘못되면 yaml이 해당 파드에 주입되지 않고 해당 파드의 관리가 이루어지지 않으며, 해당 파드는 관측할 수 없게 됨
- 반면 eBPF는 앱 구성 변경이 필요가 없음. 커널에 eBPF 프로그램을 로드하고 있고, 이벤트에 eBPF 프로그램을 연결하자마자 파드가 이미 실행중인지 여부에 관계없이 이벤트가 트리거 될 것이기 때문(파드를 다시 시작할 필요가 없음)
- 또한 eBPF는 해당 노드의 모든 활동과 악의적인 활동, 예상 활동까지 인식하므로 툴링으로 악의적인 활동을 볼 수 있다.
- 노드에서 실행되는 프로세스 사이클 모델은 또한 리소스를 상당히 낭비할 수 있음. 모든 파드는 애플리케이션뿐만 아니라 사이드카 컨테이너에도 충분한 메모리와 CPU를 갖도록 구성해야 하고, 모든 파드 내부에 상태 및 구성 정보가 중복되는 사본이 있어야 함. 설게상 파드는 서로 격리되어 있으므로 공유 파일이나 네트워크 액세스, 네트워크 메시지를 통해서만 정보를 공유할 수 있음.
- eBPF 개념에서, 맵은 커널의 eBPF 프로그램과 사용자 공간, 툴링 에이전트 간에 데이터를 매우 효율적으로 공유하는 데이터 구조이므로 이미 많은 도구들이 있음.
- eBPF와 그것을 활용하는 도구들이 이미 많이 작성되어 있음. Pixie로 클러스터의 모든 노드에서 메트릭과 모든 종류의 다른 메트릭을 수집하고 이를 한데 모아 다양한 그래픽 방식으로 표시할 수 있음.
또 다른 통합 가시성 도구는 개별 패킷을 볼 수 있는, 네트워킹 정보에 대한 가시성을 제공하는 Cilium의 Hubble 구성 요소. 트래픽이 서로 다른 쿠버네티스 간에 어떻게 흐르는지 보여주는 서비스 맵 구축을 볼 수 있음.
애플리케이션 3, 4, 7계층 모두에서 메트릭 정보를 얻을 수 있음. Hubble은 Cilium 프로젝트의 일부이며 Cilium은 효율적인 네트워킹 연결을 제공하기 위해 eBPF도 사용함.
- eBPF가 네트워킹 스택의 이벤트에 프로그램을 첨부할 수 있고, 이를 사용하여 스택의 일부를 우회하여 쿠버네티스 네트워크 내에서 패킷을 훨씬 더 효율적으로 전달할 수 있으며, 연결성을 제공할 뿐만 아니라 (Cilium에서는) 보안성까지 제공함
- 투명한 암호화(TE)를 제공하여 커널의 노드 간 트래픽을 암호화할 수 있고, 네트워크 정책을 시행하기 위해 eBPF를 사용할 수 있음. 네트워크 정책에 어긋나는 네트워크 패킷을 삭제하고 (약 1년 전부터) Cilium에 몇 가지 기능을 추가하여 서비스 메시 역할을 할 수 있도록 함.
- 서비스 메시란 서비스 수준에서 앱 간 연결을 제공하는 것으로 기본 네트워크를 추상화하고, 가시성, 보안, 트래픽 관리와 같은 추가 기능을 제공함. 
- Cilium이 서비스 메시의 세계에 가져온 혁신은 사이드카 없이 서비스 메시를 구축하는 것. 모든 서비스 메시는 네트워크 프록시를 사용하여 애플리케이션 7계층에서 트래픽을 처리 가능.
- 다른 서비스 메시는 해당 프록시에 사이드카 모델을 사용했기 때문에 모든 애플리케이션 파드에 프록시가 주입되어 있음. Cilium의 서비스 메시 구현을 통해 사이드카 모델을 피하고 여러 파드에서 네트워크 프록시를 공유할 수 있으므로 서비스 혼란에 대한 Kelsey가 말한 것 처럼 모든 단일 파드에서 프록시를 구성하는 것과 관련된 복잡성과 리소스 사용을 피할 수 있음.
- 이것을 eBPF와 결합하면 훨씬 더 효율적인 네트워킹 경로를 제공함(네트워킹 경로가 짧아진다는 것은 사이드카 모델에서 네트워킹 지연 시간 감소를 뜻함, 모든 단일 네트워크 패킷은 해당 프록시를 통과하기 위해 네트워킹 스택을 여러 번 통과해야 하고, 두 개의 파드가 모두 프록시를 사용하는 경우 양쪽 끝에서 프록시를 통과해야 하기 때문에 네트워킹 경로가 매우 복잡해짐)
- 7계층의 트래픽이 관련되어 있기 때문에 프록시를 한 번만 통과하고 필요할 때문 프록시를 통과하는 두 개의 다른 파드 간의 직접 네트워킹 경로를 만들 수 있고, Cilium beta testers로부터 받은 피드백은 운영 복잡성을 피하고 지연 시간을 개선할 수 있는 이 기능이 정말 매력적이라는 것
- 사이드카 기반 프록시가 제공하는 기능에 비해 너무 높은 가격을 지불하면서 사용하는 많은 기업들이 있음
- 사이드카 없이 서비스 메시를 구현한 것은 Cilium이 처음이었으나, Istio도 앰비언트 메시 접근 방식으로 따라가고 있음.
- Cilium과 Istio가 접근하는 방식에는 약간의 차이가 있으나 둘 다 7계층의 복잡성을 처리하기 위해 Envoy 프록시를 사용한다는 점에서 사이드카를 제거함
- 사이드카는 항상 아쉬운 구현 세부 사항이었고, 메시 기능이 기본 인프라로 이동하는 것은 원래 Envoy 프록시를 작성한 매트 클라인의 아이디어이며, Cilium에서는 서비스 메시 기능의 상당 부분을 커널 자체로 옮겼고, 7계층의 복잡한 처리를 수행하도록 Envoy 프록시와 사용자 공간에 책임을 위임함
- 커널 내부에서 프로세싱하고 복잡한 부분을 사용자 공간에 위임하는 이 아이디어는 서비스 메시의 네트워킹에서 수행하기 전에 동작함. 비슷한 패턴은 커널이 NFQueue를 사용하여 사용자 공간으로 보낸 패킷을 기반으로 사용자 공간에서 보안 결정을 내리는 수리카타 보안 툴링에서 사용되거나 리눅스에서 하드웨어 장치를 연결하면 커널 모듈이 로드될 때 일반적으로 사용자 모드 헬퍼를 호출하여 해당 장치 구성의 복잡한 작업을 도와주는 커널이 호출함.
- 이제 서비스 메시에서 프록시를 파드 내부에 함께 배치하려는 이유가 여전히 있을 수 있음. Envoy 프록시에서 복잡한 사용자 정의 필터를 실행하려는 경우 해당 프록시를 다른 파드로부터 격리하고 싶을 수 있음. 따라서 사이드카 모델을 사용하여 계속 그렇게 하고, 실제로 프록시를 격리하는 방법에 대한 다양한 옵션을 제공하는 서비스 메시를 볼 수 있을 것임.
- 서비스 메시의 마지막 조각은 암호화. 애플리케이션 워크로드 간의 상호 인증은 많은 조직에서 매우 중요한 기능. Cilium에서 eBPF를 통해 이를 어떻게 처리하는지 살펴보자.
- 다른 노드 간에 투명한 암호화 트래픽이 커널에서 ipsec 또는 wireguard를 사용하여 암호화되도록 지원한다고 이미 말했음. 모든 트래픽이 암호화되고 관리가 매우 쉽기 때문에 많은 조직에서 유용하게 사용중.
- 또한 Cilium 네트워크 정책을 사용하여 서로 다른 서비스 간에 이동하는 트래픽이 허용되도록 할 수 있으나 이제 차세대 암호화를 개발중.
- 애플리케이션 워크로드 ID를 사용한 상호 암호화. 따라서 원하는 ID 관리 시스템을 사용할 수 있음. ID 관리와 각 개별 애플리케이션 워크로드를 나타내는 인증서를 관리할 수 있고, Cilium은 해당 인증서를 커널에 주입하고 트래픽 암호화를 위해 커널 수준 암호화를 사용할 것임.
- 그래서 서비스 메시의 가시성과 보안 툴링에서 많은 문제를 eBPF를 통해 해결했음, 그럼 사이드카는 이제 더이상 사용하지 않아도 되는 것인가? 사이드카도 여전히 사용될 것이라 확신함.
- 우선 eBPF 프로그램은 본질적으로 커널 프로그래밍이기 때문에 eBPF 프로그램을 작성하는 데는 꽤 높은 장벽이 있음. 사람들이 모든 인프라 툴링을 eBPF를 사용하여 즉시 작성하지는 않을 것임. 확실히 사이드카 모델은 많은 개발자가 실험하기 쉬울 것임.
- 사이드카를 사용하는 또 다른 이유는 기본 노드에 액세스 할 수 없는 경우. 많은 매니지드 쿠버네티스 환경에서 eBPF 기반 툴링을 사용하려면 클라우드 제공업체의 협력이 필요하지만, eBPF의 성능과 효율성은 우리가 해당 플랫폼에 구축된 훨씬 더 많은 인프라 툴이 구축되는 것을 의미한다.
- 그 이유 중 하나는 성능 개선을 요구하는 사용자들의 요구 때문일 것이고, 커널에서 매우 효율적으로 실행할 수 있고 동적으로 eBPF 프로그램을 로드할 수 있기 때문에 네트워크 지연 시간 감소와 같은 성능 개선이 입증된 것으로 보임
- 그래서 사이드카 모델은 여전히 그 자리를 지키고 있다고 생각됨. 일부 환경에서 계속 사용하는 것을 볼 수 있을 것임.
- 관찰 가능성과 보안을 위한 네트워킹을 위한 인프라 툴링의 미래에 eBPF가 큰 역할을 할 것이라고 생각됨.

