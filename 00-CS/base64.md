- https://ko.wikipedia.org/wiki/%EB%B2%A0%EC%9D%B4%EC%8A%A464
- https://en.wikipedia.org/wiki/Base64
# Base64 wiki korean
컴퓨터 분야에서 쓰이는 Base 64 (베이스 육십사)란 6비트 이진 데이터(예를 들어 실행 파일이나, ZIP 파일 등)를 문자 코드에 영향을 받지 않는 공통 ASCII 영역의 문자들로만 이루어진 일련의 문자열로 바꾸는 인코딩 방식을 가리키는 개념이다.

원래 Base 64를 글자 그대로 번역하여 보면 64진법이란 뜻이다. 특별히 64진법이 컴퓨터에서 흥미로운 것은, 64가 2의 제곱수(64 = 26)이며, 2의 제곱수들에 기반한 진법들 중에서 화면에 표시되는 ASCII 문자들을 써서 표현할 수 있는 가장 큰 진법이기 때문이다. 즉, 다음 제곱수인 128진법에는 128개의 기호가 필요한데 화면에 표시되는 ASCII 문자들은 128개가 되지 않는다.

그런 까닭에 이 인코딩은 전자 메일을 통한 이진 데이터 전송 등에 많이 쓰이고 있다. Base 64에는 어떤 문자와 기호를 쓰느냐에 따라 여러 변종이 있지만, 잘 알려진 것은 모두 처음 62개는 알파벳 A-Z, a-z와 0-9를 사용하고 있으며 마지막 두 개를 어떤 기호를 쓰느냐의 차이만 있다.

## MIME

MIME에서 정의하는 전자 메일 base64는 임의의 바이트 스트림을 화면에 표시할 수 있는 ASCII 문자들로 바꾸는 인코딩 방식을 말한다. 이 인코딩은 인터넷 전자 메일을 전송할 때 MIME의 content transfer encoding의 하나로 정의된다.

인코딩된 문자열은 알파벳 대소문자와 숫자, 그리고 "+", "/" 기호 64개로 이루어지며, "="는 끝을 알리는 코드로 쓰인다.

베이스64의 정확한 규격은 RFC 1421, RFC 2045에 정의된다. 연속된 8비트 바이트를 인코딩하도록 정의되어 있으며, 이는 대부분 시스템에서 파일의 정의와 들어맞는다. 베이스64 코딩을 거친 결과물은 원본보다 대략 4/3 정도 크기가 늘어나게 되며, 보통 의미없어 보이는 문자열이 나열된 형태가 된다.

데이터를 베이스64로 바꾸는 과정은 다음과 같다. 우선 24비트 버퍼에 위쪽(MSB)부터 한 바이트씩 세 바이트를 집어넣는다. 그리고 남은 바이트가 3바이트 미만이라면, 버퍼의 남은 부분은 0으로 채워넣게 된다. 그리고, 버퍼의 위쪽부터 6비트[1]씩 잘라 그 값을 읽어, 다음에 정렬된 64개 "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"의 문자 중에서 읽은 값 번째 문자를 골라 출력한다. 만약 입력된 바이트가 하나라면 출력 중 두 개만이 사용되고 나머지 둘은 "="으로 패딩되며, 입력된 바이트가 둘이라면 출력 중 세 개 만이 사용되고 나머지 하나는 "="으로 패딩되게 된다. 이것은 원본으로 되돌릴 때 원본에는 없던 비트가 생기는 것을 방지하기 위함이다. 이 과정을 입력 데이터가 끝날 때까지 반복하면 인코딩이 된다.

## UTF-7
RFC 2152에서 정의된 UTF-7은 Modified BASE64라 불리는 시스템을 의미한다. 이 data encoding scheme는 UTF-16을 SMTP와 같이 7비트를 사용하는 ASCII문자로 변환하는데 사용된다. 이는 MIME를 사용하는 BASE64 encoding의 변화된 방식이다. Modified BASE64 알파벳은 MIME BASE64 알파벳으로 구성되어 있으나, “ = ” 패딩 기호는 사용하지 않는다. UTF-7은 메일 헤더로 구성되어 사용되며[2], “ = ”기호는 quoted-printable encoding을 위한 이스케이프 문자로 사용된다. Modified BASE64는 간단하게 유용한 비트를 포함하고 있는 마지막 BASE64 숫자[3] 뒤에 바로 패딩과 끝을 생략한다.

## OpenPGP
RFC 4880에서 정의하고 있는 OpenPGP는 “ASCII Armor로 알려진 64진수 인코딩을 설명한다. 64진수는 MIME에서 정의하고 있는 BASE64 encoding과 동일하며, 추가적으로 24비트 CRC 체크섬을 포함하고 있다. 체크섬은 encoding 이전의 입력 데이터로 계산한다. 체크섬은 같은 BASE64 알고리즘으로 encoding되며, 추가적으로 “ = ” 기호를 구분자로 사용하여 인코딩된 출력 데이터에 추가된다.

## RFC3548
RFC 3548(BASE16, BASE32, BASE64 Data Encodings)은 BASE64 encodings에 관한 RFC 1421과 RFC 2045의 내용을 통일시키는 정보이며, 드물게 BASE32와 BASE16에 관한 내용도 사용하고 있다. 특별히 선언되어 있지 않는 한은, RFC 3548은 인코딩 알파벳 이외의 문자를 사용한 메시지 생성을 허용하지 않고 있으며, 디코더는 인코딩 알파벳 이외의 문자가 포함되어 있는 데이터를 거부해야 한다.

## RFC4648
이 RFC는 구 버전의 RFC 3548에 대하여 BASE64/32/16에 관한 내용이다.

이 문서는 일반적으로 사용되는 BASE64/32/16 encoding scheme에 대한 내용이다. 이는 또 인코딩 된 데이터의 line-feed, padding, 비(非) 알파벳 문자, 다른 방식으로 인코딩 된 알파벳 등의 사용과 규범적인 인코딩에 대한 내용을 다루고 있다.

---
# Base64 wiki english
컴퓨터 프로그래밍에서 Base64는 이진 데이터를 64개의 고유 문자 집합으로 제한된 인쇄 가능한 문자 시퀀스로 변환하는 이진-텍스트 인코딩 체계의 그룹입니다. 보다 구체적으로, 소스 바이너리 데이터를 한 번에 6비트씩 가져온 다음 이 6비트 그룹을 64개의 고유 문자 중 하나에 매핑합니다.

모든 바이너리-텍스트 인코딩 체계와 마찬가지로 Base64는 텍스트 콘텐츠만 안정적으로 지원하는 채널에서 바이너리 형식으로 저장된 데이터를 전달하도록 설계되었습니다. Base64는 특히 월드와이드웹에서 널리 사용되고 있으며[1], 그 용도 중 하나는 이미지 파일이나 기타 바이너리 자산을 HTML 및 CSS 파일과 같은 텍스트 자산 내에 삽입하는 기능입니다[2].

Base64는 이메일 첨부파일 전송에도 널리 사용되는데, 그 이유는 SMTP가 원래 7비트 ASCII 문자만 전송하도록 설계되었기 때문입니다. 첨부파일을 보내기 전에 Base64로 인코딩한 다음 수신 시 디코딩하면 구형 SMTP 서버가 첨부파일을 방해하지 않습니다.

Base64 인코딩은 원본 바이너리 데이터 크기에 비해 33~37%의 오버헤드가 발생합니다(인코딩 자체로 33%, 삽입된 줄 바꿈으로 최대 4% 추가).

## Design
베이스의 64자리 값을 나타내기 위해 선택되는 특정 64자 집합은 구현에 따라 다릅니다. 일반적인 전략은 대부분의 인코딩에 공통적이고 인쇄도 가능한 64자를 선택하는 것입니다. 이러한 조합은 이메일과 같이 전통적으로 8비트가 아닌 정보 시스템을 통해 전송되는 데이터의 수정 가능성을 낮춥니다.[3] 예를 들어, MIME의 Base64 구현은 처음 62개의 값에 A-Z, a-z, 0-9를 사용합니다. 다른 변형은 이 속성을 공유하지만 마지막 두 값에 선택되는 기호가 다릅니다(예: UTF-7).

이러한 유형의 인코딩의 초기 사례는 동일한 OS를 실행하는 시스템 간의 전화 접속 통신을 위해 만들어졌기 때문에(예: UNIX용 uuencode 및 TRS-80용 BinHex (나중에 Macintosh에 적용됨)) 어떤 문자를 사용해도 안전한지에 대해 더 많은 가정을 할 수 있었습니다. 예를 들어, uuencode는 대문자, 숫자 및 많은 구두점 문자를 사용하지만 소문자는 사용하지 않습니다.

## Examples

아래 예시에서는 단순화를 위해 ASCII 텍스트를 사용했지만, 이는 Base64를 처리할 수 있는 모든 시스템에서 이미 안전하게 전송할 수 있으므로 일반적인 사용 사례는 아닙니다. 보다 일반적인 용도는 이진 데이터 (예: 이미지)를 인코딩하는 것입니다. 결과 Base64 데이터에는 64개의 서로 다른 ASCII 문자만 포함되며, 모두 원시 소스 바이트가 손상될 수 있는 시스템 간에 안정적으로 전송될 수 있습니다.

따옴표(후행 공백 없이)를 Base64로 인코딩하면 다음과 같이 MIME의 Base64 체계로 인코딩된 8비트 추가 ASCII 문자의 바이트 시퀀스로 표시됩니다(개행과 공백은 어디에나 있을 수 있지만 디코딩 시 무시해야 함):

Man의 인코딩된 값은 TWFu입니다. ASCII로 인코딩된 문자 M, a, n은 바이트 값 77, 97, 110으로 저장되며, 이는 8비트 이진 값 01001101, 01100001, 01101110 입니다. 이 세 값을 24비트 문자열로 합치면 010011010110000101101110 이 됩니다. 6비트 그룹(6비트에는 최대26 = 64개의 서로 다른 이진 값이 있음)은 처음부터 끝까지 개별 숫자로 변환되고 (이 경우 24비트 문자열에는 4개의 숫자가 있음), 해당 Base64 문자 값으로 변환됩니다.

이 예시에서 알 수 있듯이 Base64 인코딩은 3옥텟을 4개의 인코딩된 문자로 변환합니다.

Man -> 77 + 97 + 110(ASCII) => 01001101 + 01100001 + 01101110(ASCII Binary) => 6bit cut -> 010011 + 010110 + 000101 + 101110(Base64 6bit group) -> 19 + 22 + 5 + 46 => TWFu(Base64 table) -> (ASCII) 84 + 87 + 70 + 117

`=` 패딩 문자를 추가하여 마지막 인코딩된 블록에 Base64 문자 4개를 포함하도록 할 수 있습니다.

16진수에서 8진수로 변환은 바이너리와 Base64 간에 변환할 때 유용합니다. 이러한 변환은 고급 계산기와 프로그래밍 언어 모두에서 사용할 수 있습니다. 예를 들어, 위 24비트의 16진수 표현은 4D616E입니다. 8진수 표현은 23260556 입니다. 이 8진수 8자리는23 26 05 56 쌍으로 나눌 수 있으며, 각 쌍을 10진수로 변환하면 19 22 05 46이 됩니다. 이 네 개의 십진수를 Base64 알파벳의 인덱스로 사용하면 해당 ASCII 문자는 TWFu가 됩니다.

유의미한 입력 옥텟이 두 개만 있거나(예: 'Ma') 마지막 입력 그룹에 두 개의 옥텟만 포함된 경우, 16비트 모두 처음 세 자리(18비트)의 Base64에서 캡처되고, 마지막 콘텐츠가 포함된 6비트 블록의 최하위 두 비트는 0으로 판명되어 디코딩 시 버려집니다(이어지는 = 패딩 문자와 함께):
Ma(16bit) -> 6bit + 6bit + 4bit + 2bit(00) + padding(=)

유의미한 입력 옥텟이 하나만 있거나(예: 'M') 마지막 입력 그룹에 옥텟이 하나만 포함된 경우, 8비트 모두 처음 두 자리(12비트)의 Base64에서 캡처되고, 마지막 콘텐츠가 포함된 6비트 블록의 최하위 비트 4개는 0으로 판명되어 디코딩 시 폐기됩니다(이어지는 2개의 = 패딩 문자들과 함께):
M(8bit) -> 6bit + 2bit + 4bit(0000) + padding(=) + padding(=)

### Output padding
Base64는 6비트 인코딩이고 디코딩된 값은 8비트 옥텟으로 나뉘기 때문에 Base64로 인코딩된 텍스트 4자(4섹셋 = 4 × 6 = 24비트)는 인코딩되지 않은 텍스트 또는 데이터 3옥텟(3옥텟 = 3 × 8 = 24비트)을 나타냅니다. 즉, 인코딩되지 않은 입력의 길이가 3의 배수가 아닌 경우 인코딩된 출력에 패딩을 추가하여 그 길이가 4의 배수가 되도록 해야 합니다. 패딩 문자는 =이며, 이는 입력을 완전히 인코딩하는 데 더 이상 비트가 필요하지 않음을 나타냅니다. (이는 나머지 비트가 모두 0임을 의미하는 A와는 다릅니다.) 아래 예시는 위 인용문의 입력을 잘라내면 출력 패딩이 어떻게 변경되는지 보여줍니다:


Text	Length	Text	Length Padding
light work.	11	bGlnaHQgd29yay4=	16	1
light work	10	bGlnaHQgd29yaw==	16	2
light wor	9	bGlnaHQgd29y	12	0
light wo	8	bGlnaHQgd28=	12	1
light w	7	bGlnaHQgdw==	12	2
패딩 문자는 인코딩된 텍스트의 길이를 통해 누락된 바이트 수를 유추할 수 있으므로 디코딩에 필수적인 것은 아닙니다. 일부 구현에서는 패딩 문자가 필수인 반면, 다른 구현에서는 패딩 문자가 사용되지 않습니다. 패딩 문자가 필요한 예외적인 경우는 여러 개의 Base64 인코딩 파일이 연결된 경우입니다.

