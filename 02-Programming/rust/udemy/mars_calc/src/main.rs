// main 함수는 항상 러스트 파일이 실행될 때 제일 먼저 실행되는 코드
use std::io;
fn main() {
        // 새로운 문자열을 생성함, 문자열은 변수 input이 소유하게 됨
        // input은 문자열 String의 소유자
        // 컴파일 시점에 문자열의 크기를 알지 못하기 때문에 힙에 저장된다.
        // 스택에는 힙을 가리키는 포인터를 저장하고, 문자열의 크기같은 메타데이터를 추가로 저장한다.(이것은 문자열에 대한 포인터)
        // 이 input이 범위를 벗어나면, 힙에 있는 문자열은 해제된다.(스마트 포인터와 유사한 것처럼 보임, 문자열은 스마트 포인터의 한 유형)
            // 소유자가 범위를 벗어나게 되면, 러스트 컴파일러는 drop 함수를 호출할 것이다.
            // 그리고 이 함수(main)가 종료되면, 문자열에 있는 drop 함수가 컴파일러에 의해 자동으로 호출될 것이다.
            // 러스트의 drop 함수는 다른 언어의 destructor(소멸자)와 아주 비슷하다.
            // 수명이 다했을 때 값을 해제하는 패턴은 RAII라고 불리는 것 또는 자원 획득 초기화(Resource Acquisition Is Initialization)이다.
            // RAII(in C++)
        // 변수가 소유권을 갖고, 소유자가 범위를 벗어나면 해제된다는 것은 명료하다.
        // 반면 특정 시점에 값의 소유자는 단 하나뿐이라는 것은 문제가 있을 수 있다.
    let mut input = String::new();

            // input 값을 가변으로 차용하게 되면, 뒤이어 불변으로 차용하는 것이 불가능하기 때문에 에러가 발생한다.
            // 불변으로 차용하는 변수 s2를 생성하기 전에 이미 변수 s1의 입력을 가변으로 차용했기 때문에
            // 컴파일러는 가변 차용과 불변 차용이 동시에 일어나는 것을 허용하지 않는다.
            // 가변 차용을 하면, 다른 차용은 할 수 없다. 하지만 변수 s2를 s1과 마찬가지로 가변으로 변환하면 이제 두 개의 가변 변수를 갖게 되는데,
            // 이것도 불가능하다.
            // 단일 가변 차용만 가능하거나 원하는 만큼의 불변 차용만 가능하기 때문이다.
            // 변수 변화는 이런 제한들을 통해 매우 제한되는 방식으로만 가능하다.
            // 대부분의 언어에서는 데이터를 원하는 대로 변형할 수 있기 때문에 러스트를 처음 접하는 사람들은 이런 개념 때문에 힘들어한다.
            // 하지만 아주 큰 장점이 있다.
            // 이런 제한은 컴파일 시점에 데이터 레이스를 방지하는 장점을 갖는다. 이것은 아주 큰 장점이다.
            // 데이터 레이스는 프로그래밍 디버깅에 있어서 가장 어려운 부분들 중 하나이기 때문이다.
            // 다른 언어에서 동시 실행 코드를 작성할 때는 항상 데이터 레이스에 대해 생각하고 방지할 수 있는 방법을 생각해야 한다.
            // 하지만 러스트에서는 만약 컴파일이 되면 코드에서 데이터 레이스가 일어날 일이 없다는 것을 정적으로 보장하는 강력한 힘을 제공한다.
            // 이것이 바로 러스트의 놀라운 특징 중 하나이다.
            // 컴파일러가 얼마나 영리한 지 보자면
            // 두 개의 불변 변수로 사용된 다음 아래 함수에서 가변 변수로 사용되는 경우가 있다.
            // 컴파일러는 불변 참조를 허용하고 println!에서 참조를 사용한다.
            // 컴파일러가 허용하는 이유는 (불변) 변수를 출력하는 이 지점 다음에 이 (불변 변수에 대한) 참조를 다시 사용하지 않는다는 것을 파악했기 때문이다.
            // 그래서 출력한 다음에 입력 값이 변경될 것이라는 것을 아고 있어서 불변 변수 뒤의 가변 변수 사용을 허용한 것이다.
            // println!의 위치를 가변 변수 뒤로 이동하면 컴파일에 실패한다.
                // let s1 = &input;
                // let s2 = &input;
                // println!("{} {}", s1, s2);
                // some_fn(&mut input);

        // 새로운 변수 s를 생성
        // s는 input을 가리키고, input은 문자열을 가리킴
        // 따라서 두 개의 메모리 주소를 갖는데, 이것들은 힙에 있는 같은 문자열을 가리킴
        // 소유자가 범위를 벗어나면 값은 해제된다고 하면, 문자열에 두 개의 소유자를 갖게 됨
        // 두 소유자가 모두 범위를 벗어날 때, 문자열을 해제할 것이다.
        // 이것을 이중해제라고 하고, 메모리 손상을 일으킬 수 있다. C에서는 흔한 버그이고, 아주 심각한 보안 취약점이 될 수 있다.
        // 그래서 러스트에서는 하나의 소유자만 가지게 강제하고, 이중 해제 오류에 대한 가능성이 제거된다.
        // 이 경우에 동작 방식은 다음과 같다.
            // 문자열에 대한 소유권이 변수 s로 이동된다.(문자열에 새로운 소유자를 할당하면, 변수 input은 유효하지 않게 된다.)
            // 컴파일러는 이 시점 이후에 변수 input을 사용하지 못하게 한다.(build error가 발생함)
            // input을 read_line함수에 전달하면, 실제로는 값을 차용하게 된다.
            // 값이 이동된 다음 그 값을 차용하려고 하는데 컴파일러는 값이 어디로 이동했는지 정확히 우리에게 알려준다.
            // 우리가 새로운 소유자를 할당했을 때, 값은 변수 s로 이동한다고도 알려준다.
            // 문자열인 input이 복사될 수 없기 때문에 이동이 발생했다고 얘기하고 있다.
            // 이동은 되지만 복사는 안된다. 힙에 저장된 복합 유형이기 때문이다.
                // 그럼 복사될 수 있는 유형은 무엇일까?
                // let a = 5; 와 같이 컴파일 시점에 크기를 알 수 있고, 스택에 저장/힙에는 할당되지 않는 경우.
                // let b = a; 변수는 b가 a의 값을 새로운 위치로 복사해 오기 때문에 두 개의 포인터가 있는 것이 아닌, 두 개의 값이 있는 것이 된다.
                // 즉 힙에 저장되는 문자열 같은 복합 유형과 힙에 저장되지 않는 숫자 같은 단순 유형의 차이이다.(reference type vs primitive type)
            // 함수도 동일하다.
                // 동일하게 새로운 변수에 문자열을 할당하는 대신 input을 할당하여 input값을 차용하게 되면 에러가 발생한다.
                // 값이 이동한 다음에 차용하려고 했기 때문에, 함수를 호출했을 때는 값이 이미 이동했다고 말한다.
                // 그것은 이 함수를 호출했을 때, 이 문자열의 소유권이 이 함수 안에 있는 변수 s로 이동했다는 것을 뜻한다.
                // 그리고 함수의 마지막에 s가 범위를 벗어날 때 문자열은 해제된다. 그래서 이 문자열을 사용한다면 포인터는 더 이상 유효하지 않을 것이다.
                // 문자열은 메모리 주소에 있지 않고, 그 안에 무엇이 있는지 알지 못하는 것과 같다.
                // 그러면 메모리는 손상되고 프로그램은 동작하지 않을 것이다.
                // 그래서 러스트 컴파일러는 이런 오류가 발생하는 것을 막기 위해 단일 소유자 규칙을 강제 적용한다.
                // 그것은 매개 변수를 함수에 전달하고 이 함수 반환 이후에도 계속 사용할 수 있도록 한다는 뜻이다.
                // 대부분의 언어에서는 변수를 함수에 전달해서 함수에서 사용하고, 함수가 반환된 이후에도 계속 사용하기 때문에 
                // 큰 문제가 되는 것처럼 보일 수 있지만, 그것을 위해 러스트에서는 차용이라는 기능을 제공한다.
    // 정확히 이 줄에서 무엇이 발생하였는지 아는 것이 중요함
    // 특히 &mut가 무슨 뜻인지를 아는 것이 중요함
    // 이 부분은 소유권과 관련이 있음(다른 대부분의 언어에는 없는 개념)
    // 러스트에는 3가지 소유권 규칙이 있다.
    // 1. 러스트에서 각각의 값은 변수가 소유한다는 것(모든 것에는 소유자가 있음)
    // 2. 소유자가 범위를 벗어나면 그 값은 해제된다는 것
    // 3. 특정 시점에 값의 소유자는 단 하나뿐이라는 것

        // read_line 함수는 문자열에 대해 가변 변수를 기대한다.
        // 그래서 문자열을 불변으로 차용할 것이다.
        // 콘솔에서 입력되는 값으로 채워질 것이고, 그 문자열로부터 소유권을 얻으면 계속 사용할 수 있을 것이다. 
        // 그 문자열 출력을 테스트해 볼 수 있는데, input값을 출력하여 여기에 입력되는 문자열을 전달한다.
        // 즉 read_line 함수는 문자열을 불변 차용하지만, 콘솔 입력으로 값을 변경해서 사용할 수 있다.
    io::stdin().read_line(&mut input);
    println!("Input: {}", input);
    let mut mars_weight = calculate_weight_on_mars(100.0);
    // 변수를 재지정하면 
    // cannot assign twice to immutable variable 에러가 발생함
    // 러스트 변수는 기본적으로 불변 변수라는 것을 알 수 있다.
    // 가변 변수로 만들려면 명시적으로 선언해줘야한다.
    mars_weight = mars_weight * 1000.0;
    // println! 는 매크로, !가 붙어있으면 매크로라는 의미
    // cargo expand로 확인 가능
    println!("Weight on Mars: {}g", mars_weight);
}

// 러스트 코드는 함수와 변수명을 작성할 때 스네이크 케이스를 사용함
// 함수의 마지막 표현식에서 끝에 세미콜론을 넣지 않는다. 반환 값 앞에 키워드 return을 사용하지 않아도 반환됨
// 함수에서 조기 반화을 윌해서 return 키워드를 사용할 수 있다.
// 대부분의 경우에는 return 키워드와 세미콜론이 제외된 반환값을 사용한다.

fn calculate_weight_on_mars(weight: f32) -> f32 {
    (weight / 9.81) * 3.711
}

// 참조/소유권
// 러스트에는 소유권 이전 없이 함수에 변수를 전달하는 방법으로 참조라는 기능이 있다.
// Reference(참조)는 소유권 없이도 값을 참조할 수 있게 해준다.
// some_fn 함수의 시그니처를 문자열의 소유권을 가지는 대신 문자열을 참조할 수 있도록 변경할 수 있다.
// ampersand(&)를 변수 앞에 추가하면 된다.
// 변수 s가 범위를 벗어나도 문자열은 제거되지 않게 된다. 변수 s가 문자열의 소유자가 아니기 때문이다.
// 함수는 문자열을 차용만 한다.
// 그래서 러스트에서는 매개변수로 참조를 전달하는 것을 차용이라고 한다.
// 함수를 호출할 때 명시적으로 참조를 전달해야 한다.
// 문자열 참조를 기대한 곳에 전체 문자열을 전달하게 되면, 문제가 발생한다.
// 그래서 참조를 전달할 때도 ampersand기호를 사용하여 참조임을 명시해야한다.
// 일반적인 변수처럼 참조는 기본적으로 변경 불가능하다.
// 그래서 문자열에 어떤 값을 추가하려고 하면, 컴파일러가 경고한다.
// 가변 변수로 사용하려면 &mut로 명시한다. 또한 변수를 차용할 때도 동일하게 명시해줘야한다.

// 참조에는 아주 중요한 규칙이 있다.
// 동일한 범위 안에서는 원하는 만큼의 불변 참조 또는 단일 가변 참졸르 가질 수 있다.
// 그래서 원하는 만큼의 불변 참조나 단일 가변 참조를 만들 수 있다.
    // fn some_fn(s: &mut String) {
    //     s.push_str("a");
    // }


// 러스트에도 표준 라이브러리가 있음
// 유용한 추상적 개념들의 집합을 뜻하는 것으로, 해시맵, 벡터, 데이터 구조 등과
// 가장 중요한 입출력 기본 요소가 있다.
// 표준 라이브러리는 외부 크레이트이다. 러스트에서 패키지를 가리키는 말이다.
// 이 크레이트는 기본적으로 모든 러스트 프로젝트에서 사용 가능하다.
// https://doc.rust-lang.org/stable/std 여기서 목록들을 찾을 수 있다.
// https://doc.rust-lang.org/stable/std/io/index.html I/O 관련 내용
