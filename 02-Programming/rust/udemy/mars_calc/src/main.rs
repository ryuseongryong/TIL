// main 함수는 항상 러스트 파일이 실행될 때 제일 먼저 실행되는 코드
use std::io;
fn main() {
        // 새로운 문자열을 생성함, 문자열은 변수 input이 소유하게 됨
        // input은 문자열 String의 소유자
        // 컴파일 시점에 문자열의 크기를 알지 못하기 때문에 힙에 저장된다.
        // 스택에는 힙을 가리키는 포인터를 저장하고, 문자열의 크기같은 메타데이터를 추가로 저장한다.(이것은 문자열에 대한 포인터)
        // 이 input이 범위를 벗어나면, 힙에 있는 문자열은 해제된다.(스마트 포인터와 유사한 것처럼 보임, 문자열은 스마트 포인터의 한 유형)
            // 소유자가 범위를 벗어나게 되면, 러스트 컴파일러는 drop 함수를 호출할 것이다.
            // 그리고 이 함수(main)가 종료되면, 문자열에 있는 drop 함수가 컴파일러에 의해 자동으로 호출될 것이다.
            // 러스트의 drop 함수는 다른 언어의 destructor(소멸자)와 아주 비슷하다.
            // 수명이 다했을 때 값을 해제하는 패턴은 RAII라고 불리는 것 또는 자원 획득 초기화(Resource Acquisition Is Initialization)이다.
            // RAII(in C++)
        // 변수가 소유권을 갖고, 소유자가 범위를 벗어나면 해제된다는 것은 명료하다.
        // 반면 특정 시점에 값의 소유자는 단 하나뿐이라는 것은 문제가 있을 수 있다.
    let mut input = String::new();
        // 새로운 변수 s를 생성
        // s는 input을 가리키고, input은 문자열을 가리킴
        // 따라서 두 개의 메모리 주소를 갖는데, 이것들은 힙에 있는 같은 문자열을 가리킴
        // 소유자가 범위를 벗어나면 값은 해제된다고 하면, 문자열에 두 개의 소유자를 갖게 됨
        // 두 소유자가 모두 범위를 벗어날 때, 문자열을 해제할 것이다.
        // 이것을 이중해제라고 하고, 메모리 손상을 일으킬 수 있다. C에서는 흔한 버그이고, 아주 심각한 보안 취약점이 될 수 있다.
        // 그래서 러스트에서는 하나의 소유자만 가지게 강제하고, 이중 해제 오류에 대한 가능성이 제거된다.
        // 이 경우에 동작 방식은 다음과 같다.
            // 문자열에 대한 소유권이 변수 s로 이동된다.(문자열에 새로운 소유자를 할당하면, 변수 input은 유효하지 않게 된다.)
            // 컴파일러는 이 시점 이후에 변수 input을 사용하지 못하게 한다.(build error가 발생함)
            // input을 read_line함수에 전달하면, 실제로는 값을 차용하게 된다.
            // 값이 이동된 다음 그 값을 차용하려고 하는데 컴파일러는 값이 어디로 이동했는지 정확히 우리에게 알려준다.
            // 우리가 새로운 소유자를 할당했을 때, 값은 변수 s로 이동한다고도 알려준다.
            // 문자열인 input이 복사될 수 없기 때문에 이동이 발생했다고 얘기하고 있다.
            // 이동은 되지만 복사는 안된다. 힙에 저장된 복합 유형이기 때문이다.
                // 그럼 복사될 수 있는 유형은 무엇일까?
                // let a = 5; 와 같이 컴파일 시점에 크기를 알 수 있고, 스택에 저장/힙에는 할당되지 않는 경우.
                // let b = a; 변수는 b가 a의 값을 새로운 위치로 복사해 오기 때문에 두 개의 포인터가 있는 것이 아닌, 두 개의 값이 있는 것이 된다.
                // 즉 힙에 저장되는 문자열 같은 복합 유형과 힙에 저장되지 않는 숫자 같은 단순 유형의 차이이다.(reference type vs primitive type)
            // 함수도 동일하다.
                // 동일하게 새로운 변수에 문자열을 할당하는 대신 input을 할당하여 input값을 차용하게 되면 에러가 발생한다.
                // 값이 이동한 다음에 차용하려고 했기 때문에, 함수를 호출했을 때는 값이 이미 이동했다고 말한다.
                // 그것은 이 함수를 호출했을 때, 이 문자열의 소유권이 이 함수 안에 있는 변수 s로 이동했다는 것을 뜻한다.
                // 그리고 함수의 마지막에 s가 범위를 벗어날 때 문자열은 해제된다. 그래서 이 문자열을 사용한다면 포인터는 더 이상 유효하지 않을 것이다.
                // 문자열은 메모리 주소에 있지 않고, 그 안에 무엇이 있는지 알지 못하는 것과 같다.
                // 그러면 메모리는 손상되고 프로그램은 동작하지 않을 것이다.
                // 그래서 러스트 컴파일러는 이런 오류가 발생하는 것을 막기 위해 단일 소유자 규칙을 강제 적용한다.
                // 그것은 매개 변수를 함수에 전달하고 이 함수 반환 이후에도 계속 사용할 수 있도록 한다는 뜻이다.
                // 대부분의 언어에서는 변수를 함수에 전달해서 함수에서 사용하고, 함수가 반환된 이후에도 계속 사용하기 때문에 
                // 큰 문제가 되는 것처럼 보일 수 있지만, 그것을 위해 러스트에서는 차용이라는 기능을 제공한다.
    // 정확히 이 줄에서 무엇이 발생하였는지 아는 것이 중요함
    // 특히 &mut가 무슨 뜻인지를 아는 것이 중요함
    // 이 부분은 소유권과 관련이 있음(다른 대부분의 언어에는 없는 개념)
    // 러스트에는 3가지 소유권 규칙이 있다.
    // 1. 러스트에서 각각의 값은 변수가 소유한다는 것(모든 것에는 소유자가 있음)
    // 2. 소유자가 범위를 벗어나면 그 값은 해제된다는 것
    // 3. 특정 시점에 값의 소유자는 단 하나뿐이라는 것
    io::stdin().read_line(&mut input);
    let mut mars_weight = calculate_weight_on_mars(100.0);
    // 변수를 재지정하면 
    // cannot assign twice to immutable variable 에러가 발생함
    // 러스트 변수는 기본적으로 불변 변수라는 것을 알 수 있다.
    // 가변 변수로 만들려면 명시적으로 선언해줘야한다.
    mars_weight = mars_weight * 1000.0;
    // println! 는 매크로, !가 붙어있으면 매크로라는 의미
    // cargo expand로 확인 가능
    println!("Weight on Mars: {}g", mars_weight);
}

// 러스트 코드는 함수와 변수명을 작성할 때 스네이크 케이스를 사용함
// 함수의 마지막 표현식에서 끝에 세미콜론을 넣지 않는다. 반환 값 앞에 키워드 return을 사용하지 않아도 반환됨
// 함수에서 조기 반화을 윌해서 return 키워드를 사용할 수 있다.
// 대부분의 경우에는 return 키워드와 세미콜론이 제외된 반환값을 사용한다.

fn calculate_weight_on_mars(weight: f32) -> f32 {
    (weight / 9.81) * 3.711
}


// 러스트에도 표준 라이브러리가 있음
// 유용한 추상적 개념들의 집합을 뜻하는 것으로, 해시맵, 벡터, 데이터 구조 등과
// 가장 중요한 입출력 기본 요소가 있다.
// 표준 라이브러리는 외부 크레이트이다. 러스트에서 패키지를 가리키는 말이다.
// 이 크레이트는 기본적으로 모든 러스트 프로젝트에서 사용 가능하다.
// https://doc.rust-lang.org/stable/std 여기서 목록들을 찾을 수 있다.
// https://doc.rust-lang.org/stable/std/io/index.html I/O 관련 내용
