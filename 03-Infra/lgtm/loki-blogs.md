- https://medium.com/@krishnarajanarunachalam/loki-efficient-log-aggregation-and-centralized-log-management-29d678851fc6#:~:text=The%20compactor%20in%20Loki%20is,the%20Loki%20Ingester%20and%20querier.

# Loki: Efficient Log Aggregation and Centralized Log Management

- https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oL1RVMu0DkskSKL6aCpxhg.png

클라우드 네이티브 애플리케이션과 분산형 애플리케이션이 증가하면서 애플리케이션 환경의 복잡성은 새로운 차원에 도달했습니다. 프로덕션 환경과 하위 환경에서 애플리케이션 문제를 효과적으로 해결하려면 중앙 집중식 로그 관리 솔루션이 필수적입니다. 이러한 강력한 오픈 소스 솔루션 중 하나가 Grafana Labs에서 개발한 Loki입니다. 이 블로그 게시물에서는 Loki의 기능과 이점을 살펴보고 실제 사용 사례 시나리오를 살펴봄으로써 그 사용법을 이해해 보겠습니다.

로키란 무엇인가요?

Loki는 Grafana Labs의 로그 집계 도구입니다. 로그 데이터를 효율적으로 보관하도록 설계된 데이터 저장소입니다. 다른 로깅 솔루션과 달리, Loki는 로그 메시지 자체가 아닌 레이블을 사용해 로그 데이터를 색인합니다. 따라서 더 효율적이고 확장성이 뛰어납니다. Loki는 고유한 레이블 세트가 있는 로그 집합인 스트림을 색인합니다. Loki가 사용하는 쿼리 언어를 LogQL이라고 합니다.

로키의 구성 요소는 무엇인가요?

- https://miro.medium.com/v2/resize:fit:1100/format:webp/1*lCCU0Yvh9pzpcvQhdUS-1w.png

1. Distributor
배포자는 클라이언트가 전송한 로그 스트림을 관리할 책임이 있습니다. 배포자는 여러 스트림을 수신하고 유효성을 검사하여 지정된 테넌트 제한을 준수하는지 확인합니다. 유효한 청크는 배치로 나뉘어 동시에 수집기로 전송됩니다.

배포자는 상태 비저장형으로 설계되었으며 필요에 따라 확장 또는 축소할 수 있습니다. 들어오는 요청을 효과적으로 분산하려면 로드 밸런서가 필요합니다. 배포자의 이러한 확장성 기능은 DDoS 공격이 발생하더라도 Loki의 다른 구성 요소를 보호하는 데 도움이 됩니다.

로그 처리의 일환으로, Loki는 먼저 로그 스트림이 합의된 사양을 준수하는지 여부를 확인합니다. 그런 다음 레이블을 표준화하여 들어오는 로그 데이터를 전처리하여 Loki가 효율적으로 캐시하고 해싱할 수 있도록 합니다. 또한 배포자는 테넌트당 허용되는 비트레이트에 따라 들어오는 로그에 대해 전송률 제한을 적용할 수 있습니다.

로그가 처리되면, 배포자는 이를 수집기 구성 요소로 전달합니다. 데이터 손실 위험을 최소화하기 위해, 배포자는 일반적으로 기본적으로 3으로 설정되는 수집기의 복제 계수를 기반으로 로그 쓰기를 배포합니다. 이 로그 쓰기 분배는 일관된 해싱 기법을 따릅니다.

2. Ingester
IngeSter 서비스의 역할은 AWS DynamoDB, AWS S3, Cassandra 등과 같은 다양한 영구 스토리지 백엔드에 로그 데이터를 쓰는 작업을 처리하는 것입니다. 쓰기 경로를 관리하여 로그 데이터가 안전하게 저장되도록 합니다. 또한, Ingester 서비스는 읽기 경로에서 인메모리 쿼리에 대한 로그 데이터를 제공합니다.

Inger 서비스 내에는 해시 링에 있는 각 Inger의 수명 주기를 관리하는 라이프사이클러라는 구성 요소가 있습니다. 이 라이프사이클러는 수집기의 시작 및 중지, 해시 링 구조 내에서의 배치 관리와 같은 작업을 처리합니다.

3. Querier
쿼리어 서비스는 LogQL 쿼리 언어를 사용하여 쿼리를 처리하는 역할을 담당합니다. 이 서비스는 수집기와 장기 저장소 모두에서 로그를 검색합니다. 쿼리가 수신되면, 쿼리기는 먼저 모든 수집기에서 인메모리 데이터를 검색합니다. 원하는 로그를 메모리에서 찾을 수 없는 경우, 백엔드 저장소에 대해 동일한 쿼리가 실행됩니다.

복제 요소로 인해 쿼리어에 중복 데이터가 수신될 가능성이 있습니다. 이를 처리하기 위해 쿼리기는 내부적으로 나노초 단위의 타임스탬프, 레이블 세트, 로그 메시지를 비교하여 중복 항목을 제거합니다. 이 중복 제거 프로세스는 쿼리 결과에서 고유한 로그만 반환되도록 합니다.

4. Query Frontend
쿼리 프런트엔드는 쿼리자에게 API 엔드포인트를 제공하는 서비스로, 읽기 경로의 성능을 향상시키는 데 사용할 수 있습니다. 이 서비스는 들어오는 쿼리를 처리하고, 내부적으로 특정 조정을 수행하며, 쿼리 대기열을 관리합니다. 쿼리 프런트엔드는 상태 비저장형으로 설계되었으며, 일반적으로 안정성과 확장성을 높이기 위해 인스턴스 두 개를 사용하는 것이 좋습니다.

5. Caching
쿼리 프론트엔드는 메트릭 쿼리의 결과를 캐싱하여 후속 쿼리에서 재사용할 수 있도록 지원합니다. 결과 캐시는 멤캐시드, Redis, 인메모리 캐시를 비롯한 다양한 Loki 캐싱 백엔드와 호환됩니다. 이 캐싱 메커니즘은 캐시된 결과를 검색하고 제공함으로써 기본 스토리지에서 동일한 데이터를 반복적으로 가져올 필요성을 줄여 쿼리 성능을 향상시킵니다.

6. Consul
Consul은 서비스 ID와 기존 네트워킹 관행을 사용하여 조직이 모든 환경에서 실행 중인 애플리케이션 또는 애플리케이션의 구성 요소를 안전하게 연결할 수 있도록 지원합니다. Consul에 저장된 해시 링은 일관된 해싱을 달성하는 데 사용되며, 모든 수집기는 자신이 소유한 토큰 세트로 해시 링에 자신을 등록합니다.

7. Compactor
Loki의 컴팩터는 인덱스 항목을 중복 제거하고 여러 인덱스 파일을 단일 파일로 병합하여 Loki 인덱스의 크기를 줄이는 구성 요소입니다. 이를 통해 쿼리 성능을 개선하고 스토리지 비용을 절감할 수 있습니다. 컴팩터는 로키 인제스터 및 쿼리기와 함께 실행되는 별도의 프로세스입니다. Loki 구성 파일에서 구성되며, 정기적인 일정에 따라 또는 필요에 따라 실행할 수 있습니다.

8. Object Store
개체 저장소는 Loki에서 로그 데이터의 영구 저장소 백엔드 역할을 합니다. Amazon S3나 Google Cloud Storage와 같은 원격 객체 스토리지 서비스나 로컬 디스크 기반 스토리지일 수 있습니다. 객체 저장소는 인제스터에서 생성된 압축된 로그 청크를 저장하며, 이를 쿼리기가 효율적으로 쿼리하고 검색할 수 있습니다.

9. Ruler
Loki의 룰러 구성 요소는 알림 규칙을 실행하고 Loki가 수집한 로그 데이터를 기반으로 알림을 생성하는 역할을 담당합니다. 사용자는 로그 스트림에 대해 일치시킬 조건이나 패턴을 지정하는 규칙을 정의하고 구성할 수 있습니다. 규칙이 트리거되면 룰러 컴포넌트가 경보를 생성하여 다양한 경보 플랫폼이나 알림 채널로 전송할 수 있습니다.

What is Chunk in Loki context?
Loki의 청크는 로그 항목의 시퀀스를 포함하는 저장 단위입니다. 청크는 Loki의 기본 저장 단위이며, Loki가 수집하는 로그 데이터를 저장하는 데 사용됩니다. 청크는 Loki 스토리지 백엔드에 저장됩니다. 스토리지 백엔드는 Amazon S3, Google Cloud Storage, 로컬 파일 시스템 등 다양한 스토리지 시스템이 될 수 있습니다.

How are data flows handled in Loki?

Write Path

1. Log Ingestion: 애플리케이션 또는 에이전트의 로그 항목이 Loki 배포자로 전송됩니다.
2. Distributor: Loki 배포기는 로그 항목을 수신한 후 로드 밸런싱 기술을 사용하여 사용 가능한 IngeSter 인스턴스 간에 로그 항목을 배포합니다. 이를 통해 로그 항목이 Inger 인스턴스 전체에 고르게 분산됩니다.
3. Ingester: 각 Inger 인스턴스는 Loki 배포자로부터 로그 항목을 받습니다. 이 인스턴스는 로그 항목을 스토리지 계층에 지속시켜 수집 프로세스를 처리합니다. 인제스터는 로그 스트림 검색, 레이블 추출, 청킹, 압축된 청크를 구성된 Object Store에 저장하는 등의 작업을 수행합니다.
4. Object Store: 객체 저장소는 Loki에서 로그 데이터를 위한 영구 저장소 백엔드 역할을 합니다. 인제스터는 압축된 로그 청크를 원격 객체 스토리지 서비스(예: Amazon S3, Google Cloud Storage) 또는 로컬 디스크 기반 스토리지가 될 수 있는 객체 저장소에 씁니다.

Read Path

1. 쿼리 요청: 사용자가 로키 쿼리 프런트엔드에 쿼리 요청을 제출합니다.
2. 쿼리 프런트엔드: 쿼리 프론트엔드는 사용자 쿼리의 진입점 역할을 합니다. 쿼리 프론트엔드는 쿼리 요청을 수신하고 인증 및 권한 부여를 처리합니다. 그런 다음 처리를 위해 쿼리를 쿼리어 인스턴스로 전달합니다.
3. 쿼리어: 쿼리어 인스턴스는 쿼리 프런트엔드에서 쿼리를 받습니다. 이 쿼리는 여러 쿼리어 인스턴스에 분산된 인덱스인 로키 인덱스와 상호 작용합니다. 쿼리어는 인덱스를 검사하여 쿼리와 관련된 로그 청크를 결정합니다.
4. 로키 인덱스: 로키 인덱스는 특정 쿼리에 대한 관련 데이터가 포함된 로그 청크를 찾는 역할을 합니다. 로그 항목과 관련된 레이블을 기반으로 로그 청크를 식별하는 데 도움이 됩니다. 로키 인덱스는 쿼리어 인스턴스 전체에 분산되어 있으며 효율적인 쿼리 기능을 제공합니다.
5. 개체 저장소 검색: 쿼리어는 Object Store와 통신하여 쿼리와 일치하는 로그 청크를 가져옵니다. 쿼리어는 로키 인덱스에서 얻은 정보를 기반으로 오브젝트 스토어에서 압축된 로그 청크를 검색합니다.
6. 결과 집계: 쿼리어는 Object Store에서 받은 결과를 집계하여 서로 다른 청크의 로그 데이터를 일관된 응답으로 결합합니다.
7. 쿼리 응답: 쿼리어는 집계된 쿼리 결과를 쿼리 프론트엔드로 다시 전송하고, 쿼리 프론트엔드는 결과를 포맷하여 사용자의 쿼리에 대한 응답으로 보냅니다.

What are the clients of Loki?

Loki는 로그 전송을 위한 다양한 클라이언트를 지원하며, 그 클라이언트는 Promtail, Docker Driver, Fluentd, Fluent Bit, Logstash, Lambda Promtail입니다. 사용 사례의 성격에 따라 클라이언트를 결정하세요.

프롬테일: Promtail은 Kubernetes를 실행할 때 선택하는 클라이언트로, Promtail이 실행되는 동일한 노드에서 실행되는 파드의 로그를 자동으로 스크랩하도록 구성할 수 있습니다.
Docker 드라이버는 Docker가 Kubernetes 기반이 아닌 환경에서 실행되는 경우 Docker 전용으로 사용할 수 있습니다.
Logstash, Fluent Bit, Fluentd는 대상 환경에 이미 배포된 경우 사용할 수 있습니다.

How Loki Uses Labels?
레이블은 키 값 쌍으로, 무엇이든 정의할 수 있습니다! Loki는 이를 로그 스트림을 설명하는 메타데이터로 사용합니다. 레이블에는 밑줄과 콜론뿐만 아니라 ASCII 문자와 숫자도 포함될 수 있습니다. 레이블은 정규식 [a-zA-Z_:][a-zA-Z0-9_:]*와 일치해야 합니다.

Example:

In this example:

1. 스크랩_컨피그 섹션은 단일 항목이 포함된 YAML 목록입니다.
2. 목록 안에는 sonarqube_logs라는 이름으로 작업이 정의되어 있습니다.
3. pipeline_stages 섹션은 작업 정의 아래에 들여쓰기되어 있으며 단계 목록을 포함합니다.
4. 이 경우, 일치 선택기로 정의된 단일 스테이지입니다.
5. 일치 선택기는 작업 레이블이 "sonarqube"와 같은 로그를 선택합니다.
6. static_configs 섹션은 작업 정의 아래에 들여쓰기되어 있으며 정적 대상의 목록을 포함합니다.
7. 이 예에서는 localhost로 정의된 단일 대상입니다.
8. 레이블 섹션은 대상 정의 아래에 들여쓰기되어 있으며 대상과 관련된 레이블을 포함합니다.
9. 작업 레이블은 "sonarqube"로 설정되어 있으며, __path__ 레이블에 SonarQube 로그 파일(/var/sonarqube/logs/sonarqube.log)의 경로를 정의합니다.
10. 이 구성은 하나의 파일을 추적하고 하나의 레이블을 할당합니다: job=sonarqube, {job="sonarqube"}와 같이 쿼리할 수 있습니다.

What are Loki Deployment modes?

Monolith Mode

이 모드에서 Loki는 단일 바이너리로 배포되고 단일 프로세스로 실행됩니다. 배포자, 수집기, 쿼리어, 쿼리 프런트엔드 등 모든 Loki 구성 요소는 동일한 Loki 인스턴스의 일부입니다. 이 모드는 소규모 배포나 테스트 및 개발 목적에 적합합니다.

Microservices Mode

마이크로서비스 모드에서 Loki 구성 요소는 별도의 서비스로 배포되어 확장성과 분리가 가능합니다. 배포자, 수집기, 쿼리어, 쿼리 프론트엔드 등 각 구성 요소는 독립적인 서비스로 배포되며 워크로드에 따라 개별적으로 확장할 수 있습니다. 이 모드는 대규모 배포에 적합하며 더 나은 리소스 활용도와 유연성을 제공합니다.

Where Loki can be used?

사용 사례: IT 운영팀은 여러 서버, 컨테이너, 네트워킹 장치로 구성된 복잡한 인프라를 관리합니다. 문제를 해결하고 시스템 안정성을 유지하기 위해 중앙 집중식 로그 관리 솔루션이 필요합니다.

How Loki can be used in this scenario?

이 팀은 IT 환경에 Loki를 배포하고 모든 인프라 구성 요소에서 로그를 수집하도록 구성합니다. 서버, 컨테이너화된 애플리케이션, 네트워크 장치에서 로그를 캡처합니다. Loki의 강력한 쿼리 기능을 통해 SRE 또는 인프라 전문가는 서버 이름, 오류 메시지 또는 네트워크 이벤트와 같은 특정 기준에 따라 로그를 검색하고 필터링할 수 있습니다. 이를 통해 신속하게 문제를 해결하고, 장애의 근본 원인을 파악하고, 적시에 문제를 해결할 수 있습니다. 또한 Loki의 중앙 집중식 로그 스토리지는 기록 분석 및 추세 감지를 지원하여 팀이 잠재적인 문제를 사전에 해결하고 인프라를 원활하게 운영할 수 있도록 도와줍니다.

Conclusion

Grafana Labs의 효율적인 로그 집계 도구인 Loki는 로그 데이터 저장 및 관리에 혁신을 불러일으킵니다. 레이블과 인덱스를 사용하는 독특한 방식으로 기존 로깅 솔루션과 차별화됩니다. 다양한 에이전트와 클라이언트 간 호환성을 갖춘 Loki는 다양한 사용 사례와 환경에 유연성을 제공합니다. 모놀리식 또는 마이크로서비스 모드로 배포할 수 있는 Loki는 애플리케이션 개발팀, IT 운영팀, DevOps팀에 중앙 집중식 로그 관리 기능을 제공합니다. 신속한 문제 해결, 근본 원인 파악, 시기적절한 문제 해결을 통해 시스템 안정성을 확보할 수 있습니다. Loki의 중앙 집중식 로그 스토리지는 기록 분석과 추세 감지를 용이하게 하여 조직이 선제적으로 문제를 해결할 수 있도록 지원합니다.