- https://grafana.com/docs/loki/latest/get-started/architecture/
- https://medium.com/@dudwls96/logging-grafana-loki-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B5%AC%EC%84%B1-6c1f0d83a5f3

# Loki architecture

## 멀티 테넌시
메모리와 장기 스토리지의 모든 데이터는 Grafana Loki가 멀티테넌트 모드로 실행 중일 때 요청의 X-Scope-OrgID HTTP 헤더에서 가져온 테넌트 ID로 분할될 수 있습니다. Loki가 멀티 테넌트 모드가 아닌 경우, 헤더는 무시되고 테넌트 ID는 "가짜"로 설정되어 인덱스와 저장된 청크에 나타납니다.

## Chunk Format
```
  ----------------------------------------------------------------------------
  |                        |                       |                         |
  |     MagicNumber(4b)    |     version(1b)       |      encoding (1b)      |
  |                        |                       |                         |
  ----------------------------------------------------------------------------
  |                      #structuredMetadata (uvarint)                       |
  ----------------------------------------------------------------------------
  |      len(label-1) (uvarint)      |          label-1 (bytes)              |
  ----------------------------------------------------------------------------
  |      len(label-2) (uvarint)      |          label-2 (bytes)              |
  ----------------------------------------------------------------------------
  |      len(label-n) (uvarint)      |          label-n (bytes)              |
  ----------------------------------------------------------------------------
  |                      checksum(from #structuredMetadata)                  |
  ----------------------------------------------------------------------------
  |           block-1 bytes          |           checksum (4b)               |
  ----------------------------------------------------------------------------
  |           block-2 bytes          |           checksum (4b)               |
  ----------------------------------------------------------------------------
  |           block-n bytes          |           checksum (4b)               |
  ----------------------------------------------------------------------------
  |                           #blocks (uvarint)                              |
  ----------------------------------------------------------------------------
  | #entries(uvarint) | mint, maxt (varint)  | offset, len (uvarint)         |
  ----------------------------------------------------------------------------
  | #entries(uvarint) | mint, maxt (varint)  | offset, len (uvarint)         |
  ----------------------------------------------------------------------------
  | #entries(uvarint) | mint, maxt (varint)  | offset, len (uvarint)         |
  ----------------------------------------------------------------------------
  | #entries(uvarint) | mint, maxt (varint)  | offset, len (uvarint)         |
  ----------------------------------------------------------------------------
  |                          checksum(from #blocks)                          |
  ----------------------------------------------------------------------------
  | #structuredMetadata len (uvarint) | #structuredMetadata offset (uvarint) |
  ----------------------------------------------------------------------------
  |     #blocks len (uvarint)         |       #blocks offset (uvarint)      |
  ----------------------------------------------------------------------------
```
mint와 maxt는 각각 최소 및 최대 유닉스 나노초 타임스탬프를 설명합니다.

구조화된 메타데이터 섹션은 반복되지 않는 문자열을 저장합니다. 구조화된 메타데이터의 라벨 이름과 라벨 값을 저장하는 데 사용됩니다. 구조화된 메타데이터 섹션 내의 라벨 문자열과 길이는 압축되어 저장된다는 점에 유의하세요.

### Block Format
블록은 일련의 항목으로 구성되며, 각 항목은 개별 로그 행입니다.

블록의 바이트는 압축되어 저장됩니다. 압축이 해제되었을 때의 형식은 다음과 같습니다:

```
-----------------------------------------------------------------------------------------------------------------------------------------------
|  ts (varint)  |  len (uvarint)  |  log-1 bytes  |  len(from #symbols)  |  #symbols (uvarint)  |  symbol-1 (uvarint)  | symbol-n*2 (uvarint) |
-----------------------------------------------------------------------------------------------------------------------------------------------
|  ts (varint)  |  len (uvarint)  |  log-2 bytes  |  len(from #symbols)  |  #symbols (uvarint)  |  symbol-1 (uvarint)  | symbol-n*2 (uvarint) |
-----------------------------------------------------------------------------------------------------------------------------------------------
|  ts (varint)  |  len (uvarint)  |  log-3 bytes  |  len(from #symbols)  |  #symbols (uvarint)  |  symbol-1 (uvarint)  | symbol-n*2 (uvarint) |
-----------------------------------------------------------------------------------------------------------------------------------------------
|  ts (varint)  |  len (uvarint)  |  log-n bytes  |  len(from #symbols)  |  #symbols (uvarint)  |  symbol-1 (uvarint)  | symbol-n*2 (uvarint) |
-----------------------------------------------------------------------------------------------------------------------------------------------
```
ts는 로그의 유닉스 나노초 타임스탬프이고, len은 로그 항목의 바이트 단위 길이입니다.

기호는 청크의 structuredMetadata 섹션에 레이블 이름과 값이 포함된 실제 문자열에 대한 참조를 저장합니다.

## Storage
### Single Store
Loki는 모든 데이터를 단일 오브젝트 스토리지 백엔드에 저장합니다. 이 운영 모드는 Loki 2.0에서 일반적으로 사용할 수 있게 되었으며, 빠르고 비용 효율적이며 간단할 뿐만 아니라 현재와 미래의 모든 개발이 이루어지는 곳입니다. 이 모드는 boltdb_shipper라는 어댑터를 사용해 청크를 저장하는 것과 같은 방식으로 오브젝트 스토리지에 인덱스를 저장합니다.

청크 스토어는 백그라운드 유지 관리 작업 없이도 대화형 쿼리 및 지속적인 쓰기를 지원하도록 설계된 Loki의 장기 데이터 저장소입니다. 청크 저장소는 다음으로 구성됩니다:

- 청크에 대한 인덱스. 이 인덱스는 다음에 의해 뒷받침될 수 있습니다:
    - Amazon DynamoDB
    - Google Bigtable
    - Apache Cassandra
- 청크 데이터 자체에 대한 키-값(KV) 저장소입니다:
    - Amazon DynamoDB
    - Google Bigtable
    - Apache Cassandra
    - Amazon S3
    - Google Cloud Storage

Loki의 다른 핵심 구성 요소와 달리 청크 스토어는 별도의 서비스, 작업 또는 프로세스가 아니라 Loki 데이터에 액세스해야 하는 두 서비스, 즉 ingester와 querier에 내장된 라이브러리입니다.

청크 스토어는 청크 스토어 인덱스를 백업하는 데 사용할 수 있는 "NoSQL" 스토어(DynamoDB, Bigtable, Cassandra)에 대한 통합 인터페이스에 의존합니다. 이 인터페이스는 인덱스가 키가 지정된 항목의 모음이라고 가정합니다:
- hash key. 모든 읽기 및 쓰기에 필요합니다.
- range key. 쓰기에는 필요하며 접두사 또는 범위로 쿼리할 수 있는 읽기에는 생략할 수 있습니다.

인터페이스는 지원되는 데이터베이스에 따라 다소 다르게 작동합니다:
- DynamoDB는 기본적으로 범위와 해시 키를 지원합니다. 따라서 인덱스 항목은 해시 키를 배포 키로, 범위를 DynamoDB 범위 키로 사용하여 DynamoDB 항목으로 직접 모델링됩니다.
- 빅테이블과 카산드라의 경우, 인덱스 항목은 개별 열 값으로 모델링됩니다. 해시 키는 행 키가 되고 범위 키는 열 키가 됩니다.

스키마 세트는 청크 저장소에 대한 읽기 및 쓰기에 사용되는 매처와 레이블 세트를 인덱스의 적절한 연산에 매핑하는 데 사용됩니다. 스키마는 주로 쓰기 부하를 더 잘 분산하고 쿼리 성능을 개선하기 위해 Loki가 발전하면서 추가되었습니다.

## Read Path
요약하자면, 읽기 경로는 다음과 같이 작동합니다:

1. querier가 데이터에 대한 HTTP/1 요청을 받습니다.
2. querier는 쿼리를 모든 Ingester에 인메모리 데이터에 대한 쿼리를 전달합니다.
3. Ingester는 읽기 요청을 수신하고 쿼리와 일치하는 데이터가 있는 경우 이를 반환합니다.
4. querier는 데이터를 반환한 Ingester가 없는 경우 백업 저장소에서 데이터를 느리게 로드하고 이에 대해 쿼리를 실행합니다.
5. querier는 수신된 모든 데이터를 반복하고 중복을 제거하여 HTTP/1 연결을 통해 최종 데이터 세트를 반환합니다.

## Write Path
요약하면, 쓰기 경로는 다음과 같이 작동합니다:

1. distributor는 스트림용 데이터를 저장하기 위해 HTTP/1 요청을 받습니다.
2. 각 스트림은 해시 링을 사용하여 해시됩니다.
3. distributor는 각 스트림을 적절한 ingester와 해당 복제본으로 전송합니다(구성된 복제 계수에 따라).
4. 각 ingester는 스트림의 데이터에 대해 청크를 생성하거나 기존 청크에 추가합니다. 청크는 테넌트 및 레이블 세트별로 고유합니다.
5. distributor는 HTTP/1 연결을 통해 성공 코드로 응답합니다.
