- https://docs.fluentbit.io/manual/administration/backpressure
# Backpressure

특정 시나리오에서는 로그나 데이터를 일부 대상으로 플러시하는 기능보다 더 빠르게 수집하거나 생성할 수 있습니다. 
이러한 일반적인 시나리오 중 하나는 특히 백로그가 많은 대용량 로그 파일에서 로그를 읽고 응답하는 데 시간이 걸리는 네트워크를 통해 백엔드로 로그를 전송하는 경우입니다. 
이로 인해 역압이 발생하여 서비스에서 높은 메모리 사용량을 유발합니다.

역압을 피하기 위해 플루언트 비트는 엔진에서 입력 플러그인이 수집할 수 있는 데이터의 양을 제한하는 메커니즘을 구현하며, 이는 구성 매개변수 Mem_Buf_Limit 및 storage.Max_Chunks_Up을 통해 수행됩니다.

버퍼링 개념 섹션에서 설명한 대로, 플루언트 비트는 데이터 처리를 위해 인메모리 전용(기본값)과 인메모리 + 파일 시스템(옵션)의 두 가지 모드를 제공합니다.

기본 storage.type memory 버퍼는 Mem_Buf_Limit으로 제한할 수 있습니다. 
메모리가 이 제한에 도달하여 역압박 시나리오에 도달하면 메모리에 있는 데이터 청크를 플러시할 수 있을 때까지 더 많은 데이터를 수집할 수 없습니다. 
입력이 일시 중지되고 플루언트 비트에서 `[warn] [input] {input name or alias} paused (mem buf overlimit)` 로그 메시지를 표시합니다. 
사용 중인 입력 플러그인에 따라 수신 데이터가 삭제될 수 있습니다(예: TCP 입력 플러그인). 
테일 플러그인은 데이터 손실 없이 일시 중지를 처리할 수 있으며, 현재 파일 오프셋을 저장하고 나중에 다시 읽기를 재개합니다. 
버퍼 메모리를 사용할 수 있게 되면 입력이 로그 수집/수락을 재개하고, 플루언트 비트는 `[info] [input] {input name or alias} resume (mem buf overlimit)` 메시지를 표시합니다.

이러한 데이터 손실 위험은 버퍼링 및 스토리지에 설명된 대로 storage.type filesystem을 사용하여 파일시스템에 보조 스토리지를 구성함으로써 완화할 수 있습니다. 
처음에는 로그가 메모리와 파일 시스템 모두에 버퍼링됩니다. 
storage.max_chunks_up 제한에 도달하면 모든 새 데이터는 파일시스템에만 안전하게 저장됩니다. 
플루언트 비트는 메모리에 새 데이터를 대기열에 추가하는 것을 중지하고 파일시스템에만 버퍼링합니다. 
storage.type filesystem이 설정된 경우 Mem_Buf_Limit 설정은 더 이상 적용되지 않으며, 대신 [SERVICE] 수준의 storage.max_chunks_up 설정이 메모리 버퍼의 크기를 제어한다는 점에 유의하세요.

## Mem_Buf_Limit

이 옵션은 기본적으로 비활성화되어 있으며 모든 입력 플러그인에 적용할 수 있습니다. 
Mem_Buf_Limit은 기본 저장소 유형 메모리에만 적용된다는 점에 유의하세요. 
다음 시나리오를 통해 그 동작을 설명해 보겠습니다:
- Mem_Buf_Limit이 1MB(1메가바이트)로 설정된 경우
- 입력 플러그인이 700KB를 추가하려고 시도합니다.
- 엔진이 데이터를 출력 플러그인으로 라우팅
- 출력 플러그인 백엔드(HTTP 서버)가 다운되었습니다.
- 엔진 스케줄러가 10초 후에 플러시를 다시 시도합니다.
- 입력 플러그인이 500KB를 추가하려고 시도합니다.

이 시점에서 엔진은 500KB의 데이터를 메모리에 추가할 수 있으며, 총 1.2MB의 데이터가 버퍼링됩니다. 
이 한도는 허용되며 한도를 초과하는 한 번의 쓰기는 허용되지만 한도를 초과하면 다음과 같은 조치가 취해집니다:
- 입력 플러그인의 로컬 버퍼를 차단합니다(더 이상 데이터를 추가할 수 없음).
- 입력 플러그인에 일시 중지 콜백을 호출하도록 알립니다.

엔진은 스스로를 보호하고 해당 입력 플러그인에서 오는 데이터를 더 이상 추가하지 않습니다. 
상태를 유지하고 일시 중지된 상태에서 수행할 작업을 결정하는 것은 플러그인의 책임이라는 점에 유의하세요.

일정 시간(보통 초 단위로 측정) 후 스케줄러가 초기 700KB의 데이터를 플러시할 수 있었거나 재시도 후 포기한 경우 해당 양의 메모리가 해제되고 다음 작업이 수행됩니다:

- 데이터 버퍼가 해제되면(700KB) 내부 카운터가 업데이트됩니다.
- 이제 카운터가 500KB로 설정됩니다.
- 500KB는 1MB 미만이므로 입력 플러그인 상태를 확인합니다.
- 플러그인이 일시 중지된 경우 재개 콜백을 호출합니다.
- 입력 플러그인이 계속해서 데이터를 더 추가할 수 있습니다.

## storage.max_chunks_up
storage.type filesystem이 설정된 경우 Mem_Buf_Limit 설정은 더 이상 적용되지 않으며, 대신 [SERVICE] 수준의 storage.max_chunks_up 설정이 메모리 버퍼의 크기를 제어합니다.

이 설정은 기본값이 아닌 storage.pause_on_chunks_overlimit이 활성화된 경우 Mem_Buf_Limit을 사용하는 위의 시나리오와 유사하게 작동합니다.

(기본값인) storage.pause_on_chunks_overlimit이 비활성화되면 메모리 제한에 도달해도 입력이 일시 중지되지 않습니다. 
대신 파일시스템의 로그만 버퍼링하도록 전환됩니다. 
파일 시스템 버퍼링에 사용되는 디스크 간격은 storage.total_limit_size로 제한할 수 있습니다.
자세한 내용은 버퍼링 및 스토리지 문서를 참조하세요.

## About pause and resume Callbacks
각 플러그인은 독립적이며 모든 플러그인이 일시 중지 및 재개 콜백을 구현하는 것은 아닙니다. 

앞서 말했듯이 이러한 콜백은 플러그인의 알림 메커니즘일 뿐입니다.
이러한 콜백을 구현하고 상태를 올바르게 유지하는 플러그인의 한 예로 테일 입력 플러그인을 들 수 있습니다. 
일시 중지 콜백이 트리거되면 해당 플러그인은 수집기를 일시 중지하고 데이터 추가를 중지합니다. 
다시 시작되면 수집기를 다시 시작하고 데이터 수집을 계속합니다. 
Tail은 일시 중지할 때 현재 파일 오프셋을 추적하고 같은 위치에서 다시 시작합니다. 
파일이 삭제되거나 이동되지 않은 경우 여전히 읽을 수 있습니다.

기본 저장소 유형 메모리 및 Mem_Buf_Limit을 사용하면 일시 중지 및 재개 시 다음과 같은 로그 메시지가 전송됩니다:
```
[warn] [input] {input name or alias} paused (mem buf overlimit)
[info] [input] {input name or alias} resume (mem buf overlimit)
```
storage.type 파일 시스템 및 storage.max_chunks_up을 사용하면 일시 중지 및 재개 시 다음과 같은 로그 메시지가 생성됩니다:
```
[input] {input name or alias} paused (storage buf overlimit
[input] {input name or alias} resume (storage buf overlimit
```