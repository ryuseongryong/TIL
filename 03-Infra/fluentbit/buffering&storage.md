- https://docs.fluentbit.io/manual/administration/buffering-and-storage

# Buffering & Storage

플루언트 비트의 최종 목표는 로그를 수집, 파싱, 필터링하여 중앙 위치로 전송하는 것입니다. 
이 워크플로에는 여러 단계가 있으며, 그 중 중요한 부분 중 하나는 처리된 데이터를 전송할 준비가 될 때까지 임시 위치에 저장하는 메커니즘인 버퍼링 기능입니다.

기본적으로 플루언트 비트는 데이터를 처리할 때 메모리를 기본 및 임시 저장소로 사용하지만, 집계 및 데이터 안전 기능을 제공하기 위해 파일시스템에 기반한 영구 버퍼링 메커니즘을 사용하는 것이 이상적인 시나리오가 있습니다.

올바른 구성을 선택하는 것이 중요하며, backpressure 설정에 따라 서비스 동작을 조절할 수 있습니다. 
구성을 시작하기 전에 청크, 메모리, 파일 시스템 및 백프레셔 간의 관계를 이해해야 합니다.

## Chunks, Memory, Filesystem and Backpressure

청크, 버퍼링 및 배압 개념을 이해하는 것은 올바른 구성을 위해 매우 중요합니다. 
이러한 개념의 의미를 다시 한 번 정리해 보겠습니다.

### 청크
입력 플러그인(소스)이 레코드를 내보낼 때 엔진은 레코드를 청크에 함께 그룹화합니다. 
청크의 크기는 보통 2MB 정도입니다. 
엔진은 설정에 따라 이 청크를 어디에 배치할지 결정하며, 기본값은 모든 청크가 메모리에만 생성된다는 것입니다.

### 복구 불가능한 청크
플루언트 비트가 청크를 복구 불가능한 것으로 표시하는 두 가지 시나리오가 있습니다:

- 플루언트 비트가 청크에서 잘못된 레이아웃을 발견한 경우. 잘못된 레이아웃은 예상 형식을 따르지 않는 청크입니다.
- 플루언트 비트에서 청크 헤더 크기가 잘못되었거나 유효하지 않은 경우.

두 시나리오 모두에서 플루언트 비트는 오류 메시지를 기록한 다음 복구할 수 없는 청크를 삭제합니다.

### 버퍼링 및 메모리
위에서 언급했듯이 엔진에서 생성된 청크는 메모리에 배치되지만 이는 구성할 수 있습니다.

메모리가 입력 플러그인에 대해 설정된 유일한 메커니즘인 경우, 메모리에 저장할 수 있는 만큼만 데이터를 저장합니다(메모리). 이는 시스템 오버헤드가 가장 적은 가장 빠른 메커니즘이지만, 네트워크가 느리거나 원격 서비스가 응답하지 않아서 서비스가 레코드를 충분히 빠르게 전달할 수 없는 경우 플루언트 비트 메모리 사용량은 전달할 수 있는 것보다 더 많은 데이터를 축적하므로 증가합니다.

역압이 있는 고부하 환경에서는 메모리 사용량이 높아지면 커널(OOM 킬러)에 의해 죽임을 당할 위험이 있습니다. 이 백프레셔 시나리오에 대한 해결 방법은 입력 플러그인이 등록할 수 있는 레코드의 메모리 양을 제한하는 것인데, 이 구성 속성을 mem_buf_limit이라고 합니다. 플러그인이 mem_buf_limit을 초과하여 큐에 넣은 경우, 해당 데이터가 제대로 전달되거나 플러시될 때까지 더 이상 수집할 수 없습니다. 이 시나리오에서는 해당 입력 플러그인이 일시 중지됩니다. 입력이 일시 중지되면 다시 시작될 때까지 레코드가 수집되지 않습니다. TCP 및 테일과 같은 일부 입력의 경우, 입력을 일시 중지하면 거의 확실하게 로그 손실로 이어집니다. 테일 입력의 경우, 플루언트 비트는 현재 읽고 있는 파일에 현재 오프셋을 저장했다가 입력이 재개되면 다시 가져올 수 있습니다.

플루언트 비트 로그 출력에서 다음과 같은 메시지를 찾아보세요:
```
[input] tail.1 paused (mem buf overlimit)
[input] tail.1 resume (mem buf overlimit)
```

mem_buf_limit의 해결 방법은 특정 시나리오와 환경에 적합하며 서비스의 메모리 사용량을 제어하는 데 도움이 되지만, 일시 중지된 상태에서 파일이 회전하면 새 레코드를 등록할 수 없어 해당 데이터가 손실될 수 있다는 단점이 있습니다. 
이는 모든 입력 소스 플러그인에서 발생할 수 있습니다. 
mem_buf_limit의 목표는 메모리 제어와 서비스 생존입니다.

완전한 데이터 안전성을 보장하려면 파일 시스템 버퍼링을 사용하세요.

다음은 입력 정의 예시입니다:
```
[INPUT]
    Name          tcp
    Listen        0.0.0.0
    Port          5170
    Format        none
    Tag           tcp-logs
    Mem_Buf_Limit 50MB
```

이 입력이 로그를 버퍼링하는 데 50MB 이상의 메모리를 사용하는 경우, 유창한 비트 로그에 다음과 같은 경고가 표시됩니다:

```
[input] tcp.1 paused (mem buf overlimit)
```

Mem_Buf_Limit은 storage.type이 기본 메모리 값으로 설정된 경우에만 적용된다는 점에 유의하세요. 
아래 섹션에서는 storage.type 파일 시스템을 활성화할 때 적용되는 제한에 대해 설명합니다.

### Filesystem buffering to the rescue
파일 시스템 버퍼링을 활성화하면 배압 및 전반적인 메모리 제어에 도움이 됩니다.

메모리와 파일시스템 버퍼링 메커니즘은 서로 배타적이지 않습니다. 실제로 입력 플러그인(소스)에 파일시스템 버퍼링을 활성화하면 성능과 데이터 안전성이라는 두 가지 장점을 모두 얻을 수 있습니다.

파일 시스템 버퍼링이 활성화되면 엔진의 동작이 달라집니다. 청크가 생성되면 엔진은 콘텐츠를 메모리에 저장하고 디스크에 사본을 매핑합니다(mmap(2)를 통해). 새로 생성된 청크는 (1) 메모리에서 활성화되고, (2) 디스크에 백업되며, (3) "청크 콘텐츠가 메모리에 있다"는 의미로 "up"이라고 호출됩니다.

파일 시스템 버퍼링 메커니즘은 높은 메모리 사용량과 역압력을 어떻게 처리하나요? 플루언트 비트는 메모리에 올라가는 청크의 수를 제어합니다.

기본적으로 엔진은 모든 청크를 고려하여 총 128개의 청크를 메모리에 저장할 수 있으며, 이 값은 서비스 속성 storage.max_chunks_up에 의해 제어됩니다. 가동 중인 활성 청크는 전송 준비가 완료된 상태이며, 아직 레코드를 수신 중인 청크도 있습니다. 나머지 청크는 다운 상태이므로 파일 시스템에만 존재하며 전송할 준비가 되지 않는 한 메모리에서 업 상태가 되지 않습니다. 청크는 2MB보다 크지 않으므로 기본 storage.max_chunks_up 값이 128인 경우 각 입력은 약 256MB의 메모리로 제한됩니다.

입력 플러그인에서 storage.type을 파일 시스템으로 활성화한 경우, storage.max_chunks_up 임계값에 도달하면 플러그인이 일시 중지되는 대신 모든 새 데이터가 파일 시스템에서 다운된 청크로 이동합니다. 이를 통해 서비스의 메모리 사용량을 제어할 수 있으며 데이터가 손실되지 않도록 보장할 수 있습니다. 기본적으로 storage.max_chunks_up 제한을 적용하는 것은 최선의 노력입니다. 플루언트 비트는 업 상태인 청크에만 새 데이터를 추가할 수 있으며, 한도에 도달하면 새 데이터를 수집하기 위해 청크를 메모리에 일시적으로 불러온 후 다운 상태로 전환합니다. 일반적으로 플루언트 비트는 업 청크의 총 개수를 storage.max_chunks_up 이하로 유지하기 위해 작동합니다.

storage.pause_on_chunks_overlimit이 활성화된 경우(기본값은 꺼짐), 입력 플러그인은 storage.max_chunks_up을 초과하면 일시 중지됩니다. 따라서 이 옵션을 사용하면 storage.max_chunks_up이 입력에 대한 하드 리밋이 됩니다. 입력이 일시 중지되면 다시 시작될 때까지 레코드가 수집되지 않습니다. TCP 및 테일과 같은 일부 입력의 경우, 입력을 일시 중지하면 거의 확실하게 로그 손실로 이어집니다. 테일 입력의 경우, 플루언트 비트는 현재 읽고 있는 파일에 현재 오프셋을 저장했다가 입력이 재개되면 다시 가져올 수 있습니다.

플루언트 비트 로그 출력에서 다음과 같은 메시지를 찾아보세요:
```
[input] tail.1 paused (storage buf overlimit
[input] tail.1 resume (storage buf overlimit
```

### Limiting Filesystem space for Chunks
플루언트 비트는 논리적 대기열 개념을 구현하여 태그에 따라 청크를 여러 목적지로 라우팅할 수 있습니다. 
따라서 청크가 어디에서 생성되었고 어디로 이동해야 하는지에 대한 내부 참조를 유지합니다.

청크의 목적지가 여러 곳일 경우, 목적지 중 한 곳이 다른 곳보다 느리거나, 한 곳에서만 역압이 발생하고 다른 곳에서는 발생하지 않는 경우가 종종 있습니다. 
이 시나리오에서 논리적으로 대기열에 넣는 파일 시스템 청크의 양을 어떻게 제한할 수 있을까요?

플루언트 비트 v1.6부터 특정 논리적 출력 대상에 대해 파일시스템에 존재하는 청크의 수를 제한하는 storage.total_limit_size라는 출력 플러그인의 새로운 구성 속성을 도입했습니다. 
대상 중 하나가 storage.total_limit_size에 도달하면 해당 논리적 출력 대상에 대한 대기열에서 가장 오래된 청크가 삭제됩니다.