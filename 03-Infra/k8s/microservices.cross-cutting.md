- https://www.baeldung.com/cs/microservices-cross-cutting-concerns#sidecar

# 마이크로서비스와 크로스 커팅 문제

1. 개요
흔히 마이크로서비스를 완전히 독립적이고 독립된 단위로 생각하지만, 항상 그런 것은 아닙니다. 때로는 시스템 수준에서 생각하고 자율성을 일부 포기하는 것이 더 편리할 때도 있습니다.

이러한 교차적인 문제들을 자세히 살펴보고 어떤 것들이 있는지 알아봅시다.

2. 보안
가장 먼저 고려해야 할 사항 중 하나는 이 아키텍처 스타일에 보안이 어떻게 관련되어 있는지입니다. 마이크로서비스 아키텍처는 본질적으로 다른 패턴보다 더 분산되어 있습니다. 구성 요소 간의 호출이 더 많으므로 미사용, 전송 및 사용 중인 데이터의 보안을 유지하기 위한 정책에 특히 주의를 기울여야 합니다.

이러한 특성을 고려할 때 가장 취약한 부분은 API입니다. API 게이트웨이를 구축하면 외부에서 들어오는 호출에 대한 단일 진입점 역할을 하므로 유리합니다. 이렇게 하면 적절한 화이트리스트를 통해 공격 표면을 줄여 악의적인 공격자의 잠재적 공격을 방지할 수 있습니다.

엔드포인트 보안은 매우 중요합니다. 따라서 권한 부여 및 인증이라는 주제에 대해서도 살펴봐야 합니다. 오늘날 권한 부여 관리의 사실상 표준은 OAuth/OAuth2 플로우입니다. 반면 이중 인증은 인증 부분에서 원치 않는 악의적인 액세스를 방지하고 탐지하는 데 도움이 됩니다.

3. 구성 관리
마이크로서비스 구성 관리는 마이크로서비스 자체와 이를 사용하는 애플리케이션의 변경 추적 프로세스와 관련이 있습니다. 마이크로서비스 아키텍처에서 단일 마이크로서비스에 대한 변경은 전체 아키텍처에 영향을 미칠 수 있습니다. 즉, 모든 소비자에게 잠재적으로 영향을 미칠 수 있습니다.

즉, 모든 마이크로서비스의 배포와 그 구성을 추적해야 합니다. 이러한 방식으로 모든 주변 요소(예: 쿠버네티스 클러스터, 이를 호스팅하는 인프라와 관련된 정보)를 추가하면 게임의 전체 그림을 파악할 수 있습니다.

클러스터에서 수백, 수천 개의 마이크로서비스가 실행되고 있다고 가정해 보겠습니다. 모든 마이크로서비스가 실행 중인 환경에 따라 특정 구성을 취할 수 있는 중앙 집중식 장소가 필요합니다.

4. 로그 집계 및 분산 추적
로깅은 소프트웨어 애플리케이션의 중요한 부분으로, 코드가 실행될 때 무엇을 했는지 알려줍니다. 로깅을 통해 예상대로 실행되는지 확인할 수 있으며, 더 중요한 것은 실행되지 않을 때 문제를 진단하는 데 도움이 된다는 것입니다.

마이크로서비스 아키텍처를 사용하면 인프라에서 여러 개의 마이크로서비스가 실행됩니다. 또한 동일한 마이크로서비스의 인스턴스가 여러 개 있을 수도 있습니다. 각 마이크로서비스는 표준 형식으로 자체 로그를 작성하며 정보, 경고, 오류 및 디버그 메시지를 포함합니다.

이러한 종류의 시스템에서는 태생적으로 문제가 분리되어 있기 때문에 하나의 요청을 처리하기 위해 여러 마이크로 서비스를 참여시켜야 하는 경우가 많습니다.
따라서 모든 마이크로서비스에서 로그를 수집하고 집계해야 하며, 둘째로 전체 여정 요청을 관찰하는 데 필요한 모든 내부 호출을 상호 연관시킬 수 있는 메커니즘을 갖춰야 할 필요성이 생깁니다:

이러한 로그 집계 도구는 상관관계 ID(CID)를 활용하며, 관련된 서비스 호출 집합에 대해 단일 ID를 사용합니다. 예를 들어, 클라이언트 요청의 결과로 트리거될 수 있는 일련의 호출이 있습니다. 이 ID를 각 로그 항목의 일부로 기록하면 특정 호출 흐름과 관련된 모든 로그를 분리하여 문제 해결을 훨씬 더 간단하게 할 수 있습니다.

5. 서비스 검색 및 부하 분산
탄력성과 안정성은 마이크로서비스가 가장 잘 지원할 수 있는 두 가지 기능입니다.

마이크로서비스 기반 애플리케이션은 일반적으로 가상화 또는 컨테이너화된 환경에서 실행됩니다. 서비스의 인스턴스 수와 위치는 동적으로 변경됩니다. 이때 서비스 검색 및 로드 밸런싱과 같은 전술이 중요한 역할을 합니다. 외부에서 들어오는 호출을 분산하려면 이러한 인스턴스의 위치와 이름을 알아야 합니다.

서비스 검색은 각 인스턴스의 위치와 이름을 추적하는 서비스 레지스트리로 상상할 수 있습니다. 간단히 말해, 새 인스턴스가 제공되고 요청을 수락할 준비가 되면 지정된 노드에 준비 상태를 전달합니다. 후자는 핑/에코 또는 하트비트 전술 등을 통해 존재하는 모든 인스턴스의 상황을 모니터링합니다.

반면 부하 분산은 알고리즘에 따라 여러 인스턴스 중 하나에 부하를 분산하여 더 이상 정상적이지 않은 인스턴스를 제거하고 다시 가동될 때 인스턴스를 다시 설치해야 하는 경우입니다. 기타 유용한 기능으로는 수신 통화 트래픽의 전송 및 마이크로서비스 간의 데이터 보안을 관리하는 SSL 종료 등이 있습니다:

서비스 검색과 로드 밸런싱은 모두 Service Mesh와 같은 도구 또는 Kubernetes와 같은 오케스트레이션 시스템에서 제공됩니다.

6. 공유 라이브러리
재사용 가능한 코드를 만들려면 DRY(반복하지 않기)를 실천해야 합니다. 일반적으로 이 말은 일리가 있습니다. 마이크로서비스와 관련하여 끊임없이 논의되는 주제는 공유 라이브러리를 사용할지 여부입니다. 물론 공유 라이브러리를 사용할 수 있다고 해서 반드시 사용하는 것이 옳은 것은 아닙니다.

첫 번째 요점은 코드를 공유하면 이기종 기술을 사용할 수 있는 자유가 줄어든다는 것입니다. Java 공유 라이브러리는 다른 Java 기반 마이크로서비스를 구축하는 데 영향을 미칠 수 있습니다. 이것이 반드시 단점이라고 할 수는 없지만 강조할 필요가 있습니다.

기본적으로 마이크로서비스를 구현한다는 것은 책임을 공유하고 결합을 줄이는 것을 의미합니다. 공유 라이브러리를 도입하는 것은 이러한 아키텍처의 기본 철학에 위배됩니다. 공유 라이브러리를 도입하려는 이유를 이해하는 것이 중요합니다. DDD와 같은 기술을 제대로 적용했다면 매우 응집력 있고 결합이 잘 되지 않는 아키텍처를 갖게 될 것입니다. 우리는 이러한 개념을 보존하고자 합니다.

마이크로서비스 내에 공유 라이브러리가 있는 경우, 코드를 변경하면 해당 마이크로서비스를 재배포해야 하므로 마이크로서비스의 기본 속성 중 하나인 독립적인 배포 가능성이 약화된다는 점을 인정해야 합니다.
배포 복잡성을 증가시키거나 극단적으로 말하자면 분산된 모놀리스를 다루고 싶지 않다면 이 속성을 유지하는 것이 가장 좋습니다.

마이크로서비스에서 코드를 공유하는 것이 항상 잘못된 것은 아니지만, 한 번 더 생각해 볼 필요가 있는 것은 분명합니다.

7. 사이드카
사이드카 패턴은 아마도 가장 교차적인 관심사일 것입니다. 마이크로서비스 아키텍처에 대해 이야기할 때는 다국어 시스템의 가능성에 대해서도 이야기합니다. 즉, 해결해야 하는 작업에 따라 언어, 기술 또는 프레임워크를 자유롭게 선택할 수 있다는 뜻입니다.

이로 인해 서로 다른 언어를 사용하는 마이크로서비스가 존재할 수 있으며, 이로 인해 크로스 커팅 라이브러리를 유지 관리하기가 더 어려워질 수 있습니다.
이에 대한 한 가지 해결책은 사이드카 패턴입니다. 크로스커팅 관심사에 대한 로직은 자체 프로세서 컨테이너(사이드카 컨테이너라고 함) 에 배치된 다음 기본 애플리케이션에 연결됩니다 . 오토바이 사이드카가 오토바이에 연결되는 방식과 유사하게 사이드카 애플리케이션은 기본 애플리케이션에 연결되고 함께 실행됩니다:

