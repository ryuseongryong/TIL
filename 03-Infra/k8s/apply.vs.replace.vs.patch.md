# Kubernetes Apply vs. Replace vs. Patch

- https://blog.atomist.com/kubernetes-apply-replace-patch/

쿠버네티스는 적용, 편집, 패치, 교체 등 리소스를 업데이트하는 여러 가지 방법을 제공한다. 안타깝게도 각각의 기능과 사용 시점에 대해 약간의 혼란이 있는 것 같습니다. Google에서 'kubernetes 적용과 바꾸기'를 검색할 때 Stack Overflow에서 제공하는 강조 표시된 답변이 잘못되었습니다. 'kubernetes 적용 대 패치'를 검색하면 결과의 첫 번째 항목은 적용과 패치의 비교가 포함되지 않은 kubectl 패치 문서입니다. 이 게시물에서는 다양한 접근 방식과 각각의 사용 시기를 설명한다.

업데이트: 이 게시물은 이제 'kubernetes 적용 대 교체'를 검색할 때 Google에서 가장 먼저 반환되는 사이트이지만 강조 표시된 답변은 여전히 잘못되었습니다. 'kubernetes 적용 대 패치'를 검색할 때 이 게시물이 강조 표시된 답변으로 표시됩니다!

서비스, 배포 또는 인그레스와 같은 Kubernetes 리소스의 라이프사이클 중에 리소스의 특정 속성을 변경, 추가 또는 삭제해야 하는 경우가 있습니다. 예를 들어, 어노테이션을 추가해야 하거나 배포의 원하는 복제본 수를 늘리거나 줄여야 하는 경우가 있습니다.

## The Kubernetes CLI
kubectl 명령줄 인터페이스(CLI)를 사용하여 쿠버네티스 클러스터와 상호 작용하는 경우, 적용 및 편집 하위 명령에 익숙할 것이다. 적용 명령은 파일에서 리소스 사양을 읽고, 리소스가 없는 경우 리소스를 삽입/생성하거나 있는 경우 해당 리소스를 업데이트하는 등 쿠버네티스 클러스터에 리소스를 "업서트"한다. 편집 명령은 Kubernetes API에서 리소스를 읽고, 리소스 사양(즉, "spec")을 로컬 파일에 쓰고, 텍스트 편집기에서 해당 파일을 엽니다. 그런 다음 파일을 편집하고 저장하면 kubectl은 사용자가 변경한 내용을 다시 쿠버네티스 API로 전송하여 리소스에 해당 변경 사항을 적용한다.

익숙하지 않은 서브커맨드는 아마도 패치와 교체일 것이다. 패치 명령어를 사용하면 리소스 스펙의 일부를 수정할 수 있으며, 명령줄에 변경된 부분만 제공한다. replace 명령은 편집 명령의 수동 버전과 비슷하게 동작한다. 예를 들어, kubectl get -o yaml을 사용하여 리소스 스펙의 현재 버전을 다운로드하고, 편집한 다음, 수정된 스펙을 사용하여 리소스를 업데이트하려면 kubectl replace를 사용해야 한다. 리소스를 읽고 교체하는 사이에 변경 사항이 발생하면 교체가 실패한다.

## The Kubernetes API
선택한 프로그래밍 언어용 쿠버네티스 클라이언트 라이브러리를 사용하여 쿠버네티스 클러스터와 상호 작용하는 경우, CoreV1().파드().업데이트(), 대체 네임스페이스 서비스 또는 패치_네임스페이스_디플로이먼트와 같은 메서드에 익숙할 것이다. 이러한 클라이언트 라이브러리 메서드의 기반에는 PUT 및 PATCH HTTP 요청 메서드를 사용하는 HTTP 요청이 있습니다. "update" 및 "replace" 메서드는 PUT을 사용하고 "patch" 메서드는 당연히 PATCH를 사용합니다.

한 가지 주목할 점은 kubectl이 쿠버네티스 API를 사용하여 클러스터와 상호 작용한다는 것이다. 다시 말해, kubectl은 Go 쿠버네티스 클라이언트 라이브러리를 위한 명령줄 래퍼인 동시에 쿠버네티스 API의 기능에 더해 상당한 양의 설탕을 제공한다. 예를 들어, 위에서 언급된 "적용" API 메서드가 없다는 것을 눈치채셨을 것입니다. 현재 모든 쿠벡툴 적용 로직, 즉 존재하지 않는 리소스를 생성하고 기존 리소스를 패치하는 로직은 전적으로 쿠벡툴 코드 베이스에 존재한다. 적용 로직을 쿠버네티스 API로 옮기기 위한 노력이 진행 중이지만, 아직 베타 버전이다. 이에 대한 자세한 내용은 아래에서 확인할 수 있다.

## By default, patch
리소스를 업데이트하려는 경우, 기본적으로 패치를 적용하는 것이 가장 좋다. 이는 쿠버네티스 클라이언트 라이브러리를 사용하든 kubectl을 사용하든 마찬가지이다.

### Be strategic
내부적으로, kubectl 적용, 편집 및 패치 커맨드는 모두 기존 리소스를 업데이트하기 위해 PATCH HTTP 요청 메서드를 사용한다. 더 구체적으로, 리소스를 업데이트할 때 모두 전략적 병합 패치 접근 방식을 사용하지만, 패치는 다른 접근 방식을 사용할 수도 있다(아래에서 자세히 설명한다). 전략적 병합 접근 방식은 제공된 사양을 기존 사양과 결합할 때 "올바른 작업"을 시도합니다. 좀 더 구체적으로 말하자면, 객체와 배열을 모두 병합하려고 시도하므로 변경 사항이 추가되는 경향이 있습니다. 예를 들어, 하나의 새로운 환경 변수가 포함된 패치를 파드 컨테이너 스펙에 제공하면 기존 환경 변수를 덮어쓰는 것이 아니라 해당 환경 변수가 기존 환경 변수에 추가된다. 이 접근 방식으로 프로퍼티를 삭제하려면 제공된 스펙에서 해당 값을 null로 구체적으로 설정해야 합니다. 그렇다면 업데이트하는 kubectl 서브커맨드 중 어떤 것을 사용하는 것이 가장 좋을까?

리소스를 생성하고 관리하는 경우, 업데이트할 때 항상 kubectl apply를 사용하는 것이 가장 좋으며, 그래야 kubectl이 구성을 관리하고 적용에서 적용으로 요청된 변경 사항을 적절하게 추적할 수 있다. 적용을 항상 사용하면 이전에 적용된 스펙을 추적하여 스펙 프로퍼티와 배열 요소가 명시적으로 제거된 시점을 알 수 있다는 이점이 있다. 따라서 일반적인 전략적 병합에서는 제거할 수 없는 프로퍼티와 배열 요소를 적용을 통해 제거할 수 있습니다. 편집 및 패치 명령은 변경 사항을 추적하는 데 사용하는 어노테이션을 업데이트하지 않으므로, 편집 및 패치로 수행한 모든 변경 사항은 쿠버네티스 API에 의해 추적되고 명시되지만 후속 적용 명령에는 보이지 않으므로 적용 입력 스펙[1]에 나타나지 않더라도 적용이 제거하지 않는다.

kubectl apply를 사용하지 않는 경우, 편집과 패치를 혼용하여 사용할 수 있으며, 수행하려는 특정 변경에 적합한 명령을 선택할 수 있다. 스펙 속성을 추가하고 변경할 때 두 접근 방식은 어느 정도 동일하다. 스펙 속성이나 배열 요소를 제거할 때 편집은 일회성 적용처럼 작동합니다. 즉, 편집하기 전과 후의 스펙을 추적하여 리소스에서 명시적으로 속성 및 배열 요소를 제거할 수 있습니다. 패치를 사용하면 리소스에서 프로퍼티를 제거하려면 패치 사양에서 프로퍼티의 값을 null로 명시적으로 설정해야 합니다. 전략적 병합 패치를 사용하여 배열 요소를 제거하는 것은 더 복잡하므로 병합 지시문을 사용해야 합니다. 보다 합리적인 대안은 아래의 다른 패치 방법을 참조하세요.

"패치" 클라이언트 라이브러리 메서드가 위의 kubectl 패치 서브커맨드와 유사하게 동작하도록 하려면, 요청의 콘텐츠 타입 헤더를 application/strategic-merge-patch+json으로 설정해야 한다. kubectl 패치와 마찬가지로, 스펙 프로퍼티를 제거하려면 명시적으로 해당 값을 null로 설정해야 한다. 배열 요소를 제거하려면 패치 스펙에 merge 지시문을 포함하거나 다른 패치 방식을 사용해야 한다.

### Other patching approaches
쿠버네티스는 두 가지 다른 패치 접근 방식을 지원한다: JSON 병합 패치와 JSON 패치. 전략적 병합 접근 방식과 마찬가지로, JSON 병합 패치 접근 방식은 부분적인 쿠버네티스 스펙을 입력으로 받아들이고 오브젝트 병합을 지원한다. JSON 병합 패치 접근 방식은 배열 교체만 지원한다는 점에서 전략적 병합 접근 방식과 다르다. 여기에는 파드 스펙의 컨테이너 배열이 포함된다. 즉, JSON 병합 접근 방식을 사용할 때 컨테이너의 속성을 변경하려면 모든 컨테이너에 대한 전체 스펙을 제공해야 합니다. 따라서 JSON 병합 패치 접근 방식은 스펙의 배열에서 요소를 제거하려는 경우에 유용하다. 명령줄에서 kubectl patch --type=merge를 사용하여 JSON 병합 패치를 선택할 수 있다. 쿠버네티스 API를 사용하는 경우, PATCH 요청 메서드를 사용하여 쿠버네티스 리소스 엔드포인트에 액세스하고 콘텐츠 유형 요청 헤더를 application/merge-patch+json으로 설정할 때 JSON 병합 패치가 사용된다.

JSON 패치 접근 방식은 리소스의 일부 사양을 제공하는 대신 리소스에 적용하려는 변경 사항의 JSON 표현을 사용한다. JSON 패치는 배열로 구성되며, 배열의 각 요소는 리소스에 적용할 변경 사항에 대한 설명입니다. JSON 패치는 수행하려는 변경 사항을 보다 유연하고 강력하게 표현하는 방법이지만, 더 이상 리소스 스펙의 일부가 아니라 쿠버네티스 스펙이 아닌 별도의 형식으로 수행하려는 변경 사항 집합을 전송해야 한다는 대가가 따른다. 명령줄에서 kubectl patch --type=json을 사용하여 JSON 패치를 선택할 수 있다. 쿠버네티스 API를 사용하는 경우, PATCH 요청 메서드를 사용하여 쿠버네티스 리소스 엔드포인트에 액세스하고 콘텐츠 유형 요청 헤더를 application/json-patch+json으로 설정할 때 JSON 패치가 사용된다.

## When you need to be certain, replace
리소스를 읽은 시점과 리소스를 업데이트하는 시점 사이에 리소스가 변경되지 않았는지 확인해야 하는 경우가 있을 수 있습니다. 다시 말해, 리소스에 대한 모든 변경 사항이 원자적인지 확인해야 합니다. 이것이 바꾸기를 사용하여 리소스를 업데이트하는 사용 사례입니다. 예를 들어 여러 소스에 의해 업데이트되는 카운터가 있는 컨피그맵이 있는 경우 두 소스가 동시에 카운터를 업데이트하려고 시도하여 업데이트가 "손실"되지 않도록 해야 할 수 있습니다. 패치 접근 방식을 사용하는 이벤트 시퀀스를 예로 들어 설명해 보겠습니다.

1. A와 B는 쿠버네티스 API에서 리소스의 현재 상태를 가져옵니다.
2. A와 B는 모두 로컬로 스펙을 업데이트하여 카운터를 n에서 n+1로 증가시키고 "updated-by" 어노테이션에 각각 "A"와 "B"를 추가합니다.
3. A가 조금 더 빠르게 리소스를 패치합니다.
4. B는 리소스를 패치합니다.

그 결과 A 업데이트가 손실됩니다. 마지막 패치 작업이 승리하고 카운터는 2가 아니라 1씩만 증가하며 "업데이트 기준" 주석의 값은 "B"로 끝나고 "A"가 없습니다. 위의 내용을 바꾸기 방식을 사용하여 업데이트를 수행할 때 발생하는 상황과 비교해 보세요.

1. A와 B는 쿠버네티스 API에서 리소스의 현재 상태를 가져옵니다.
2. A와 B는 모두 로컬로 스펙을 업데이트하여 카운터를 n에서 n+1로 증가시키고 "updated-by" 어노테이션에 각각 "A"와 "B"를 추가합니다.
3. A는 조금 더 빠르게 리소스를 대체합니다.
4. B는 리소스를 교체하려고 시도하지만, A 교체 작업이 수행될 때 리소스 버전이 증가했기 때문에 교체 사양의 리소스 버전이 Kubernetes의 현재 리소스 버전과 일치하지 않기 때문에 API에 의해 업데이트가 거부된다.

위의 경우 소스 B는 리소스를 다시 가져와서 새 상태에 맞게 변경한 다음 다시 교체를 시도해야 합니다. 그 결과 카운터가 2씩 증가하고 "업데이트 기준" 어노테이션이 "AB"로 끝납니다.

위의 예제에서 암시하는 것은 리소스를 교체한다는 것은 바로 전체 리소스를 교체한다는 것입니다. 리소스 교체 요청에 제공된 스펙은 부분 스펙이 아닌 전체 리소스 스펙이어야 하며, kubectl 적용 시 필요한 부분만 제공하면 안 된다. 특히, 스펙 메타데이터에 현재 resourceVersion을 포함해야 한다. 리소스 버전을 포함하지 않거나 제공한 버전이 현재 버전이 아닌 경우 교체가 거부된다. 따라서 대체를 사용하는 가장 좋은 방법은 리소스를 읽고, 업데이트하고, 즉시 대체하는 것이다. kubectl을 사용하면 다음과 같이 보일 수 있다.
```
$ kubectl get deployment my-deployment -o json \
    | jq '.spec.template.spec.containers[0].env[1].value = "new value"' \
    | kubectl replace -f -
```
즉, 다음 두 명령을 순서대로 성공적으로 실행할 수 있다는 것을 알 수 있습니다.

```
$ kubectl create -f deployment.yaml
$ kubectl replace -f deployment.yaml

```

deploy.yaml에 .metadata.resourceVersion 속성을 지정하지 않는 한. 이는 위에서 말씀드린 내용, 즉 "사양 메타데이터에 현재 resourceVersion을 포함해야 한다"는 내용과 직접적으로 모순되는 것처럼 보입니다. 그렇다면 그 말이 틀렸나요? 아니요, 그렇지 않습니다. 내부에서 일어나는 일은 사용자가 resourceVersion을 제공하지 않았다는 것을 알아차리고, 쿠버네티스에서 리소스를 읽고, 사용자가 제공한 스펙에 현재 resourceVersion을 추가한 다음, 교체 요청을 수행한다는 것이다. 대체의 원자적 특성에 의존하는 경우 위험할 수 있는 이 마법은 전적으로 kubectl에 존재하기 때문에, 쿠버네티스 API 클라이언트 라이브러리를 사용할 때는 이 마법에 의존할 수 없다. 이 경우, 현재 리소스 스펙을 GET하고 업데이트한 다음 PUT 요청을 실행해야 한다.

