# Kubernetes Apply vs. Replace vs. Patch

- https://blog.atomist.com/kubernetes-apply-replace-patch/

쿠버네티스는 적용, 편집, 패치, 교체 등 리소스를 업데이트하는 여러 가지 방법을 제공한다. 안타깝게도 각각의 기능과 사용 시점에 대해 약간의 혼란이 있는 것 같습니다. Google에서 'kubernetes 적용과 바꾸기'를 검색할 때 Stack Overflow에서 제공하는 강조 표시된 답변이 잘못되었습니다. 'kubernetes 적용 대 패치'를 검색하면 결과의 첫 번째 항목은 적용과 패치의 비교가 포함되지 않은 kubectl 패치 문서입니다. 이 게시물에서는 다양한 접근 방식과 각각의 사용 시기를 설명한다.

업데이트: 이 게시물은 이제 'kubernetes 적용 대 교체'를 검색할 때 Google에서 가장 먼저 반환되는 사이트이지만 강조 표시된 답변은 여전히 잘못되었습니다. 'kubernetes 적용 대 패치'를 검색할 때 이 게시물이 강조 표시된 답변으로 표시됩니다!

서비스, 배포 또는 인그레스와 같은 Kubernetes 리소스의 라이프사이클 중에 리소스의 특정 속성을 변경, 추가 또는 삭제해야 하는 경우가 있습니다. 예를 들어, 어노테이션을 추가해야 하거나 배포의 원하는 복제본 수를 늘리거나 줄여야 하는 경우가 있습니다.

## The Kubernetes CLI
kubectl 명령줄 인터페이스(CLI)를 사용하여 쿠버네티스 클러스터와 상호 작용하는 경우, 적용 및 편집 하위 명령에 익숙할 것이다. 적용 명령은 파일에서 리소스 사양을 읽고, 리소스가 없는 경우 리소스를 삽입/생성하거나 있는 경우 해당 리소스를 업데이트하는 등 쿠버네티스 클러스터에 리소스를 "업서트"한다. 편집 명령은 Kubernetes API에서 리소스를 읽고, 리소스 사양(즉, "spec")을 로컬 파일에 쓰고, 텍스트 편집기에서 해당 파일을 엽니다. 그런 다음 파일을 편집하고 저장하면 kubectl은 사용자가 변경한 내용을 다시 쿠버네티스 API로 전송하여 리소스에 해당 변경 사항을 적용한다.

익숙하지 않은 서브커맨드는 아마도 패치와 교체일 것이다. 패치 명령어를 사용하면 리소스 스펙의 일부를 수정할 수 있으며, 명령줄에 변경된 부분만 제공한다. replace 명령은 편집 명령의 수동 버전과 비슷하게 동작한다. 예를 들어, kubectl get -o yaml을 사용하여 리소스 스펙의 현재 버전을 다운로드하고, 편집한 다음, 수정된 스펙을 사용하여 리소스를 업데이트하려면 kubectl replace를 사용해야 한다. 리소스를 읽고 교체하는 사이에 변경 사항이 발생하면 교체가 실패한다.

## The Kubernetes API
선택한 프로그래밍 언어용 쿠버네티스 클라이언트 라이브러리를 사용하여 쿠버네티스 클러스터와 상호 작용하는 경우, CoreV1().파드().업데이트(), 대체 네임스페이스 서비스 또는 패치_네임스페이스_디플로이먼트와 같은 메서드에 익숙할 것이다. 이러한 클라이언트 라이브러리 메서드의 기반에는 PUT 및 PATCH HTTP 요청 메서드를 사용하는 HTTP 요청이 있습니다. "update" 및 "replace" 메서드는 PUT을 사용하고 "patch" 메서드는 당연히 PATCH를 사용합니다.

한 가지 주목할 점은 kubectl이 쿠버네티스 API를 사용하여 클러스터와 상호 작용한다는 것이다. 다시 말해, kubectl은 Go 쿠버네티스 클라이언트 라이브러리를 위한 명령줄 래퍼인 동시에 쿠버네티스 API의 기능에 더해 상당한 양의 설탕을 제공한다. 예를 들어, 위에서 언급된 "적용" API 메서드가 없다는 것을 눈치채셨을 것입니다. 현재 모든 쿠벡툴 적용 로직, 즉 존재하지 않는 리소스를 생성하고 기존 리소스를 패치하는 로직은 전적으로 쿠벡툴 코드 베이스에 존재한다. 적용 로직을 쿠버네티스 API로 옮기기 위한 노력이 진행 중이지만, 아직 베타 버전이다. 이에 대한 자세한 내용은 아래에서 확인할 수 있다.

## By default, patch
리소스를 업데이트하려는 경우, 기본적으로 패치를 적용하는 것이 가장 좋다. 이는 쿠버네티스 클라이언트 라이브러리를 사용하든 kubectl을 사용하든 마찬가지이다.

### Be strategic
내부적으로, kubectl 적용, 편집 및 패치 커맨드는 모두 기존 리소스를 업데이트하기 위해 PATCH HTTP 요청 메서드를 사용한다. 더 구체적으로, 리소스를 업데이트할 때 모두 전략적 병합 패치 접근 방식을 사용하지만, 패치는 다른 접근 방식을 사용할 수도 있다(아래에서 자세히 설명한다). 전략적 병합 접근 방식은 제공된 사양을 기존 사양과 결합할 때 "올바른 작업"을 시도합니다. 좀 더 구체적으로 말하자면, 객체와 배열을 모두 병합하려고 시도하므로 변경 사항이 추가되는 경향이 있습니다. 예를 들어, 하나의 새로운 환경 변수가 포함된 패치를 파드 컨테이너 스펙에 제공하면 기존 환경 변수를 덮어쓰는 것이 아니라 해당 환경 변수가 기존 환경 변수에 추가된다. 이 접근 방식으로 프로퍼티를 삭제하려면 제공된 스펙에서 해당 값을 null로 구체적으로 설정해야 합니다. 그렇다면 업데이트하는 kubectl 서브커맨드 중 어떤 것을 사용하는 것이 가장 좋을까?

리소스를 생성하고 관리하는 경우, 업데이트할 때 항상 kubectl apply를 사용하는 것이 가장 좋으며, 그래야 kubectl이 구성을 관리하고 적용에서 적용으로 요청된 변경 사항을 적절하게 추적할 수 있다. 적용을 항상 사용하면 이전에 적용된 스펙을 추적하여 스펙 프로퍼티와 배열 요소가 명시적으로 제거된 시점을 알 수 있다는 이점이 있다. 따라서 일반적인 전략적 병합에서는 제거할 수 없는 프로퍼티와 배열 요소를 적용을 통해 제거할 수 있습니다. 편집 및 패치 명령은 변경 사항을 추적하는 데 사용하는 어노테이션을 업데이트하지 않으므로, 편집 및 패치로 수행한 모든 변경 사항은 쿠버네티스 API에 의해 추적되고 명시되지만 후속 적용 명령에는 보이지 않으므로 적용 입력 스펙[1]에 나타나지 않더라도 적용이 제거하지 않는다.

kubectl apply를 사용하지 않는 경우, 편집과 패치를 혼용하여 사용할 수 있으며, 수행하려는 특정 변경에 적합한 명령을 선택할 수 있다. 스펙 속성을 추가하고 변경할 때 두 접근 방식은 어느 정도 동일하다. 스펙 속성이나 배열 요소를 제거할 때 편집은 일회성 적용처럼 작동합니다. 즉, 편집하기 전과 후의 스펙을 추적하여 리소스에서 명시적으로 속성 및 배열 요소를 제거할 수 있습니다. 패치를 사용하면 리소스에서 프로퍼티를 제거하려면 패치 사양에서 프로퍼티의 값을 null로 명시적으로 설정해야 합니다. 전략적 병합 패치를 사용하여 배열 요소를 제거하는 것은 더 복잡하므로 병합 지시문을 사용해야 합니다. 보다 합리적인 대안은 아래의 다른 패치 방법을 참조하세요.

"패치" 클라이언트 라이브러리 메서드가 위의 kubectl 패치 서브커맨드와 유사하게 동작하도록 하려면, 요청의 콘텐츠 타입 헤더를 application/strategic-merge-patch+json으로 설정해야 한다. kubectl 패치와 마찬가지로, 스펙 프로퍼티를 제거하려면 명시적으로 해당 값을 null로 설정해야 한다. 배열 요소를 제거하려면 패치 스펙에 merge 지시문을 포함하거나 다른 패치 방식을 사용해야 한다.

