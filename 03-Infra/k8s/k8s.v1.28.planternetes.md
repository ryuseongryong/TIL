# Kubernetes v1.28: Planternetes

- https://kubernetes.io/blog/2023/08/15/kubernetes-v1-28-release/

## Changes to supported skew between control plane and node versions 
쿠버네티스 v1.28은 코어 노드와 컨트롤 플레인 구성 요소 간에 지원되는 스큐를 n-2에서 n-3으로 한 마이너 버전 확장하여, 가장 오래 지원되는 가장 오래된 마이너 버전의 노드 구성 요소(kubelet 및 kube-proxy)가 가장 최근에 지원되는 마이너 버전의 컨트롤 플레인 구성 요소(kube-apiserver, kube-scheduler, kube-controller-manager, cloud-controller-manager)와 작동하도록 한다.

일부 클러스터 운영자는 노드가 워크로드가 실행되는 곳이기 때문에 노드 유지 관리, 특히 노드 동작에 대한 변경을 피합니다. 쿠버렛에 대한 마이너 버전 업그레이드의 경우, 지원되는 프로세스에는 해당 노드를 배수하는 것이 포함되며, 따라서 해당 노드에서 실행 중이던 모든 파드에 대한 중단이 발생한다. 워크로드가 매우 오래 실행되고 가능한 한 파드가 계속 실행되어야 하는 Kubernetes 최종 사용자의 경우, 노드 유지보수로 인해 손실되는 시간을 줄이는 것이 이점이 됩니다.

Kubernetes 연간 지원 기간에 따라 이미 연간 업그레이드가 가능해졌습니다. 사용자는 최신 패치 버전으로 업그레이드하여 보안 수정 사항을 적용하고, 1년에 한 번씩 순차적으로 마이너 버전 업그레이드를 3번 수행하여 지원되는 최신 마이너 버전을 '따라잡을' 수 있습니다.

이전에는 지원되는 스큐를 유지하려면 연간 업그레이드를 계획하는 클러스터 운영자가 노드를 두 번(아마도 불과 몇 시간 간격으로) 업그레이드해야 했을 것입니다. 이제 Kubernetes v1.28에서는 1년에 한 번만 노드를 마이너 버전으로 업그레이드하고도 업스트림 지원을 계속 유지할 수 있습니다.

최신 버전을 유지하면서 클러스터를 더 자주 업그레이드하고 싶어도 괜찮으며 여전히 완벽하게 지원됩니다.

## Generally available: recovery from non-graceful node shutdown
노드가 예기치 않게 종료되거나 복구할 수 없는 상태가 되는 경우(하드웨어 오류 또는 응답하지 않는 OS로 인해), Kubernetes를 사용하면 나중에 정리하고 스테이트풀 워크로드가 다른 노드에서 다시 시작되도록 할 수 있습니다. Kubernetes v1.28에서는 이제 안정적인 기능이 되었습니다.

이를 통해 원래 노드가 종료되거나 하드웨어 장애 또는 OS 고장 등 복구할 수 없는 상태가 된 후에도 스테이트풀 워크로드가 다른 노드로 성공적으로 페일오버할 수 있습니다.

v1.20 이전 버전의 쿠버네티스에는 리눅스에서 노드 종료에 대한 처리가 부족했지만, kubelet은 systemd와 통합되어 유예된 노드 종료(베타 버전이며 기본적으로 활성화됨)를 구현한다. 그러나 의도적인 종료조차도 제대로 처리되지 않을 수 있습니다:

- 노드가 Windows를 실행한다.
- 노드가 리눅스를 실행하지만 다른 초기화(시스템드가 아닌)를 사용한다.
- 종료가 시스템 억제 잠금 메커니즘을 트리거하지 않는 경우.
- 노드 수준 구성 오류로 인해(예: shutdownGracePeriod 및 shutdownGracePeriodCriticalPods에 적절한 값을 설정하지 않음).

노드가 종료되거나 실패하고 해당 종료가 kubelet에 의해 감지되지 않은 경우, 스테이트풀셋의 일부인 파드는 종료 노드에서 종료 상태로 고착된다. 중지된 노드가 다시 시작되면, 해당 노드의 쿠버릿은 쿠버네티스 API가 여전히 해당 노드에 바인딩된 것으로 간주하는 파드를 정리(삭제)할 수 있다. 그러나 노드가 계속 중지된 상태이거나 재부팅 후 쿠버릿을 시작할 수 없는 경우, 쿠버네티스는 대체 파드를 생성하지 못할 수 있다. 종료된 노드의 쿠버릿이 이전 파드를 삭제할 수 없는 경우, 연결된 스테이트풀셋은 새 파드(동일한 이름)를 생성할 수 없다.

스토리지에도 문제가 있다. 파드에서 사용하는 볼륨이 있는 경우, 기존 볼륨 어태치먼트는 원래 노드(현재는 종료됨)에서 연결이 해제되지 않으므로 이러한 파드에서 사용하는 퍼시스턴트볼륨을 다른 정상 노드에 연결할 수 없습니다. 그 결과, 영향을 받는 스테이트풀셋에서 실행 중인 애플리케이션이 제대로 작동하지 않을 수 있다. 종료된 원래 노드가 나타나면, 해당 노드의 파드는 해당 쿠버릿에 의해 삭제되고 실행 중인 다른 노드에 새 파드를 생성할 수 있다. 원래 노드가 나타나지 않는 경우(불변 인프라 설계에서 일반적), 해당 파드는 종료된 노드에서 영원히 종료 상태에 머물러 있게 됩니다.

비유예 노드 종료 후 정리를 트리거하는 방법에 대한 자세한 내용은 비유예 노드 종료를 참조하세요.

## Improvements to CustomResourceDefinition validation rules
공통 표현식 언어(CEL)를 사용하여 사용자 정의 리소스의 유효성을 검사할 수 있습니다. 주요 목표는 웹훅을 디자인하고 구현하기 위해 사용자 정의 리소스 정의(CRD) 작성자가 필요했던 유효성 검사 사용 사례의 대부분을 허용하는 것입니다. 대신 베타 기능으로 CRD의 스키마에 직접 유효성 검사 표현식을 추가할 수 있습니다.

CRD는 사소하지 않은 유효성 검사에 대한 직접적인 지원이 필요합니다. 입학 웹후크가 CRD 유효성 검사를 지원하긴 하지만 CRD의 개발과 운영이 상당히 복잡해집니다.

1.28에서는 유효성 검사에 실패했을 때 사용자가 실패 이유와 필드 경로를 지정할 수 있도록 두 개의 선택적 필드 reason 및 fieldPath가 추가되었습니다.

자세한 내용은 CRD 문서에서 유효성 검사 규칙을 참조하세요.

## ValidatingAdmissionPolicies graduate to beta 
어드미션 제어를 위한 공통 표현식 언어는 어드미션 웹후크의 유효성 검사에 대한 대안으로 Kubernetes API 서버에 대한 요청을 사용자 정의할 수 있는 프로세스 중 유효성 검사입니다.

이는 1.25에서 베타 버전으로 전환된 CRD 유효성 검사 규칙 기능의 기능을 기반으로 하지만, 허용 제어 유효성 검사에 대한 정책 적용 기능에 중점을 두고 있습니다.

이를 통해 사용자 지정 가능한 정책 시행에 대한 인프라 장벽을 낮추고 커뮤니티가 K8과 그 확장 기능의 모범 사례를 수립하고 준수하는 데 도움이 되는 기본 요소를 제공할 수 있습니다.

ValidatingAdmissionPolicies를 사용하려면 클러스터의 컨트롤 플레인에서 admissionregistration.k8s.io/v1beta1 API 그룹과 ValidatingAdmissionPolicy 기능 게이트를 모두 활성화해야 합니다.

## Match conditions for admission webhooks 
쿠버네티스 v1.27에서는 어드미션 웹후크에 대한 일치 조건을 지정할 수 있으며, 이를 통해 어드미션 시점에 쿠버네티스가 원격 HTTP 호출을 하는 시점의 범위를 좁힐 수 있다. ValidatingWebhookConfiguration 및 MutatingWebhookConfiguration의 matchCondition 필드는 웹훅으로 어드미션 요청을 전송하기 위해 참으로 평가되어야 하는 CEL 표현식이다.

쿠버네티스 v1.28에서는 이 필드가 베타로 전환되었으며, 기본적으로 활성화되어 있다.

자세한 내용은 쿠버네티스 설명서에서 matchConditions를 참조하세요.

## Beta support for enabling swap space on Linux 
이렇게 하면 제어되고 예측 가능한 방식으로 노드에 스왑 지원이 추가되어 Kubernetes 사용자가 스왑을 기반으로 클러스터 기능을 계속 구축하기 위해 테스트를 수행하고 데이터를 제공할 수 있습니다.

스왑에는 두 가지 사용자 유형이 있으며, 이들은 서로 겹칠 수 있다:

- 노드 관리자는 노드 수준의 성능 튜닝과 안정성/노이즈가 많은 이웃 문제 감소를 위해 스왑을 사용하고자 할 수 있다.
- 스왑 메모리를 사용하면 이점을 얻을 수 있는 애플리케이션을 작성한 애플리케이션 개발자.

## Mixed version proxy (alpha)
클러스터에 여러 API 서버가 혼합된 버전으로 있는 경우(예: 업그레이드/다운그레이드 중 또는 런타임 구성이 변경되어 롤아웃이 발생하는 경우) 모든 Apiserver가 모든 버전에서 모든 리소스를 제공할 수 있는 것은 아닙니다.

쿠버네티스 v1.28의 경우, API 서버의 어그리게이션 레이어 내에서 혼합 버전 프록시를 활성화할 수 있다. 혼합 버전 프록시는 로컬 API 서버가 인식하지 못하지만 컨트롤 플랜 내의 다른 API 서버가 지원할 수 있는 요청을 찾는다. 적합한 피어를 찾으면 집계 계층은 요청을 호환 가능한 API 서버로 프록시하며, 이는 클라이언트 관점에서 투명하게 이루어집니다.

클러스터에서 업그레이드 또는 다운그레이드가 수행되면 일정 기간 동안 컨트롤 플레인 내의 API 서버가 서로 다른 버전에 있을 수 있으며, 이 경우 API 서버의 서로 다른 하위 집합이 서로 다른 기본 제공 리소스 세트(서로 다른 그룹, 버전, 리소스 모두 가능)에 서비스를 제공할 수 있습니다. 이 새로운 알파 메커니즘을 사용하면 클라이언트로부터 이러한 왜곡을 숨길 수 있습니다.

## Source code reorganization for control plane components
쿠버네티스 기여자들은 k/apiserver를 사용하지만 재사용할 수 있도록 신중하게 선택된 더 큰 하위 집합을 가진 새로운 스테이징 리포지토리를 기반으로 구축하기 위해 kube-apiserver의 코드를 재구성하기 시작했다.

이것은 점진적인 개편이며, 결국에는 Kubernetes의 API 서버에서 추상화된 일반 기능을 갖춘 새로운 git 리포지토리가 있을 것이다.

## Support for CDI injection into containers (alpha)
CDI는 복잡한 디바이스(즉, 논리적으로 단일 /dev 노드 이상을 주입해야 작동하는 디바이스)를 컨테이너에 주입할 수 있는 표준화된 방법을 제공합니다. 이 새로운 기능을 통해 플러그인 개발자는 1.27에서 CRI에 추가된 CDIDevices 필드를 활용하여 CDI 지원 런타임(컨테이너드와 크리오가 최근 릴리스에 포함됨)에 CDI 장치를 직접 전달할 수 있습니다.

## API awareness of sidecar containers (alpha)
쿠버네티스 1.28은 초기 컨테이너를 위한 알파 restartPolicy 필드를 도입하고, 이를 사용하여 초기 컨테이너가 사이드카 컨테이너이기도 한 경우를 나타낸다. kubelet은 restartPolicy로 초기화 컨테이너를 시작한다: 를 사용하여 항상 정의된 순서대로 다른 초기 컨테이너와 함께 초기화한다. 파드의 메인 컨테이너를 시작하기 전에 사이드카 컨테이너가 완료될 때까지 기다리는 대신, 쿠블릿은 사이드카 초기화 컨테이너가 시작될 때까지만 기다린다.

시작 프로브가 성공하고 포스트스타트 핸들러가 완료되면 사이드카 컨테이너에 대한 시작이 완료된 것으로 간주한다. 이 조건은 컨테이너 상태 유형의 Started 필드로 표시됩니다. 시작 프로브를 정의하지 않으면, kubelet은 postStart 핸들러가 완료된 직후 컨테이너 시작이 완료된 것으로 간주한다.

초기화 컨테이너의 경우 restartPolicy 필드를 생략하거나 항상으로 설정할 수 있습니다. 이 필드를 생략한다는 것은 애플리케이션 시작 전에 완료까지 실행되는 진정한 초기화 컨테이너를 원한다는 의미입니다.

사이드카 컨테이너는 파드 완료를 차단하지 않는다: 모든 일반 컨테이너가 완료되면, 해당 파드의 사이드카 컨테이너는 종료된다.

사이드카 컨테이너가 시작되고(프로세스가 실행 중이고, 포스트스타트가 성공했으며, 구성된 시작 프로브가 통과 중) 실패가 발생하면, 해당 사이드카 컨테이너는 파드의 전체 restartPolicy가 Never 또는 OnFailure일 때에도 재시작된다. 또한, 사이드카 컨테이너는 파드 종료 중에도 (실패 시 또는 정상 종료 시) 재시작된다.

자세한 내용은 사이드카 컨테이너용 API를 참고한다.

## Automatic, retroactive assignment of a default StorageClass graduates to stable 
값을 제공하지 않으면 쿠버네티스는 퍼시스턴트볼륨클레임(PVC)에 대한 스토리지클래스명을 자동으로 설정한다. 또한 컨트롤 플레인은 스토리지클래스 이름이 정의되지 않은 기존 PVC에 대해 스토리지클래스를 설정한다. 이전 버전의 쿠버네티스에서도 이 동작이 있었으나, 쿠버네티스 v1.28에서는 이 기능이 자동으로 항상 활성화되며, 이 기능은 안정(일반 사용 가능)으로 업그레이드되었다.

자세한 내용은 쿠버네티스 문서에서 스토리지클래스에 대해 읽어보자.

## ***Pod replacement policy for Jobs (alpha) 
쿠버네티스 1.28에는 이전 파드가 종료되기 시작하자마자 컨트롤 플레인이 새 파드를 만들 것인지(기존 동작), 아니면 기존 파드가 완전히 종료된 후에만 새 파드를 만들 것인지(새로운, 선택적 동작)를 지정할 수 있는 새로운 필드가 잡 API에 추가되었다.

텐서플로우와 JAX와 같은 많은 일반적인 머신 러닝 프레임워크는 인덱스당 고유한 파드를 필요로 합니다. 기존 동작을 사용하면, 인덱싱된 작업에 속한 파드가 (선점, 퇴거 또는 기타 외부 요인으로 인해) 종료 상태에 들어가면 대체 파드가 생성되지만 아직 종료되지 않은 이전 파드와의 충돌로 인해 즉시 시작되지 못합니다.

이전 파드가 완전히 종료되기 전에 대체 파드가 나타나면 리소스가 부족하거나 예산이 부족한 클러스터에서 문제가 발생할 수 있습니다. 이러한 리소스는 구하기 어려울 수 있으므로 기존 파드가 종료된 후에야 파드가 노드를 찾을 수 있을 수 있습니다. 클러스터 오토스케일러가 활성화된 경우, 대체 파드를 조기에 생성하면 원치 않는 스케일업이 발생할 수 있다.

자세한 내용은 작업 문서에서 대체 파드 생성 지연을 참조한다.

## Job retry backoff limit, per index (alpha) 
이것은 백오프 한도가 인덱스별로 설정되어 있고 일부 인덱스가 실패하더라도 작업이 계속 실행될 수 있는 인덱싱된 작업을 지원하도록 Job API를 확장합니다.

현재 인덱싱된 작업의 인덱스는 하나의 백오프 한도를 공유합니다. 작업이 이 공유 백오프 한도에 도달하면, 작업 컨트롤러는 전체 작업을 실패로 표시하고 아직 완료까지 실행되지 않은 인덱스를 포함해 리소스를 정리합니다.

그 결과, 기존 구현은 각 인덱스가 다른 인덱스와 완전히 독립적인, 워크로드가 정말 당황스러울 정도로 병렬인 상황을 다루지 못했습니다.

예를 들어, 인덱싱된 작업을 장기간 실행되는 통합 테스트 모음의 기반으로 사용하는 경우, 각 테스트 실행에서 단 하나의 테스트 실패만 발견할 수 있었습니다.

자세한 내용은 쿠버네티스 문서에서 파드 및 컨테이너 장애 처리하기를 참조한다.
