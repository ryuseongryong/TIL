- https://kubernetes.io/docs/concepts/cluster-administration/flow-control/

# API Priority and Fairness
과부하 상황에서 쿠버네티스 API 서버의 동작을 제어하는 것은 클러스터 관리자의 핵심 작업이다. kube-apiserver에는 수락할 미결 작업의 양을 제한하여 인바운드 요청의 홍수로 인해 과부하가 발생하여 API 서버가 충돌하는 것을 방지하는 몇 가지 제어 기능(예: `--max-requests-inflight` 및 `--max-mutating-requests-inflight`명령줄 플래그)이 있지만 트래픽이 많은 기간에 가장 중요한 요청이 통과하는 것을 보장하기에는 충분하지 않습니다.

API 우선순위 및 공정성 기능(APF)은 앞서 언급한 최대 기내 제한을 개선하는 대안입니다. APF는 요청을 보다 세분화된 방식으로 분류하고 격리합니다. 또한 제한된 양의 대기열을 도입하여 아주 짧은 시간 동안 요청이 폭주하는 경우에도 요청이 거부되지 않도록 합니다. 요청은 공정한 큐잉 기법을 사용하여 대기열에서 발송되므로, 예를 들어 우선 순위가 같은 경우에도 성능이 좋지 않은 컨트롤러가 다른 컨트롤러를 굶길 필요가 없습니다.

이 기능은 알림을 사용하고 지수 백오프를 통해 API 요청의 실패에 반응하는 표준 컨트롤러 및 이러한 방식으로 작동하는 다른 클라이언트와 잘 작동하도록 설계되었습니다.

주의: 원격 명령 실행 또는 로그 테일링과 같이 "장기 실행"으로 분류된 일부 요청은 API 우선순위 및 공정성 필터의 적용을 받지 않습니다. 이는 API 우선순위 및 공정성 기능이 활성화되지 않은 `--max-requests-inflight` 플래그의 경우에도 마찬가지입니다. API 우선순위 및 공정성 기능은 시청요청에 적용됩니다. API 우선순위 및 공정성 기능을 비활성화하면 감시 요청에 `--max-requests-inflight` 제한이 적용되지 않습니다.

## Enabling/Disabling API Priority and Fairness

API 우선순위 및 공정성 기능은 명령줄 플래그로 제어되며 기본적으로 활성화되어 있다. 사용 가능한 kube-apiserver 명령줄 옵션과 이를 활성화 및 비활성화하는 방법에 대한 일반적인 설명은옵션을참조한다. APF에 대한 명령줄 옵션의 이름은 "--enable-priority-and-fairness"입니다. 이 기능에는 다음과 같은 API 그룹도 포함된다: (a) 1.29에 도입되어 기본적으로 활성화된 안정적인 v1 버전 (b) 기본적으로 활성화되어 있고 v1.29에서 더 이상 사용되지 않는 v1beta3 버전. 다음 명령줄 플래그를 kube-apiserver 호출에 추가하여 API 그룹 베타 버전 v1beta3을 사용하지 않도록 설정할 수 있다:
```
kube-apiserver \
--runtime-config=flowcontrol.apiserver.k8s.io/v1beta3=false \.
 # ...그리고 평소와 같이 다른 플래그
```

명령줄 플래그 `--enable-priority-and-faireness=false`를 사용하면 API 우선순위 및 공정성 기능이 비활성화됩니다.

## Concepts
API 우선순위 및 공정성 기능에는 몇 가지 고유한 기능이 있습니다. 들어오는 요청은 플로우 스키마를 사용하여 요청의 속성에 따라 분류되고 우선순위 레벨에 할당됩니다. 우선순위 수준은 별도의 동시성 제한을 유지하여 서로 다른 우선순위 수준에 할당된 요청이 서로를 고갈시키지 않도록 격리 수준을 추가합니다. 우선순위 수준 내에서 공정한 큐잉 알고리즘은 서로 다른 흐름의 요청이 서로를 고사시키는 것을 방지하고, 평균 부하가 허용 가능한 수준으로 낮은 경우 트래픽 폭주로 인해 요청이 실패하는 것을 방지하기 위해 요청을 큐에 대기시킬 수 있도록 합니다.

### Priority Levels
APF를 활성화하지 않으면, API 서버의 전체 동시성은kube-apiserver 플래그 --max-requests-inflight 및--max-mutating-requests-inflight에 의해 제한됩니다. APF를 활성화하면 이러한 플래그로 정의된 동시성 제한이 합산된 다음 구성 가능한 우선순위 수준 집합에 따라 합이 나뉩니다. 각 수신 요청은 단일 우선순위 수준에 할당되며, 각 우선순위 수준은 특정 제한이 허용하는 만큼의 동시 요청만 발송합니다.

예를 들어, 기본 구성에는 리더 선출 요청, 빌트인 컨트롤러의 요청 및 파드의 요청에 대한 별도의 우선순위 수준이 포함되어 있다. 즉, API 서버에 요청이 폭주하는 잘못된 동작을 하는 파드는 리더 선출이나 빌트인 컨트롤러의 동작이 성공하는 것을 막을 수 없다.

우선순위 레벨의 동시성 한도는 주기적으로 조정되어 활용도가 낮은 우선순위 레벨이 활용도가 높은 레벨에 일시적으로 동시성을 빌려줄 수 있습니다. 이러한 제한은 우선순위 레벨이 빌려줄 수 있는 동시성 양과 빌릴 수 있는 양에 대한 명목상 제한과 한계를 기반으로 하며, 모두 아래에 설명된 구성 개체에서 파생됩니다.

### Seats Occupied by a Request 
위의 동시성 관리에 대한 설명은 기본 사례입니다. 요청의 지속 시간은 다르지만 우선순위 수준의 동시성 제한과 비교할 때 특정 순간에 동일하게 계산됩니다. 기준 스토리에서 각 요청은 하나의 동시성 단위를 차지합니다. '좌석'이라는 단어는 기차나 항공기의 각 승객이 정해진 좌석 중 하나를 차지하는 방식에서 착안한 동시성 단위로 사용됩니다.

하지만 일부 요청은 두 개 이상의 시트를 차지합니다. 이 중 일부는 서버가 많은 수의 객체를 반환할 것으로 예상되는 목록요청입니다. 이러한 요청은 서버에 매우 큰 부담을 주는 것으로 밝혀졌습니다. 이러한 이유로 서버는 반환될 객체 수를 추정하고 해당 요청이 해당 추정 수에 비례하는 수의 시트를 차지하도록 고려합니다.

### Execution time tweaks for watch requests
API 우선순위 및 공정성에서 감시 요청을 관리하지만, 여기에는 기본 동작에서 몇 가지 예외가 더 있습니다. 첫 번째는 감시 요청이 해당 좌석을 점유하는 것으로 간주되는 기간에 관한 것입니다. 요청 매개변수에 따라 감시 요청에 대한 응답은 모든 관련 기존 개체에 대한 알림 생성으로 시작될 수도 있고 그렇지 않을 수도 있습니다. API 우선순위 및 공정성에서는 초기 알림 버스트(있는 경우)가 끝나면 감시 요청이 해당 자리를 차지한 것으로 간주합니다.

일반적인 알림은 서버가 객체 생성/업데이트/삭제에 대한 알림을 받을 때마다 모든 관련 감시 응답 스트림에 동시 버스트로 전송됩니다. 이 작업을 고려하기 위해 API 우선순위 및 공정성에서는 모든 쓰기 요청이 실제 쓰기가 완료된 후 좌석을 점유하는 데 약간의 추가 시간을 소비하도록 고려합니다. 서버는 전송될 알림의 수를 추정하고 이 추가 작업을 포함하도록 쓰기 요청의 좌석 수와 좌석 점유 시간을 조정합니다.

### Queuing
우선순위 레벨 내에서도 수많은 별개의 트래픽 소스가 있을 수 있습니다. 과부하 상황에서는 한 요청 스트림이 다른 요청 스트림을 고사시키는 것을 방지하는 것이 중요합니다(특히 하나의 버그가 많은 클라이언트가 요청으로 kube-apiserver를 넘치게 하는 비교적 일반적인 경우, 그 버그 클라이언트는 다른 클라이언트에 측정 가능한 영향을 전혀 주지 않는 것이 이상적일 것입니다). 이는 동일한 우선순위 수준이 할당된 요청을 처리하기 위해 공정 대기열 알고리즘을 사용하여 처리됩니다. 각 요청은 일치하는 플로우스키마의 이름과 요청 사용자, 대상 리소스의 네임스페이스 또는 아무것도 아닌 플로우 구별자로 식별되는 플로우에 할당되며, 시스템은 동일한 우선 순위 수준의 다른 플로우에 있는 요청에 거의 동일한 가중치를 부여하려고 시도합니다. 여러 인스턴스를 별개로 처리하려면 인스턴스가 많은 컨트롤러가 별개의 사용자 이름으로 인증해야 합니다.

요청을 플로우로 분류한 후 API 우선순위 및 공정성 기능은 요청을 대기열에 할당할 수 있습니다. 이 할당은 셔플 샤딩이라는 기술을 사용하여 대기열을 비교적 효율적으로 사용하여 고집중 흐름과 저집중 흐름을 격리합니다.

큐잉 알고리즘의 세부 사항은 각 우선순위 수준에 따라 조정할 수 있으며 관리자는 메모리 사용, 공정성(총 트래픽이 용량을 초과할 때 독립적인 흐름이 모두 진행되도록 하는 속성), 폭주 트래픽에 대한 허용치, 큐잉으로 인한 추가 대기 시간 등을 균형 있게 조정할 수 있습니다.

### Exempt requests
일부 요청은 이 기능의 제한이 적용되지 않을 정도로 충분히 중요한 것으로 간주됩니다. 이러한 예외는 부적절하게 구성된 플로우 제어 구성으로 인해 API 서버가 완전히 비활성화되는 것을 방지합니다.

## Resources
플로우 제어 API에는 두 가지 종류의 리소스가 사용됩니다. 우선순위 레벨 구성은 사용 가능한 우선순위 수준, 각각 처리할 수 있는 사용 가능한 동시성 예산의 점유율을 정의하고 대기열 동작을 미세 조정할 수 있도록 합니다. 플로우 스키마는개별 인바운드 요청을 분류하여 각각을 단일 우선순위 레벨 구성에 일치시키는 데 사용됩니다.

### PriorityLevelConfiguration
우선순위 레벨 구성은 하나의 우선순위 수준을 나타냅니다. 각 우선순위 레벨 구성에는 미처리 요청 수에 대한 독립적인 제한과 대기 중인 요청 수에 대한 제한이 있습니다.

우선순위 레벨 구성의 명목 동시성 제한은 절대적인 좌석 수로 지정되지 않고 "명목 동시성 점유율"로 지정됩니다. API 서버의 총 동시성 제한은 이러한 공유에 비례하여 기존 PriorityLevelConfiguration에 분배되어 각 레벨에 시트 측면에서 명목상 제한을 부여합니다. 이렇게 하면 클러스터 관리자가 --max-requests-inflight(또는 --max-mutating-requests-inflight)에 대해 다른 값으로kube-apiserver를 다시 시작하여 서버의 총 트래픽 양을 늘리거나 줄일 수 있으며, 모든 PriorityLevelConfiguration은 최대 허용 동시성이 같은 비율만큼 증가(또는 감소)하게 됩니다.

주의: v1beta3 이전 버전에서는 관련 PriorityLevelConfiguration 필드의 이름이 "공칭 동시성 공유"가 아닌 "보장된 동시성 공유"로 지정되었습니다. 또한, 쿠버네티스 릴리스 1.25 이하에서는 주기적인 조정이 없었으며, 공칭/보장된 제한은 항상 조정 없이 적용되었습니다.

우선순위 레벨이 얼마나 많은 동시성을 빌려줄 수 있는지, 얼마나 빌릴 수 있는지에 대한 한계는 우선순위 레벨 구성에서 레벨의 공칭 한도의 백분율로 표현됩니다. 이는 명목상 한도/100.0을 곱한 후 반올림하여 절대 좌석 수로 해결됩니다. 우선순위 레벨의 동적으로 조정된 동시성 한도는 (a) 명목 한도의 하한에서 대여 가능한 좌석을 뺀 값과 (b) 명목 한도의 상한에서 대여 가능한 좌석을 더한 값 사이에 위치하도록 제한됩니다. 각 조정 시 동적 한도는 각 우선순위 레벨이 최근에 수요가 발생한 대여 좌석을 회수한 다음 방금 설명한 범위 내에서 우선순위 레벨의 최근 좌석 수요에 공동으로 공정하게 대응함으로써 도출됩니다.

주의: 우선순위 및 공정성 기능을 활성화하면 서버의 총 동시성 제한은 --max-requests-inflight와--max-mutating-requests-inflight의 합으로 설정됩니다. 더 이상 돌연변이 요청과 비돌연변이 요청을 구분하지 않으므로 특정 리소스에 대해 별도로 처리하려면 돌연변이 동사와 비돌연변이 동사에 각각 일치하는 별도의 플로우 스키마를 만드세요.

단일 우선순위 수준 구성에 할당된 인바운드 요청의 양이 허용된 동시성 수준보다 많으면 해당 사양의유형 필드에 따라 추가 요청이 어떻게 처리될지 결정됩니다. 거부 유형은 초과 트래픽이 HTTP 429(너무 많은 요청) 오류와 함께 즉시 거부됨을 의미합니다. 큐 유형은 임계값을 초과하는 요청이 큐에 대기하며, 셔플 샤딩 및 공정 큐 기술을 사용하여 요청 흐름 간 진행률의 균형을 맞추는 것을 의미합니다.

대기열 구성을 통해 우선순위 수준에 맞게 공정한 대기열 알고리즘을 조정할 수 있습니다. 알고리즘에 대한 자세한 내용은개선 제안서에서 확인할 수 있지만 간단히 요약하면 다음과 같습니다:

- 대기열을 늘리면 메모리 사용량이 증가하는 대신 서로 다른 흐름 간의 충돌 비율이 줄어듭니다. 여기서 값이 1이면 공정 큐 로직은 효과적으로 비활성화되지만 요청은 여전히 큐에 대기할 수 있습니다.

- 대기 시간 및 메모리 사용량을 늘리면 요청을 삭제하지 않고도 더 큰 트래픽 버스트를 지속할 수 있지만 지연 시간과 메모리 사용량이 증가합니다.

- handSize를 변경하면 과부하 상황에서 서로 다른 흐름 간의 충돌 확률과 단일 흐름에서 사용할 수 있는 전체 동시성을 조정할 수 있습니다.

참고: handSize가 클수록 두 개의 개별 흐름이 충돌할 가능성은 줄어들지만(따라서 한 흐름이 다른 흐름을 고갈시킬 수 있음), 소수의 흐름이 에이피저를 지배할 가능성은 높아집니다. 또한 핸드사이즈가 클수록 트래픽이 많은 단일 플로우로 인해 발생할 수 있는 지연 시간도 늘어날 수 있습니다. 단일 플로우에서 가능한 대기 중인 요청의 최대 수는 handSize * queueLengthLimit입니다.

다음은 셔플 샤딩 구성의 흥미로운 모음을 보여주는 표로, 주어진 마우스(저강도 흐름)가 코끼리(고강도 흐름)에 의해 찌그러질 확률을 각각에 대해 코끼리 수의 예시적인 모음을 보여 줍니다. 이 표를 계산하는 https://play.golang.org/p/Gi0PLgVHiUg을 참조하세요.

### FlowSchema
플로우 스키마는 일부 인바운드 요청을 일치시키고 우선순위를 할당합니다. 모든 인바운드 요청은 수치상 매칭 우선순위가 가장 낮은 요청부터 시작하여 위로 올라가는 순서로 FlowSchema에 대해 테스트됩니다. 가장 먼저 일치하는 것이 승리합니다.

주의: 주어진 요청에 대해 가장 먼저 일치하는 FlowSchema만 중요합니다. 하나의 인바운드 요청에 여러 개의 플로우 스키마가 일치하는 경우 일치 우선순위가 가장 높은 플로우 스키마에 따라 요청이 할당됩니다.일치 우선순위가 동일한 여러 개의 FlowSchema가 동일한 요청과 일치하는 경우 사전적으로 이름이 더 작은 것이 우선하지만, 이에 의존하지 말고 두 개의 FlowSchema가 동일한 일치 우선순위를 갖지 않도록 하는 것이 좋습니다.
플로우 스키마는 해당 규칙중 하나 이상이 일치하면 주어진 요청과 일치합니다. 들어오는 요청이 리소스에 대한 요청인지 비리소스 URL에 대한 요청인지에 따라 해당 규칙의 주체 중 하나 이상과 리소스 규칙 또는 비리소스 규칙 중 하나 이상이 요청과 일치하는 경우 규칙이 일치합니다.

주제의 이름 필드와 리소스 및 비리소스 규칙의 동사, apiGroups, 리소스,네임스페이스 및 비ResourceURLs 필드에 대해 와일드카드 *를 지정하여 지정된 필드의 모든 값과 일치하도록 하여 고려 대상에서 효과적으로 제거할 수 있습니다.

FlowSchema의 distinguisherMethod.type은 해당 스키마와 일치하는 요청을 플로우로 분리하는 방법을 결정합니다. 요청하는 사용자 한 명이 다른 사용자의 용량을 고갈시키지 않는 ByUser, 한 네임스페이스의 리소스에 대한 요청이 다른 네임스페이스의 리소스에 대한 요청을 용량 고갈시키지 않는 ByNamespace, 이 FlowSchema와 일치하는 모든 요청이 단일 흐름의 일부로 간주되는 빈(또는 distinguisherMethod를 완전히 생략할 수 있음)이 될 수도 있고, 이 두 가지 중 하나를 선택할 수 있습니다. 주어진 FlowSchema에 대한 올바른 선택은 리소스와 특정 환경에 따라 달라집니다.

## Defaults
각 kube-apiserver는 필수와 권장의 두 가지 종류의 APF 구성 개체를 유지합니다.

### Mandatory Configuration Objects
네 가지 필수 구성 개체는 고정된 기본 제공 가드레일 동작을 반영합니다. 이는 해당 개체가 존재하기 전에 서버에 있는 동작이며, 해당 개체가 존재하면 사양에 이 동작이 반영됩니다. 네 가지 필수 개체는 다음과 같습니다.

- 필수 면제 우선순위 수준은 흐름 제어가 전혀 적용되지 않는 요청에 사용되며, 항상 즉시 발송됩니다. 필수 면제 흐름 스키마는 system:masters 그룹의 모든 요청을 이 우선순위 수준으로 분류합니다. 적절한 경우 다른 요청을 이 우선순위 수준으로 지정하는 다른 플로우 스키마를 정의할 수 있습니다.

- 필수 포괄적 우선순위 수준은 모든 요청이 어떤 종류의 분류를 받도록 하기 위해 필수 포괄적 FlowSchema와 함께 사용됩니다. 일반적으로 이 포괄적 구성에 의존해서는 안 되며, 자체 포괄적 FlowSchema 및 PriorityLevelConfiguration을 적절히 생성하거나 기본적으로 설치되는 제안된전역 기본 우선순위 수준을 사용해야 합니다. 필수 캐치올 우선순위 수준은 일반적으로 사용되지 않을 것으로 예상되므로 동시성 점유율이 매우 작고 요청을 큐에 넣지 않습니다.

### Suggested Configuration Objects

제안된 플로우 스키마 및 우선순위 레벨 구성은 합리적인 기본 구성을 구성합니다. 원하는 경우 이를 수정하거나 추가 구성 개체를 만들 수 있습니다. 클러스터에 과부하가 발생할 가능성이 있는 경우에는 어떤 구성이 가장 적합한지 고려해야 합니다.

제안된 구성은 요청을 6가지 우선 순위 수준으로 그룹화합니다:

- 노드 우선순위 수준은 노드의 상태 업데이트를 위한 것입니다.

- 시스템 우선순위 수준은시스템:노드 그룹의 비건강 요청, 즉 워크로드가 해당 서버에서 스케줄링할 수 있으려면 API 서버에 연결할 수 있어야 하는 Kubelets에 대한 것입니다.

- 리더 선출 우선순위 레벨은 기본 제공 컨트롤러의 리더 선출 요청(특히, 시스템네임스페이스의 시스템:kube-controller-manager 또는시스템:kube-scheduler 사용자 및 서비스 계정에서 오는 엔드포인트, 컨피그맵 또는 리스 요청)을 위한 것이다. 리더 선출에 실패하면 해당 컨트롤러가 실패하고 다시 시작되어 새 컨트롤러가 정보 제공자를 동기화하면서 더 많은 트래픽이 발생하므로 다른 트래픽과 격리하는 것이 중요합니다.

- 워크로드 우선 순위가 높은 수준은 기본 제공 컨트롤러의 다른 요청에 대한 것입니다.

- 워크로드-낮은 우선순위 수준은 다른 서비스 계정의 요청에 대한 것으로, 일반적으로 파드에서 실행되는 컨트롤러의 모든 요청을 포함한다.

- 글로벌 기본 우선순위 수준은 권한이 없는 사용자가 실행하는 대화형 kubectl 명령과 같은 다른 모든 트래픽을 처리한다.

제안된 플로우스킴은 요청을 위의 우선순위 수준으로 조정하는 역할을 하며, 여기서는 열거하지 않습니다.

### Maintenance of the Mandatory and Suggested Configuration Objects
각 큐브-애피저버는 초기 및 주기적 동작을 사용하여 필수 및 권장 구성 개체를 독립적으로 유지 관리합니다. 따라서 서로 다른 버전의 서버가 혼합된 상황에서는 서버마다 이러한 개체의 적절한 내용에 대한 의견이 다른 한 스래싱이 발생할 수 있습니다.

각 kube-apiser버는 필수 및 권장 구성 개체에 대해 초기 유지 관리 패스를 수행하고, 그 후에는 해당 개체에 대한 주기적 유지 관리(1분에 한 번)를 수행합니다.

필수 구성 개체의 경우 유지 관리는 해당 개체가 존재하는지, 존재하는 경우 적절한 사양을 가지고 있는지 확인하는 것으로 구성됩니다. 서버는 서버의 가드레일 동작과 일치하지 않는 사양으로 생성 또는 업데이트하는 것을 허용하지 않습니다.

제안된 구성 개체의 유지 관리는 해당 사양을 재정의할 수 있도록 설계되었습니다. 반면에 삭제는 존중되지 않으므로 유지 관리를 하면 개체가 복원됩니다. 제안된 구성 개체를 원하지 않는 경우에는 유지하되 그 사양이 최소한의 영향을 미치도록 설정해야 합니다. 제안된 오브젝트의 유지 관리는 또한 서버가 혼합되어 있는 동안 잠재적으로 스래싱이 발생할 수 있지만 새 버전의 kube-apiserver가 롤아웃될 때 자동 마이그레이션을 지원하도록 설계되었습니다.

제안된 구성 오브젝트의 유지 관리는 오브젝트가 존재하지 않는 경우 서버의 제안된 사양으로 오브젝트를 생성하는 것으로 구성된다. 반대로, 오브젝트가 이미 존재하는 경우, 유지 관리 동작은 kube-apiservers 또는 사용자가 오브젝트를 제어하는지 여부에 따라 달라진다. 전자의 경우, 서버는 오브젝트의 사양이 서버가 제안한 사양인지 확인하고, 후자의 경우 사양은 그대로 둡니다.

누가 오브젝트를 제어하는지에 대한 질문은 먼저 apf.kubernetes.io/autoupdate-spec 키가 있는 어노테이션을 찾으면 답을 얻을 수 있다. 그러한 어노테이션이 있고 그 값이 참이면, kube-apiservers가 오브젝트를 제어한다. 그러한 어노테이션이 있고 그 값이 거짓이면 사용자가 오브젝트를 제어한다. 이 조건 중 어느 것도 해당하지 않으면 오브젝트의 metadata.generation을 참조합니다. 이 값이 1이면 kube-apiserver가 오브젝트를 제어합니다. 그렇지 않으면 사용자가 오브젝트를 제어합니다. 이러한 규칙은 릴리스 1.22에 도입되었으며,메타데이터 생성에 대한 고려는 이전의 단순한 동작에서 마이그레이션하기 위한 것이다. 제안된 구성 오브젝트를 제어하려는 사용자는 해당 오브젝트의 apf.kubernetes.io/autoupdate-spec 어노테이션을 false로 설정해야 한다.

필수 또는 권장 구성 오브젝트의 유지 관리에는 kube-apiservers가 오브젝트를 제어하는지 여부를 정확하게 반영하는 apf.kubernetes.io/autoupdate-spec어노테이션이 있는지 확인하는 것도 포함된다.

유지 관리에는 필수도 아니고 권장도 아니지만 주석이apf.kubernetes.io/autoupdate-spec=true인 오브젝트를 삭제하는 것도 포함된다.

## Health check concurrency exemption
제안된 구성은 보안 포트를 사용하지만 자격 증명을 제공하지 않는 경향이 있는 로컬 kubelets의 kube-apiserver에 대한 상태 확인 요청에 대해 특별한 처리를 제공하지 않습니다. 제안된 구성을 사용하면 이러한 요청이 글로벌 기본FlowSchema와 해당 글로벌 기본 우선순위 수준에 할당되어 다른 트래픽에 밀릴 수 있습니다.

다음과 같은 FlowSchema를 추가하면 해당 요청이 속도 제한에서 면제됩니다.

주의: 이 변경을 수행하면 모든 적대적인 당사자가 이 플로우 스키마와 일치하는 상태 확인 요청을 원하는 양만큼 보낼 수 있습니다. 클러스터의 API 서버를 일반 인터넷 트래픽으로부터 보호하기 위해 웹 트래픽 필터 또는 이와 유사한 외부 보안 메커니즘을 사용하는 경우 클러스터 외부에서 발생하는 모든 상태 확인 요청을 차단하도록 규칙을 구성할 수 있습니다.
```
apiVersion: flowcontrol.apiserver.k8s.io/v1
kind: FlowSchema
metadata:
  name: health-for-strangers
spec:
  matchingPrecedence: 1000
  priorityLevelConfiguration:
    name: exempt
  rules:
    - nonResourceRules:
      - nonResourceURLs:
          - "/healthz"
          - "/livez"
          - "/readyz"
        verbs:
          - "*"
      subjects:
        - kind: Group
          group:
            name: "system:unauthenticated"

```

## Observability
### Metrics

참고: v1.20 이전 버전의 Kubernetes에서는 레이블 flow_schema 및priority_level의 이름이 각각 흐름 스키마 및 우선순위 레벨로 일관되지 않게 지정되었습니다. Kubernetes 버전 v1.19 이하를 실행 중인 경우 해당 버전에 대한 설명서를 참조해야 합니다.

API 우선순위 및 공정성 기능을 활성화하면, kube-apiserver는 추가 메트릭을 내보냅니다. 이러한 지표를 모니터링하면 구성이 중요한 트래픽을 부적절하게 스로틀링하고 있는지 또는 시스템 상태를 해칠 수 있는 제대로 동작하지 않는 워크로드를 찾는 데 도움이 될 수 있습니다.

### Maturity level BETA

- apiserver_flowcontrol_rejected_requests_total은 거부된 요청의 카운터 벡터(서버 시작 이후 누적)로, 요청과 일치하는 요청을 나타내는 flow_schema, 요청이 할당된 요청을 나타내는 priority_level 및 이유 레이블로 세분화합니다. 이유 레이블은 다음 값 중 하나입니다:

    - 대기열이 가득 차서 이미 너무 많은 요청이 대기열에 들어갔음을 나타냅니다.
    - 동시성 제한을 설정하여 초과 요청을 대기열에 넣지 않고 거부하도록 우선순위 수준 구성이 구성되었음을 나타냅니다.
    - 시간 초과, 대기 시간 제한이 만료되었을 때 요청이 여전히 대기열에 있었음을 나타냅니다.
    - 취소됨, 요청이 잠기지 않았으며 대기열에서 제거되었음을 나타냅니다.

- apiserver_flowcontrol_dispatched_requests_total은 실행을 시작한 요청의 카운터 벡터(서버 시작 이후 누적)로, 흐름 스키마 및 우선순위 수준에 따라 분류됩니다.

- apiserver_flowcontrol_current_inqueue_requests는 대기 중인(실행 중이 아닌) 요청의 순간 수를 나타내는 게이지 벡터로, 우선순위_수준과 흐름 스키마별로 세분화되어 있습니다.

- apiserver_flowcontrol_current_executing_requests는 실행 중인(큐에서 대기 중이 아닌) 요청의 순간 수를 나타내는 게이지 벡터로, 우선순위_수준과 흐름_스키마에 따라 세분화되어 있습니다.

- apiserver_flowcontrol_current_executing_seats는우선순위_레벨과 흐름_스케마에 따라 세분화된 순간 점유 좌석 수를 나타내는 게이지 벡터입니다.

- apiserver_flowcontrol_request_wait_duration_seconds는 요청이 대기된 시간을 나타내는 히스토그램 벡터로,flow_schema, priority_level, execute 레이블로 세분화되어 있습니다. 실행 레이블은 요청이 실행을 시작했는지 여부를 나타냅니다.

참고: 각 플로우 스키마는 항상 단일 우선순위 레벨 구성에 요청을 할당하므로, 하나의 우선순위 레벨에 대한 모든 플로우 스키마의 히스토그램을 추가하여 해당 우선순위 레벨에 할당된 요청의 유효 히스토그램을 얻을 수 있습니다.

- apiserver_flowcontrol_nominal_limit_seats는 각 우선순위 레벨의 공칭 동시성 제한을 나타내는 게이지 벡터로, API 서버의 총 동시성 제한과 우선순위 레벨의 구성된 공칭 동시성 점유율에서 계산됩니다.

### Maturity level ALPHA

- apiserver_current_inqueue_requests는 대기 중인 요청 수의 최근 최고 수치를 나타내는 게이지 벡터로, 요청_종류라는 레이블로 그룹화되며 값은 변하는 또는 읽기 전용입니다. 이러한 최고 수치는 가장 최근에 완료된 1초 창에 표시된 가장 큰 수치를 나타냅니다. 이는 활발히 처리 중인 요청 수의 마지막 윈도우의 최고 수치를 나타내는 이전 apiserver_current_inflight_requests 게이지 벡터를 보완합니다.

- apiserver_current_inqueue_seats는 각 요청이 차지하는 최대 좌석 수에 대한 대기열 요청의 합계를 게이지 벡터로, flow_schema 및 priority_level이라는 레이블로 그룹화합니다.

- apiserver_flowcontrol_read_vs_write_current_requests는 매 나노초가 끝날 때마다 라벨단계 ( 대기 중 및 실행 중 값)와요청 종류 ( 변경 및읽기 전용 값)에 따라 분류된 요청 수를 관측한 히스토그램 벡터입니다. 관측된 각 값은 요청 수를 해당 요청 수에 대한 제한(대기 중인 경우 큐 볼륨 제한, 실행 중인 경우 동시성 제한)으로 나눈 비율로 0과 1 사이의 값입니다.

- apiserver_flowcontrol_request_concurrency_in_use는우선순위_레벨과 흐름_스케마에 따라 세분화된 순간 점유 좌석 수를 나타내는 게이지 벡터입니다.

- apiserver_flowcontrol_priority_level_request_utilization은 매 나노초가 끝날 때마다 라벨단계 ( 대기 중 및 실행 중 값을 취함)와우선순위 수준에 따라 분류된 요청 수에 대한 관측치의 히스토그램 벡터입니다. 관측된 각 값은 요청 수를 해당 요청 수에 대한 제한(대기 중인 경우 큐 볼륨 제한, 실행 중인 경우 동시성 제한)으로 나눈 0과 1 사이의 비율입니다.

- apiserver_flowcontrol_priority_level_seat_utilization은 매 나노초가 끝날 때마다 우선순위 레벨의 동시성 제한 활용도를 우선순위 레벨별로 세분화하여 관측한 히스토그램 벡터입니다. 이 사용률은 (점유된 좌석 수)/(동시성 제한)의 비율입니다. 이 메트릭은 WATCH를 제외한 모든 요청의 모든 실행 단계(정상 및 해당 알림 작업을 처리하기 위한 쓰기 종료 시 추가 지연 모두)를 고려하며, 기존 개체에 대한 알림을 전달하는 초기 단계만 고려합니다. 벡터의 각 히스토그램에는 단계: 실행 중 (대기 단계에는 좌석 제한이 없음)으로 레이블이 지정되어 있습니다.

- apiserver_flowcontrol_request_queue_length_after_enqueue는 큐에 대기 중인 요청에서 샘플링한 대기열 길이의 히스토그램 벡터로,우선순위_수준 및 흐름 스키마별로 분류됩니다. 대기 중인 각 요청은 요청이 추가된 직후 대기열의 길이를 보고하면서 히스토그램에 하나의 샘플을 제공합니다. 이렇게 하면 편견 없는 조사와는 다른 통계가 생성됩니다.

참고: 여기서 히스토그램의 이상값은 단일 흐름(즉, 구성에 따라 한 사용자 또는 한 네임스페이스에 대한 요청)이 API 서버에 폭주하여 스로틀링되고 있을 가능성이 높다는 의미입니다. 반대로 한 우선순위 수준의 히스토그램에서 해당 우선순위 수준에 대한 모든 대기열이 다른 우선순위 수준에 대한 대기열보다 길다면 해당 우선순위 수준 구성의 동시성 공유를 늘리는 것이 적절할 수 있습니다.

- apiserver_flowcontrol_request_concurrency_limit은apiserver_flowcontrol_nominal_limit_seats와 동일합니다. 우선순위 수준 간 동시성 차용이 도입되기 전에는 이 값은 항상 apiserver_flowcontrol_current_limit_seats(별도의 메트릭으로 존재하지 않았습니다)와 같았습니다.

- apiserver_flowcontrol_lower_limit_seats는 각 우선순위 레벨의 동적 동시성 제한의 하한을 나타내는 게이지 벡터입니다.

- apiserver_flowcontrol_상한선_seats는 각 우선순위 레벨의 동적 동시성 제한의 상한을 나타내는 게이지 벡터입니다.

- apiserver_flowcontrol_demand_seats는 매 나노초마다 각 우선순위 레벨의 (좌석 수요) / (공칭 동시성 제한) 비율에 대한 관측치를 계산하는 히스토그램 벡터입니다. 우선순위 수준의 좌석 수요는 대기 중인 요청과 실행 초기 단계에 있는 요청을 모두 합산하여 요청의 초기 및 최종 실행 단계에서 점유한 좌석 수의 최대값을 나타냅니다.

- apiserver_flowcontrol_demand_seats_high_watermark는 각 우선순위 레벨에 대해 마지막 동시성 차입 조정 기간 동안 나타난 최대 좌석 수요를 나타내는 게이지 벡터입니다.

- apiserver_flowcontrol_demand_seats_평균은 각 우선순위 레벨에 대해 마지막 동시성 차입 조정 기간 동안 나타난 시간 가중 평균 좌석 수요를 나타내는 게이지 벡터입니다.

- apiserver_flowcontrol_demand_seats_stdev는 각 우선순위 수준에 대해 마지막 동시성 차입 조정 기간 동안 나타난 좌석 수요의 시간 가중 인구 표준 편차를 나타내는 게이지 벡터입니다.

- apiserver_flowcontrol_demand_seats_smoothed는 각 우선순위 레벨에 대해 마지막 동시성 조정에서 결정된 평활화된 감싸기 좌석 수요를 포함하는 게이지 벡터입니다.

- apiserver_flowcontrol_target_seats는 각 우선순위 레벨에 대해 차입 할당 문제에 들어가는 동시성 목표를 나타내는 게이지 벡터입니다.

- apiserver_flowcontrol_seat_fair_frac은 마지막 차입금 조정에서 결정된 공정 할당 비율을 나타내는 게이지입니다.

- apiserver_flowcontrol_current_limit_seats는 각 우선순위 레벨에 대해 마지막 조정에서 도출된 동적 동시성 제한을 유지하는 게이지 벡터입니다.

- apiserver_flowcontrol_request_execution_seconds는 요청이 실제로 실행되는 데 걸린 시간을 히스토그램 벡터로 나타낸 것으로,흐름 스키마 및 우선순위 수준에 따라 세분화되어 있습니다.

- apiserver_flowcontrol_watch_count_samples는 주어진 쓰기와 관련된 활성 WATCH 요청의 수를 흐름 스키마 및 우선순위 수준에 따라 세분화한 히스토그램 벡터입니다.

- apiserver_flowcontrol_work_estimated_seats는 요청과 관련된 예상 좌석 수(초기 및 최종 실행 단계의 최대)의 히스토그램 벡터로, 흐름 스키마및 우선순위 수준에 따라 세분화되어 있습니다.

- apiserver_flowcontrol_request_dispatch_no_accommodation_total은 원칙적으로 요청이 발송될 수 있었지만 사용 가능한 동시성 부족으로 인해 발송되지 않은 이벤트 수를 플로우 스키마와 우선순위 수준에 따라 세분화한 카운터 벡터입니다.

- apiserver_flowcontrol_epoch_advance_total은 숫자 오버플로를 방지하기 위해 우선순위 레벨의 진행률 미터를 뒤로 이동하려는 시도 횟수를 우선순위 레벨과성공으로 그룹화하여 카운터 벡터로 나타낸 값입니다.

## Good practices for using API Priority and Fairness
주어진 우선순위 수준이 허용된 동시성을 초과하면 지연 시간이 증가하거나 HTTP 429(너무 많은 요청) 오류와 함께 요청이 삭제될 수 있습니다. APF의 이러한 부작용을 방지하려면 워크로드를 수정하거나 APF 설정을 조정하여 요청을 처리할 수 있는 충분한 시트를 확보할 수 있습니다.

APF로 인해 요청이 거부되고 있는지 확인하려면 다음 메트릭을 확인하세요:

- apiserver_flowcontrol_rejected_requests_total: 흐름 스키마 및 우선순위 수준 구성당 거부된 요청의 총 수입니다.
- apiserver_flowcontrol_current_inqueue_requests: 흐름 스키마 및 우선순위 수준 구성당 현재 대기 중인 요청 수입니다.
- apiserver_flowcontrol_request_wait_duration_seconds: 대기열에서 대기 중인 요청에 추가되는 대기 시간입니다.
- apiserver_flowcontrol_priority_level_seat_utilization: 우선순위 레벨 구성에 따른 좌석 활용률입니다.

### Workload modifications
요청이 대기열에 추가되어 지연 시간이 길어지거나 APF로 인해 요청이 삭제되는 것을 방지하려면 다음과 같이 요청을 최적화할 수 있습니다:

- 요청이 실행되는 속도를 줄입니다. 일정 기간 동안 요청 횟수가 줄어들면 주어진 시간에 필요한 좌석 수가 줄어듭니다.
- 많은 수의 고비용 요청을 동시에 발행하지 마세요. 요청을 최적화하여 더 적은 시트를 사용하거나 지연 시간을 낮추어 요청이 더 짧은 기간 동안 해당 시트를 보유하도록 할 수 있습니다. 목록 요청은 요청 중에 가져오는 객체 수에 따라 1개 이상의 시트를 차지할 수 있습니다. 예를 들어 페이지 매김을 사용하여 목록 요청에서 검색되는 객체 수를 제한하면 더 짧은 기간 동안 더 적은 총 시트를 사용할 수 있습니다. 또한 목록 요청을 시청 요청으로 대체하면 시청 요청이 초기 알림 버스트 동안 1석만 차지하므로 총 동시성 점유율이 낮아집니다. 버전 1.27 이상에서 스트리밍 목록을 사용하는 경우 컬렉션의 전체 상태를 스트리밍해야 하므로 시청 요청은 초기 알림 버스트에서 목록 요청과 동일한 수의 시트를 차지하게 됩니다. 두 경우 모두 이 초기 단계 이후에는 시청 요청이 좌석을 차지하지 않는다는 점에 유의하세요.

요청 수가 증가하거나 기존 요청의 지연 시간이 증가하여 APF에서 요청이 대기 중이거나 거부될 수 있다는 점에 유의하세요. 예를 들어, 일반적으로 1초가 걸리던 요청이 60초가 걸리기 시작하면 지연 시간 증가로 인해 요청이 평소보다 더 오랜 시간 동안 시트를 점유하고 있기 때문에 APF가 요청을 거부하기 시작할 수 있습니다. 워크로드에 큰 변화 없이 여러 우선순위 수준에서 APF가 요청을 거부하기 시작하면 워크로드나 APF 설정이 아닌 컨트롤 플레인 성능에 근본적인 문제가 있을 수 있습니다.

### Priority and fairness settings
또한 워크로드를 더 잘 수용하기 위해 기본 FlowSchema 및 PriorityLevelConfiguration 개체를 수정하거나 이러한 유형의 새 개체를 만들 수도 있습니다.

APF 설정을 다음과 같이 수정할 수 있습니다:

- 우선순위가 높은 요청에 더 많은 좌석을 배정하세요.
- 다른 흐름과 공유될 경우 동시성 수준을 고갈시킬 수 있는 비필수적이거나 비용이 많이 드는 요청은 격리하세요.

#### Give more seats to high priority requests
1. 가능하다면, 특정 큐브-아피저버의 모든 우선순위 수준에서 사용 가능한 좌석 수를 최대-요청-인비테이션 및 최대-변형 요청-인비테이션 플래그의 값을 늘려서 늘릴 수 있습니다. 또는, 요청의 부하 분산이 충분하다는 가정 하에 큐브-아피저버 인스턴스 수를 수평적으로 확장하면 클러스터 전체에서 우선순위 수준당 총 동시성이 증가합니다.
2. 더 큰 동시성 레벨을 가진 우선순위 레벨 구성을 참조하는 새 플로우 스키마를 만들 수 있습니다. 이 새 우선순위 수준 구성은 기존 수준 또는 자체적인 명목 동시성 점유율을 가진 새 수준일 수 있습니다. 예를 들어, 요청에 대한 우선순위 수준 구성을 글로벌 기본값에서 작업 부하 낮음으로 변경하여 사용자가 사용할 수 있는 좌석 수를 늘리기 위해 새 FlowSchema를 도입할 수 있습니다. 새 우선순위 레벨 구성을 만들면 기존 레벨에 지정된 좌석 수가 줄어듭니다. 기본 플로우스케마 또는 프라이어리티레벨컨피규레이션을 편집하려면apf.kubernetes.io/autoupdate-spec 어노테이션을 false로 설정해야 한다는 것을 기억하자.
3. 우선순위가 높은 요청을 처리하는 우선순위 레벨 구성에 대해 NominalConcurrencyShares를 늘릴 수도 있습니다. 또는 버전 1.26 이상에서는 경쟁 우선순위 레벨에 대해 LendablePercent를 늘려 주어진 우선순위 레벨이 빌릴 수 있는 좌석 풀을 더 많이 보유하도록 할 수 있습니다.

#### Isolate non-essential requests from starving other flows
요청 격리를 위해 이러한 요청을 하는 사용자와 주제가 일치하는 FlowSchema를 만들거나 요청이 무엇인지(resourceRules에 해당)와 일치하는 FlowSchema를 만들 수 있습니다. 그런 다음 이 플로우 스키마를 좌석 점유율이 낮은 우선순위 레벨 구성에 매핑할 수 있습니다.

예를 들어, 기본 네임스페이스에서 실행 중인 파드의 리스트 이벤트 요청이 각각 10개의 시트를 사용하고 1분 동안 실행된다고 가정한다. 이러한 고비용 요청이 기존 서비스 어카운트 플로우스케마를 사용하는 다른 파드의 요청에 영향을 미치지 않도록 하려면, 다음 플로우스케마를 적용하여 이러한 목록 호출을 다른 요청으로부터 분리할 수 있다.

목록 이벤트 요청을 격리하기 위한 FlowSchema 객체 예시:
```
apiVersion: flowcontrol.apiserver.k8s.io/v1
kind: FlowSchema
metadata:
  name: list-events-default-service-account
spec:
  distinguisherMethod:
    type: ByUser
  matchingPrecedence: 8000
  priorityLevelConfiguration:
    name: catch-all
  rules:
    - resourceRules:
      - apiGroups:
          - '*'
        namespaces:
          - default
        resources:
          - events
        verbs:
          - list
      subjects:
        - kind: ServiceAccount
          serviceAccount:
            name: default
            namespace: default
```
- 이 플로우스케마는 기본 네임스페이스에서 기본 서비스 계정에 의해 수행된 모든 목록 이벤트 호출을 캡처합니다. 일치 우선 순위 8000은 기존 서비스 계정 FlowSchema에서 사용하는 값 9000보다 낮으므로 이러한 목록 이벤트 호출은 서비스 계정이 아닌 list-events-default-service-account와 일치합니다.
- 포괄적 우선순위 수준 구성은 이러한 요청을 격리하는 데 사용됩니다. 포괄적 우선순위 수준은 동시성 점유율이 매우 작으며 요청을 대기열에 넣지 않습니다.
